/*
  Face-API
  homepage: <https://github.com/vladmandic/face-api>
  author: <https://github.com/vladmandic>'
*/

var ZU=Object.create;var p0=Object.defineProperty;var JU=Object.getOwnPropertyDescriptor;var QU=Object.getOwnPropertyNames;var t4=Object.getPrototypeOf,e4=Object.prototype.hasOwnProperty;var gr=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),jt=(r,t)=>{for(var e in t)p0(r,e,{get:t[e],enumerable:!0})},r4=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of QU(t))!e4.call(r,o)&&o!==e&&p0(r,o,{get:()=>t[o],enumerable:!(n=JU(t,o))||n.enumerable});return r};var Tl=(r,t,e)=>(e=r!=null?ZU(t4(r)):{},r4(t||!r||!r.__esModule?p0(e,"default",{value:r,enumerable:!0}):e,r));var V1=gr((Flt,B1)=>{B1.exports=Ke;var po=null;try{po=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function Ke(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}Ke.prototype.__isLong__;Object.defineProperty(Ke.prototype,"__isLong__",{value:!0});function On(r){return(r&&r.__isLong__)===!0}Ke.isLong=On;var $1={},D1={};function Hu(r,t){var e,n,o;return t?(r>>>=0,(o=0<=r&&r<256)&&(n=D1[r],n)?n:(e=je(r,(r|0)<0?-1:0,!0),o&&(D1[r]=e),e)):(r|=0,(o=-128<=r&&r<128)&&(n=$1[r],n)?n:(e=je(r,r<0?-1:0,!1),o&&($1[r]=e),e))}Ke.fromInt=Hu;function mo(r,t){if(isNaN(r))return t?Uu:fo;if(t){if(r<0)return Uu;if(r>=P1)return z1}else{if(r<=-F1)return Fn;if(r+1>=F1)return M1}return r<0?mo(-r,t).neg():je(r%tm|0,r/tm|0,t)}Ke.fromNumber=mo;function je(r,t,e){return new Ke(r,t,e)}Ke.fromBits=je;var ex=Math.pow;function S0(r,t,e){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return fo;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return S0(r.substring(1),t,e).neg();for(var o=mo(ex(e,8)),s=fo,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),e);if(a<8){var l=mo(ex(e,a));s=s.mul(l).add(mo(u))}else s=s.mul(o),s=s.add(mo(u))}return s.unsigned=t,s}Ke.fromString=S0;function Ws(r,t){return typeof r=="number"?mo(r,t):typeof r=="string"?S0(r,t):je(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}Ke.fromValue=Ws;var R1=1<<16,S4=1<<24,tm=R1*R1,P1=tm*tm,F1=P1/2,O1=Hu(S4),fo=Hu(0);Ke.ZERO=fo;var Uu=Hu(0,!0);Ke.UZERO=Uu;var Qp=Hu(1);Ke.ONE=Qp;var L1=Hu(1,!0);Ke.UONE=L1;var I0=Hu(-1);Ke.NEG_ONE=I0;var M1=je(-1,2147483647,!1);Ke.MAX_VALUE=M1;var z1=je(-1,-1,!0);Ke.MAX_UNSIGNED_VALUE=z1;var Fn=je(0,-2147483648,!1);Ke.MIN_VALUE=Fn;var yt=Ke.prototype;yt.toInt=function(){return this.unsigned?this.low>>>0:this.low};yt.toNumber=function(){return this.unsigned?(this.high>>>0)*tm+(this.low>>>0):this.high*tm+(this.low>>>0)};yt.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Fn)){var e=mo(t),n=this.div(e),o=n.mul(e).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=mo(ex(t,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,c=l.toString(t);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};yt.getHighBits=function(){return this.high};yt.getHighBitsUnsigned=function(){return this.high>>>0};yt.getLowBits=function(){return this.low};yt.getLowBitsUnsigned=function(){return this.low>>>0};yt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Fn)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&(t&1<<e)==0;e--);return this.high!=0?e+33:e+1};yt.isZero=function(){return this.high===0&&this.low===0};yt.eqz=yt.isZero;yt.isNegative=function(){return!this.unsigned&&this.high<0};yt.isPositive=function(){return this.unsigned||this.high>=0};yt.isOdd=function(){return(this.low&1)===1};yt.isEven=function(){return(this.low&1)===0};yt.equals=function(t){return On(t)||(t=Ws(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};yt.eq=yt.equals;yt.notEquals=function(t){return!this.eq(t)};yt.neq=yt.notEquals;yt.ne=yt.notEquals;yt.lessThan=function(t){return this.comp(t)<0};yt.lt=yt.lessThan;yt.lessThanOrEqual=function(t){return this.comp(t)<=0};yt.lte=yt.lessThanOrEqual;yt.le=yt.lessThanOrEqual;yt.greaterThan=function(t){return this.comp(t)>0};yt.gt=yt.greaterThan;yt.greaterThanOrEqual=function(t){return this.comp(t)>=0};yt.gte=yt.greaterThanOrEqual;yt.ge=yt.greaterThanOrEqual;yt.compare=function(t){if(On(t)||(t=Ws(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};yt.comp=yt.compare;yt.negate=function(){return!this.unsigned&&this.eq(Fn)?Fn:this.not().add(Qp)};yt.neg=yt.negate;yt.add=function(t){On(t)||(t=Ws(t));var e=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,u=t.low>>>16,l=t.low&65535,c=0,p=0,m=0,f=0;return f+=s+l,m+=f>>>16,f&=65535,m+=o+u,p+=m>>>16,m&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,je(m<<16|f,c<<16|p,this.unsigned)};yt.subtract=function(t){return On(t)||(t=Ws(t)),this.add(t.neg())};yt.sub=yt.subtract;yt.multiply=function(t){if(this.isZero())return fo;if(On(t)||(t=Ws(t)),po){var e=po.mul(this.low,this.high,t.low,t.high);return je(e,po.get_high(),this.unsigned)}if(t.isZero())return fo;if(this.eq(Fn))return t.isOdd()?Fn:fo;if(t.eq(Fn))return this.isOdd()?Fn:fo;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(O1)&&t.lt(O1))return mo(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,u=t.high&65535,l=t.low>>>16,c=t.low&65535,p=0,m=0,f=0,d=0;return d+=i*c,f+=d>>>16,d&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=i*l,m+=f>>>16,f&=65535,m+=o*c,p+=m>>>16,m&=65535,m+=s*l,p+=m>>>16,m&=65535,m+=i*u,p+=m>>>16,m&=65535,p+=n*c+o*l+s*u+i*a,p&=65535,je(f<<16|d,p<<16|m,this.unsigned)};yt.mul=yt.multiply;yt.divide=function(t){if(On(t)||(t=Ws(t)),t.isZero())throw Error("division by zero");if(po){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?po.div_u:po.div_s)(this.low,this.high,t.low,t.high);return je(e,po.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Uu:fo;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return Uu;if(t.gt(this.shru(1)))return L1;s=Uu}else{if(this.eq(Fn)){if(t.eq(Qp)||t.eq(I0))return Fn;if(t.eq(Fn))return Qp;var i=this.shr(1);return n=i.div(t).shl(1),n.eq(fo)?t.isNegative()?Qp:I0:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(Fn))return this.unsigned?Uu:fo;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=fo}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:ex(2,a-48),l=mo(n),c=l.mul(t);c.isNegative()||c.gt(o);)n-=u,l=mo(n,this.unsigned),c=l.mul(t);l.isZero()&&(l=Qp),s=s.add(l),o=o.sub(c)}return s};yt.div=yt.divide;yt.modulo=function(t){if(On(t)||(t=Ws(t)),po){var e=(this.unsigned?po.rem_u:po.rem_s)(this.low,this.high,t.low,t.high);return je(e,po.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};yt.mod=yt.modulo;yt.rem=yt.modulo;yt.not=function(){return je(~this.low,~this.high,this.unsigned)};yt.and=function(t){return On(t)||(t=Ws(t)),je(this.low&t.low,this.high&t.high,this.unsigned)};yt.or=function(t){return On(t)||(t=Ws(t)),je(this.low|t.low,this.high|t.high,this.unsigned)};yt.xor=function(t){return On(t)||(t=Ws(t)),je(this.low^t.low,this.high^t.high,this.unsigned)};yt.shiftLeft=function(t){return On(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?je(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):je(0,this.low<<t-32,this.unsigned)};yt.shl=yt.shiftLeft;yt.shiftRight=function(t){return On(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?je(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):je(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};yt.shr=yt.shiftRight;yt.shiftRightUnsigned=function(t){if(On(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var n=this.low;return je(n>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?je(e,0,this.unsigned):je(e>>>t-32,0,this.unsigned)};yt.shru=yt.shiftRightUnsigned;yt.shr_u=yt.shiftRightUnsigned;yt.toSigned=function(){return this.unsigned?je(this.low,this.high,!1):this};yt.toUnsigned=function(){return this.unsigned?this:je(this.low,this.high,!0)};yt.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};yt.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};yt.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Ke.fromBytes=function(t,e,n){return n?Ke.fromBytesLE(t,e):Ke.fromBytesBE(t,e)};Ke.fromBytesLE=function(t,e){return new Ke(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};Ke.fromBytesBE=function(t,e){return new Ke(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var C_=gr(()=>{});var v_=gr(()=>{});var IE=gr((vE,fS)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=String(l);for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(vE,typeof fS=="object"&&fS,typeof define=="function"&&define)});var TE=gr((SE,dS)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(SE,typeof dS=="object"&&dS,typeof define=="function"&&define)});var kE=gr((NE,hS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(NE,typeof hS=="object"&&hS,typeof define=="function"&&define)});var EE=gr((_E,gS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(_E,typeof gS=="object"&&gS,typeof define=="function"&&define)});var $E=gr((AE,xS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],x=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,x=Math.max(x,c.length)),f=0,d=-32;d<x;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(AE,typeof xS=="object"&&xS,typeof define=="function"&&define)});var RE=gr((DE,yS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(DE,typeof yS=="object"&&yS,typeof define=="function"&&define)});var FE=gr(()=>{});var PE=gr((OE,cy)=>{(function(r,t,e){var n=256,o=6,s=52,i="random",a=e.pow(n,o),u=e.pow(2,s),l=u*2,c=n-1,p;function m(w,C,T){var E=[];C=C==!0?{entropy:!0}:C||{};var $=g(h(C.entropy?[w,b(t)]:w==null?x():w,3),E),D=new f(E),P=function(){for(var M=D.g(o),W=a,H=0;M<u;)M=(M+H)*n,W*=n,H=D.g(1);for(;M>=l;)M/=2,W/=2,H>>>=1;return(M+H)/W};return P.int32=function(){return D.g(4)|0},P.quick=function(){return D.g(4)/4294967296},P.double=P,g(b(D.S),t),(C.pass||T||function(M,W,H,q){return q&&(q.S&&d(q,D),M.state=function(){return d(D,{})}),H?(e[i]=M,W):M})(P,$,"global"in C?C.global:this==e,C.state)}function f(w){var C,T=w.length,E=this,$=0,D=E.i=E.j=0,P=E.S=[];for(T||(w=[T++]);$<n;)P[$]=$++;for($=0;$<n;$++)P[$]=P[D=c&D+w[$%T]+(C=P[$])],P[D]=C;(E.g=function(M){for(var W,H=0,q=E.i,X=E.j,j=E.S;M--;)W=j[q=c&q+1],H=H*n+j[c&(j[q]=j[X=c&X+W])+(j[X]=W)];return E.i=q,E.j=X,H})(n)}function d(w,C){return C.i=w.i,C.j=w.j,C.S=w.S.slice(),C}function h(w,C){var T=[],E=typeof w,$;if(C&&E=="object")for($ in w)try{T.push(h(w[$],C-1))}catch(D){}return T.length?T:E=="string"?w:w+"\0"}function g(w,C){for(var T=w+"",E,$=0;$<T.length;)C[c&$]=c&(E^=C[c&$]*19)+T.charCodeAt($++);return b(C)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(w)),b(w)}catch(E){var C=r.navigator,T=C&&C.plugins;return[+new Date,r,T,r.screen,b(t)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(e.random(),t),typeof cy=="object"&&cy.exports){cy.exports=m;try{p=FE()}catch(w){}}else typeof define=="function"&&define.amd?define(function(){return m}):e["seed"+i]=m})(typeof self!="undefined"?self:OE,[],Math)});var vh=gr((lTt,LE)=>{var Tj=IE(),Nj=TE(),kj=kE(),_j=EE(),Ej=$E(),Aj=RE(),sc=PE();sc.alea=Tj;sc.xor128=Nj;sc.xorwow=kj;sc.xorshift7=_j;sc.xor4096=Ej;sc.tychei=Aj;LE.exports=sc});var kT=gr(()=>{});var pw=gr(()=>{});var hg=gr(()=>{});var qW=gr(()=>{});var KW=gr(()=>{});var jW=gr(()=>{});var XW=gr((kv,qk)=>{var Hk=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};function e(){return Ft.buffer!=dr&&zo(Ft.buffer),op}function n(){return Ft.buffer!=dr&&zo(Ft.buffer),sp}function o(){return Ft.buffer!=dr&&zo(Ft.buffer),Vd}function s(){return Ft.buffer!=dr&&zo(Ft.buffer),wg}function i(){return Ft.buffer!=dr&&zo(Ft.buffer),Cg}function a(){return Ft.buffer!=dr&&zo(Ft.buffer),vg}function u(){return Ft.buffer!=dr&&zo(Ft.buffer),Ig}var l=typeof t!="undefined"?t:{},c,p;l.ready=new Promise(function(k,R){c=k,p=R});var m;typeof process!="undefined"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},l),d=[],h="./this.program",g=(k,R)=>{throw R},x=typeof window=="object",b=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C=l.ENVIRONMENT_IS_PTHREAD||!1,T="";function E(k){return l.locateFile?l.locateFile(k,T):T+k}var $,D,P,M;function W(k){if(k instanceof Zd)return;K("exiting due to exception: "+k)}var H,q,X;if(w){b?T=hg().dirname(T)+"/":T=__dirname+"/",X=()=>{q||(H=pw(),q=hg())},$=function(V,Y){return X(),V=q.normalize(V),H.readFileSync(V,Y?void 0:"utf8")},P=R=>{var V=$(R,!0);return V.buffer||(V=new Uint8Array(V)),V},D=(R,V,Y)=>{X(),R=q.normalize(R),H.readFile(R,function(ht,wt){ht?Y(ht):V(wt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(R){if(!(R instanceof Zd))throw R}),process.on("unhandledRejection",function(R){throw R}),g=(R,V)=>{if(Pu())throw process.exitCode=R,V;W(V),process.exit(R)},l.inspect=function(){return"[Emscripten Module object]"};let k;try{k=qW()}catch(R){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),R}global.Worker=k.Worker}else(x||b)&&(b?T=self.location.href:typeof document!="undefined"&&document.currentScript&&(T=document.currentScript.src),typeof r!="undefined"&&r&&(T=r),T.indexOf("blob:")!==0?T=T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):T="",w||($=k=>{var R=new XMLHttpRequest;return R.open("GET",k,!1),R.send(null),R.responseText},b&&(P=k=>{var R=new XMLHttpRequest;return R.open("GET",k,!1),R.responseType="arraybuffer",R.send(null),new Uint8Array(R.response)}),D=(k,R,V)=>{var Y=new XMLHttpRequest;Y.open("GET",k,!0),Y.responseType="arraybuffer",Y.onload=()=>{if(Y.status==200||Y.status==0&&Y.response){R(Y.response);return}V()},Y.onerror=V,Y.send(null)}),M=k=>document.title=k);w&&typeof performance=="undefined"&&(global.performance=KW().performance);var j=console.log.bind(console),Z=console.warn.bind(console);w&&(X(),j=k=>H.writeSync(1,k+`
`),Z=k=>H.writeSync(2,k+`
`));var et=l.print||j,K=l.printErr||Z;Object.assign(l,f),f=null,l.arguments&&(d=l.arguments),l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit);var ot=4;function st(k){st.shown||(st.shown={}),st.shown[k]||(st.shown[k]=1,K(k))}function it(k,R){if(typeof WebAssembly.Function=="function"){for(var V={i:"i32",j:"i64",f:"f32",d:"f64"},Y={parameters:[],results:R[0]=="v"?[]:[V[R[0]]]},ht=1;ht<R.length;++ht)Y.parameters.push(V[R[ht]]);return new WebAssembly.Function(Y,k)}var wt=[1,0,1,96],kt=R.slice(0,1),Vt=R.slice(1),nr={i:127,j:126,f:125,d:124};wt.push(Vt.length);for(var ht=0;ht<Vt.length;++ht)wt.push(nr[Vt[ht]]);kt=="v"?wt.push(0):wt=wt.concat([1,nr[kt]]),wt[1]=wt.length-2;var Wo=new Uint8Array([0,97,115,109,1,0,0,0].concat(wt,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Uo=new WebAssembly.Module(Wo),Zg=new WebAssembly.Instance(Uo,{e:{f:k}}),Jd=Zg.exports.f;return Jd}var pt=[],at;function gt(){if(pt.length)return pt.pop();try{Hn.grow(1)}catch(k){throw k instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":k}return Hn.length-1}function dt(k,R){for(var V=k;V<k+R;V++){var Y=cp(V);Y&&at.set(Y,V)}}var bt=0,Tt=k=>{bt=k},At=Atomics.load,Rt=Atomics.store,qt=Atomics.compareExchange,Kt;l.wasmBinary&&(Kt=l.wasmBinary);var me=l.noExitRuntime||!0;typeof WebAssembly!="object"&&ap("no native wasm support detected");var Ft,Ae,Ie=!1,le;function qe(k,R){k||ap(R)}function Re(k){var R=l["_"+k];return R}function Jr(k,R,V,Y,ht){var wt={string:function(Dn){var xp=0;if(Dn!=null&&Dn!==0){var b1=(Dn.length<<2)+1;xp=gp(b1),$n(Dn,xp,b1)}return xp},array:function(Dn){var xp=gp(Dn.length);return Cl(Dn,xp),xp}};function kt(Dn){return R==="string"?qr(Dn):R==="boolean"?Boolean(Dn):Dn}var Vt=Re(k),nr=[],Wo=0;if(Y)for(var Uo=0;Uo<Y.length;Uo++){var Zg=wt[V[Uo]];Zg?(Wo===0&&(Wo=u0()),nr[Uo]=Zg(Y[Uo])):nr[Uo]=Y[Uo]}var Jd=Vt.apply(null,nr);function YU(Dn){return Wo!==0&&Kg(Wo),kt(Dn)}return Jd=YU(Jd),Jd}function Me(k,R,V,Y){V=V||[];var ht=V.every(function(kt){return kt==="number"}),wt=R!=="string";return wt&&ht&&!Y?Re(k):function(){return Jr(k,R,V,arguments,Y)}}var Lo=1;function Or(k){var R=new TextDecoder(k);this.decode=V=>(V.buffer instanceof SharedArrayBuffer&&(V=new Uint8Array(V)),R.decode.call(R,V))}var Qr=typeof TextDecoder!="undefined"?new Or("utf8"):void 0;function tn(k,R,V){for(var Y=R+V,ht=R;k[ht]&&!(ht>=Y);)++ht;if(ht-R>16&&k.subarray&&Qr)return Qr.decode(k.subarray(R,ht));for(var wt="";R<ht;){var kt=k[R++];if(!(kt&128)){wt+=String.fromCharCode(kt);continue}var Vt=k[R++]&63;if((kt&224)==192){wt+=String.fromCharCode((kt&31)<<6|Vt);continue}var nr=k[R++]&63;if((kt&240)==224?kt=(kt&15)<<12|Vt<<6|nr:kt=(kt&7)<<18|Vt<<12|nr<<6|k[R++]&63,kt<65536)wt+=String.fromCharCode(kt);else{var Wo=kt-65536;wt+=String.fromCharCode(55296|Wo>>10,56320|Wo&1023)}}return wt}function qr(k,R){return k?tn(n(),k,R):""}function so(k,R,V,Y){if(!(Y>0))return 0;for(var ht=V,wt=V+Y-1,kt=0;kt<k.length;++kt){var Vt=k.charCodeAt(kt);if(Vt>=55296&&Vt<=57343){var nr=k.charCodeAt(++kt);Vt=65536+((Vt&1023)<<10)|nr&1023}if(Vt<=127){if(V>=wt)break;R[V++]=Vt}else if(Vt<=2047){if(V+1>=wt)break;R[V++]=192|Vt>>6,R[V++]=128|Vt&63}else if(Vt<=65535){if(V+2>=wt)break;R[V++]=224|Vt>>12,R[V++]=128|Vt>>6&63,R[V++]=128|Vt&63}else{if(V+3>=wt)break;R[V++]=240|Vt>>18,R[V++]=128|Vt>>12&63,R[V++]=128|Vt>>6&63,R[V++]=128|Vt&63}}return R[V]=0,V-ht}function $n(k,R,V){return so(k,n(),R,V)}function Mo(k){for(var R=0,V=0;V<k.length;++V){var Y=k.charCodeAt(V);Y>=55296&&Y<=57343&&(Y=65536+((Y&1023)<<10)|k.charCodeAt(++V)&1023),Y<=127?++R:Y<=2047?R+=2:Y<=65535?R+=3:R+=4}return R}var io=typeof TextDecoder!="undefined"?new Or("utf-16le"):void 0;function Cl(k,R){e().set(k,R)}function Fu(k,R,V){for(var Y=0;Y<k.length;++Y)e()[R++>>0]=k.charCodeAt(Y);V||(e()[R>>0]=0)}function np(k,R){return k%R>0&&(k+=R-k%R),k}var dr,op,sp,Vd,wg,Cg,Qk,vg,Ig;C&&(dr=l.buffer);function zo(k){dr=k,l.HEAP8=op=new Int8Array(k),l.HEAP16=Vd=new Int16Array(k),l.HEAP32=Cg=new Int32Array(k),l.HEAPU8=sp=new Uint8Array(k),l.HEAPU16=wg=new Uint16Array(k),l.HEAPU32=Qk=new Uint32Array(k),l.HEAPF32=vg=new Float32Array(k),l.HEAPF64=Ig=new Float64Array(k)}var Sg=l.INITIAL_MEMORY||16777216;if(C)Ft=l.wasmMemory,dr=l.buffer;else if(l.wasmMemory)Ft=l.wasmMemory;else if(Ft=new WebAssembly.Memory({initial:Sg/65536,maximum:32768,shared:!0}),!(Ft.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Ft&&(dr=Ft.buffer),Sg=dr.byteLength,zo(dr);var Hn,ip=[],vl=[],Av=[],Tg=[],Ou=!1,$v=!1,Ng=0;function Pu(){return me||Ng>0}function en(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)t1(l.preRun.shift());Ag(ip)}function Gd(){Ou=!0,!C&&Ag(vl)}function Dv(){C||(Ut.terminateAllThreads(),$v=!0)}function Rv(){if(!C){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)Wd(l.postRun.shift());Ag(Tg)}}function t1(k){ip.unshift(k)}function e1(k){vl.unshift(k)}function Wd(k){Tg.unshift(k)}var Il=0,kg=null,Bo=null;function Ud(k){Il++,l.monitorRunDependencies&&l.monitorRunDependencies(Il)}function r1(k){if(Il--,l.monitorRunDependencies&&l.monitorRunDependencies(Il),Il==0&&(kg!==null&&(clearInterval(kg),kg=null),Bo)){var R=Bo;Bo=null,R()}}l.preloadedImages={},l.preloadedAudios={};function ap(k){C?postMessage({cmd:"onAbort",arg:k}):l.onAbort&&l.onAbort(k),k="Aborted("+k+")",K(k),Ie=!0,le=1,k+=". Build with -s ASSERTIONS=1 for more info.";var R=new WebAssembly.RuntimeError(k);throw p(R),R}var Fv="data:application/octet-stream;base64,";function Hd(k){return k.startsWith(Fv)}function _g(k){return k.startsWith("file://")}var rn;rn="tfjs-backend-wasm-threaded-simd.wasm",Hd(rn)||(rn=E(rn));function Eg(k){try{if(k==rn&&Kt)return new Uint8Array(Kt);if(P)return P(k);throw"both async and sync fetching of the wasm failed"}catch(R){ap(R)}}function lp(){if(!Kt&&(x||b)){if(typeof fetch=="function"&&!_g(rn))return fetch(rn,{credentials:"same-origin"}).then(function(k){if(!k.ok)throw"failed to load wasm binary file at '"+rn+"'";return k.arrayBuffer()}).catch(function(){return Eg(rn)});if(D)return new Promise(function(k,R){D(rn,function(V){k(new Uint8Array(V))},R)})}return Promise.resolve().then(function(){return Eg(rn)})}function Ov(){var k={env:Gg,wasi_snapshot_preview1:Gg};function R(kt,Vt){var nr=kt.exports;if(l.asm=nr,Gv(l.asm.emscripten_tls_init),Hn=l.asm.__indirect_function_table,e1(l.asm.__wasm_call_ctors),Ae=Vt,!C){var Wo=Ut.unusedWorkers.length;Ut.unusedWorkers.forEach(function(Uo){Ut.loadWasmModuleToWorker(Uo,function(){--Wo||r1("wasm-instantiate")})})}}C||Ud("wasm-instantiate");function V(kt){R(kt.instance,kt.module)}function Y(kt){return lp().then(function(Vt){return WebAssembly.instantiate(Vt,k)}).then(function(Vt){return Vt}).then(kt,function(Vt){K("failed to asynchronously prepare wasm: "+Vt),ap(Vt)})}function ht(){return!Kt&&typeof WebAssembly.instantiateStreaming=="function"&&!Hd(rn)&&!_g(rn)&&typeof fetch=="function"?fetch(rn,{credentials:"same-origin"}).then(function(kt){var Vt=WebAssembly.instantiateStreaming(kt,k);return Vt.then(V,function(nr){return K("wasm streaming compile failed: "+nr),K("falling back to ArrayBuffer instantiation"),Y(V)})}):Y(V)}if(l.instantiateWasm)try{var wt=l.instantiateWasm(k,R);return wt}catch(kt){return K("Module.instantiateWasm callback failed with error: "+kt),!1}return ht().catch(p),{}}var n1,o1,Pv={};function Ag(k){for(;k.length>0;){var R=k.shift();if(typeof R=="function"){R(l);continue}var V=R.func;typeof V=="number"?R.arg===void 0?cp(V)():cp(V)(R.arg):V(R.arg===void 0?null:R.arg)}}function up(k){var R=u0(),V=k();return Kg(R),V}function oU(k){return k}function s1(k){var R=/\b_Z[\w\d_]+/g;return k.replace(R,function(V){var Y=V;return V===Y?V:Y+" ["+V+"]"})}function Lv(k){i()[k>>2]=0;var R=Ut.pthreads[k];delete Ut.pthreads[k],R.worker.terminate(),l0(k),Ut.runningWorkers.splice(Ut.runningWorkers.indexOf(R.worker),1),R.worker.pthread=void 0}function Mv(k){var R=Ut.pthreads[k];R.worker.postMessage({cmd:"cancel"})}function $g(k){var R=Ut.pthreads[k];if(R){i()[k>>2]=0;var V=R.worker;Ut.returnWorkerToPool(V)}}function Dg(k){KU(k)}function zv(k){if(k instanceof Zd||k=="unwind")return le;g(1,k)}var Ut={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){C?Ut.initWorker():Ut.initMainThread()},initMainThread:function(){for(var k=8,R=0;R<k;++R)Ut.allocateUnusedWorker()},initWorker:function(){me=!1},pthreads:{},setExitStatus:function(k){le=k},terminateAllThreads:function(){for(var k in Ut.pthreads){var R=Ut.pthreads[k];R&&R.worker&&Ut.returnWorkerToPool(R.worker)}for(var V=0;V<Ut.unusedWorkers.length;++V){var Y=Ut.unusedWorkers[V];Y.terminate()}Ut.unusedWorkers=[]},returnWorkerToPool:function(k){Ut.runWithoutMainThreadQueuedCalls(function(){delete Ut.pthreads[k.pthread.threadInfoStruct],Ut.unusedWorkers.push(k),Ut.runningWorkers.splice(Ut.runningWorkers.indexOf(k),1),l0(k.pthread.threadInfoStruct),k.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(k){i()[y1>>2]=0;try{k()}finally{i()[y1>>2]=1}},receiveObjectTransfer:function(k){},threadInit:function(){for(var k in Ut.tlsInitFunctions)Ut.tlsInitFunctions[k]()},loadWasmModuleToWorker:function(k,R){k.onmessage=V=>{var Y=V.data,ht=Y.cmd;if(k.pthread&&(Ut.currentProxiedOperationCallerThread=k.pthread.threadInfoStruct),Y.targetThread&&Y.targetThread!=qg()){var wt=Ut.pthreads[Y.targetThread];wt?wt.worker.postMessage(Y,Y.transferList):K('Internal error! Worker sent a message "'+ht+'" to target pthread '+Y.targetThread+", but that thread no longer exists!"),Ut.currentProxiedOperationCallerThread=void 0;return}ht==="processQueuedMainThreadWork"?f1():ht==="spawnThread"?Fg(Y):ht==="cleanupThread"?$g(Y.thread):ht==="killThread"?Lv(Y.thread):ht==="cancelThread"?Mv(Y.thread):ht==="loaded"?(k.loaded=!0,R&&R(k),k.runPthread&&(k.runPthread(),delete k.runPthread)):ht==="print"?et("Thread "+Y.threadId+": "+Y.text):ht==="printErr"?K("Thread "+Y.threadId+": "+Y.text):ht==="alert"?alert("Thread "+Y.threadId+": "+Y.text):Y.target==="setimmediate"?k.postMessage(Y):ht==="onAbort"?l.onAbort&&l.onAbort(Y.arg):K("worker sent an unknown command "+ht),Ut.currentProxiedOperationCallerThread=void 0},k.onerror=V=>{var Y="worker sent an error!";throw K(Y+" "+V.filename+":"+V.lineno+": "+V.message),V},w&&(k.on("message",function(V){k.onmessage({data:V})}),k.on("error",function(V){k.onerror(V)}),k.on("detachedExit",function(){})),k.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:Ft,wasmModule:Ae})},allocateUnusedWorker:function(){var k=E("tfjs-backend-wasm-threaded-simd.worker.js");Ut.unusedWorkers.push(new Worker(k))},getNewWorker:function(){return Ut.unusedWorkers.length==0&&(Ut.allocateUnusedWorker(),Ut.loadWasmModuleToWorker(Ut.unusedWorkers[0])),Ut.unusedWorkers.pop()}};function Bv(){var k=qg(),R=i()[k+44>>2],V=i()[k+48>>2],Y=R-V;x1(R,Y),Kg(R)}l.establishStackSpace=Bv;function Rg(k){if(C)return zu(1,0,k);try{Dg(k)}catch(R){zv(R)}}var Lu=[];function cp(k){var R=Lu[k];return R||(k>=Lu.length&&(Lu.length=k+1),Lu[k]=R=Hn.get(k)),R}function Vv(k,R){return cp(k)(R)}l.invokeEntryPoint=Vv;function i1(){var k=new Error;if(!k.stack){try{throw new Error}catch(R){k=R}if(!k.stack)return"(no stack trace available)"}return k.stack.toString()}function Gv(k,R,V){Ut.tlsInitFunctions.push(k)}function a1(k,R){Hn.set(k,R),Lu[k]=R}var Mu;w?Mu=()=>{var k=process.hrtime();return k[0]*1e3+k[1]/1e6}:C?Mu=()=>performance.now()-l.__performance_now_clock_drift:Mu=()=>performance.now();var Wv=!0;function Uv(k){return i()[m1()>>2]=k,k}function Hv(k,R){var V;if(k===0)V=Date.now();else if((k===1||k===4)&&Wv)V=Mu();else return Uv(28),-1;return i()[R>>2]=V/1e3|0,i()[R+4>>2]=V%1e3*1e3*1e3|0,0}function qv(k,R){return Hv(k,R)}function Kv(k){d1(k,!b,1,!x),Ut.threadInit()}function jv(k){C?postMessage({cmd:"cleanupThread",thread:k}):$g(k)}function Fg(k){var R=Ut.getNewWorker();if(!R)return 6;Ut.runningWorkers.push(R);var V=Ut.pthreads[k.pthread_ptr]={worker:R,threadInfoStruct:k.pthread_ptr};R.pthread=V;var Y={cmd:"run",start_routine:k.startRoutine,arg:k.arg,threadInfoStruct:k.pthread_ptr};return R.runPthread=()=>{Y.time=performance.now(),R.postMessage(Y,k.transferList)},R.loaded&&(R.runPthread(),delete R.runPthread),0}function Xv(k,R,V,Y){if(typeof SharedArrayBuffer=="undefined")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ht=[],wt=0;if(C&&(ht.length===0||wt))return h1(687865856,k,R,V,Y);if(wt)return wt;var kt={startRoutine:V,pthread_ptr:k,arg:Y,transferList:ht};return C?(kt.cmd="spawnThread",postMessage(kt,ht),0):Fg(kt)}function Yv(){return 2097152}function Zv(k,R){if(k==R)postMessage({cmd:"processQueuedMainThreadWork"});else if(C)postMessage({targetThread:k,cmd:"processThreadQueue"});else{var V=Ut.pthreads[k],Y=V&&V.worker;if(!Y)return;Y.postMessage({cmd:"processThreadQueue"})}return 1}function Jv(){ap("")}function Qv(){w||b||st("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Og(){return 2147483648}function tI(k,R,V){n().copyWithin(k,R,R+V)}function eI(){return w?jW().cpus().length:navigator.hardwareConcurrency}function zu(k,R){var V=arguments.length-2,Y=arguments;return up(function(){for(var ht=V,wt=gp(ht*8),kt=wt>>3,Vt=0;Vt<V;Vt++){var nr=Y[2+Vt];u()[kt+Vt]=nr}return g1(k,ht,wt,R)})}var qd=[];function rI(k,R,V){qd.length=R;for(var Y=V>>3,ht=0;ht<R;ht++)qd[ht]=u()[Y+ht];var wt=k<0,kt=wt?Pv[-k-1]:CI[k];return kt.apply(null,qd)}function nI(k){try{return Ft.grow(k-dr.byteLength+65535>>>16),zo(Ft.buffer),1}catch(R){}}function oI(k){var R=n().length;if(k=k>>>0,k<=R)return!1;var V=Og();if(k>V)return!1;for(var Y=1;Y<=4;Y*=2){var ht=R*(1+.2/Y);ht=Math.min(ht,k+100663296);var wt=Math.min(V,np(Math.max(k,ht),65536)),kt=nI(wt);if(kt)return!0}return!1}var ne={inEventHandler:0,removeAllEventListeners:function(){for(var k=ne.eventHandlers.length-1;k>=0;--k)ne._removeHandler(k);ne.eventHandlers=[],ne.deferredCalls=[]},registerRemoveEventListeners:function(){ne.removeEventListenersRegistered||(Av.push(ne.removeAllEventListeners),ne.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(k,R,V){function Y(kt,Vt){if(kt.length!=Vt.length)return!1;for(var nr in kt)if(kt[nr]!=Vt[nr])return!1;return!0}for(var ht in ne.deferredCalls){var wt=ne.deferredCalls[ht];if(wt.targetFunction==k&&Y(wt.argsList,V))return}ne.deferredCalls.push({targetFunction:k,precedence:R,argsList:V}),ne.deferredCalls.sort(function(kt,Vt){return kt.precedence<Vt.precedence})},removeDeferredCalls:function(k){for(var R=0;R<ne.deferredCalls.length;++R)ne.deferredCalls[R].targetFunction==k&&(ne.deferredCalls.splice(R,1),--R)},canPerformEventHandlerRequests:function(){return ne.inEventHandler&&ne.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!ne.canPerformEventHandlerRequests())for(var k=0;k<ne.deferredCalls.length;++k){var R=ne.deferredCalls[k];ne.deferredCalls.splice(k,1),--k,R.targetFunction.apply(null,R.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(k,R){for(var V=0;V<ne.eventHandlers.length;++V)ne.eventHandlers[V].target==k&&(!R||R==ne.eventHandlers[V].eventTypeString)&&ne._removeHandler(V--)},_removeHandler:function(k){var R=ne.eventHandlers[k];R.target.removeEventListener(R.eventTypeString,R.eventListenerFunc,R.useCapture),ne.eventHandlers.splice(k,1)},registerOrRemoveHandler:function(k){var R=function(ht){++ne.inEventHandler,ne.currentEventHandler=k,ne.runDeferredCalls(),k.handlerFunc(ht),ne.runDeferredCalls(),--ne.inEventHandler};if(k.callbackfunc)k.eventListenerFunc=R,k.target.addEventListener(k.eventTypeString,R,k.useCapture),ne.eventHandlers.push(k),ne.registerRemoveEventListeners();else for(var V=0;V<ne.eventHandlers.length;++V)ne.eventHandlers[V].target==k.target&&ne.eventHandlers[V].eventTypeString==k.eventTypeString&&ne._removeHandler(V--)},queueEventHandlerOnThread_iiii:function(k,R,V,Y,ht){up(function(){var wt=gp(12);i()[wt>>2]=V,i()[wt+4>>2]=Y,i()[wt+8>>2]=ht,a0(k,637534208,R,Y,wt)})},getTargetThreadForEventCallback:function(k){switch(k){case 1:return 0;case 2:return Ut.currentProxiedOperationCallerThread;default:return k}},getNodeNameForTarget:function(k){return k?k==window?"#window":k==screen?"#screen":k&&k.nodeName?k.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function sI(k){var R=Mo(k)+1,V=i0(R);return $n(k,V,R),V}function iI(k,R,V,Y){up(function(){var ht=gp(12),wt=0;R&&(wt=sI(R)),i()[ht>>2]=wt,i()[ht+4>>2]=V,i()[ht+8>>2]=Y,a0(k,657457152,0,wt,ht)})}function aI(k,R,V,Y){R=R?qr(R):"",iI(k,R,V,Y)}function lI(k){return k>2?qr(k):k}var uI=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function cI(k){k=lI(k);var R=uI[k]||(typeof document!="undefined"?document.querySelector(k):void 0);return R}function Kd(k){return cI(k)}function Pg(k,R,V){var Y=Kd(k);if(!Y)return-4;if(Y.canvasSharedPtr&&(i()[Y.canvasSharedPtr>>2]=R,i()[Y.canvasSharedPtr+4>>2]=V),Y.offscreenCanvas||!Y.controlTransferredOffscreen){Y.offscreenCanvas&&(Y=Y.offscreenCanvas);var ht=!1;if(Y.GLctxObject&&Y.GLctxObject.GLctx){var wt=Y.GLctxObject.GLctx.getParameter(2978);ht=wt[0]===0&&wt[1]===0&&wt[2]===Y.width&&wt[3]===Y.height}Y.width=R,Y.height=V,ht&&Y.GLctxObject.GLctx.viewport(0,0,R,V)}else if(Y.canvasSharedPtr){var kt=i()[Y.canvasSharedPtr+8>>2];return aI(kt,k,R,V),1}else return-4;return 0}function Lg(k,R,V){return C?zu(2,1,k,R,V):Pg(k,R,V)}function pI(k,R,V){var Y=Kd(k);return Y?Pg(k,R,V):Lg(k,R,V)}function mI(){throw"unwind"}function fI(k){var R=k.getExtension("ANGLE_instanced_arrays");if(R)return k.vertexAttribDivisor=function(V,Y){R.vertexAttribDivisorANGLE(V,Y)},k.drawArraysInstanced=function(V,Y,ht,wt){R.drawArraysInstancedANGLE(V,Y,ht,wt)},k.drawElementsInstanced=function(V,Y,ht,wt,kt){R.drawElementsInstancedANGLE(V,Y,ht,wt,kt)},1}function dI(k){var R=k.getExtension("OES_vertex_array_object");if(R)return k.createVertexArray=function(){return R.createVertexArrayOES()},k.deleteVertexArray=function(V){R.deleteVertexArrayOES(V)},k.bindVertexArray=function(V){R.bindVertexArrayOES(V)},k.isVertexArray=function(V){return R.isVertexArrayOES(V)},1}function hI(k){var R=k.getExtension("WEBGL_draw_buffers");if(R)return k.drawBuffers=function(V,Y){R.drawBuffersWEBGL(V,Y)},1}function gI(k){return!!(k.multiDrawWebgl=k.getExtension("WEBGL_multi_draw"))}var rr={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(R){rr.lastError||(rr.lastError=R)},getNewId:function(k){for(var R=rr.counter++,V=k.length;V<R;V++)k[V]=null;return R},getSource:function(k,R,V,Y){for(var ht="",wt=0;wt<R;++wt){var kt=Y?i()[Y+wt*4>>2]:-1;ht+=qr(i()[V+wt*4>>2],kt<0?void 0:kt)}return ht},createContext:function(k,R){k.getContextSafariWebGL2Fixed||(k.getContextSafariWebGL2Fixed=k.getContext,k.getContext=function(ht,wt){var kt=k.getContextSafariWebGL2Fixed(ht,wt);return ht=="webgl"==kt instanceof WebGLRenderingContext?kt:null});var V=k.getContext("webgl",R);if(!V)return 0;var Y=rr.registerContext(V,R);return Y},registerContext:function(k,R){var V=i0(8);i()[V+4>>2]=qg();var Y={handle:V,attributes:R,version:R.majorVersion,GLctx:k};return k.canvas&&(k.canvas.GLctxObject=Y),rr.contexts[V]=Y,(typeof R.enableExtensionsByDefault=="undefined"||R.enableExtensionsByDefault)&&rr.initExtensions(Y),V},makeContextCurrent:function(k){return rr.currentContext=rr.contexts[k],l.ctx=Vg=rr.currentContext&&rr.currentContext.GLctx,!(k&&!Vg)},getContext:function(k){return rr.contexts[k]},deleteContext:function(k){rr.currentContext===rr.contexts[k]&&(rr.currentContext=null),typeof ne=="object"&&ne.removeAllHandlersOnTarget(rr.contexts[k].GLctx.canvas),rr.contexts[k]&&rr.contexts[k].GLctx.canvas&&(rr.contexts[k].GLctx.canvas.GLctxObject=void 0),p1(rr.contexts[k].handle),rr.contexts[k]=null},initExtensions:function(k){if(k||(k=rr.currentContext),!k.initExtensionsDone){k.initExtensionsDone=!0;var R=k.GLctx;fI(R),dI(R),hI(R),R.disjointTimerQueryExt=R.getExtension("EXT_disjoint_timer_query"),gI(R);var V=R.getSupportedExtensions()||[];V.forEach(function(Y){!Y.includes("lose_context")&&!Y.includes("debug")&&R.getExtension(Y)})}}},xI=["default","low-power","high-performance"];function yI(k,R){var V=R>>2,Y=i()[V+6],ht={alpha:!!i()[V+0],depth:!!i()[V+1],stencil:!!i()[V+2],antialias:!!i()[V+3],premultipliedAlpha:!!i()[V+4],preserveDrawingBuffer:!!i()[V+5],powerPreference:xI[Y],failIfMajorPerformanceCaveat:!!i()[V+7],majorVersion:i()[V+8],minorVersion:i()[V+9],enableExtensionsByDefault:i()[V+10],explicitSwapControl:i()[V+11],proxyContextToMainThread:i()[V+12],renderViaOffscreenBackBuffer:i()[V+13]},wt=Kd(k);if(!wt||ht.explicitSwapControl)return 0;var kt=rr.createContext(wt,ht);return kt}function bI(k,R){return yI(k,R)}var pp={mappings:{},buffers:[null,[],[]],printChar:function(k,R){var V=pp.buffers[k];R===0||R===10?((k===1?et:K)(tn(V,0)),V.length=0):V.push(R)},varargs:void 0,get:function(){pp.varargs+=4;var k=i()[pp.varargs-4>>2];return k},getStr:function(k){var R=qr(k);return R},get64:function(k,R){return k}};function Mg(k){return C?zu(3,1,k):0}function zg(k,R,V,Y,ht){if(C)return zu(4,1,k,R,V,Y,ht)}function Bg(k,R,V,Y){if(C)return zu(5,1,k,R,V,Y);for(var ht=0,wt=0;wt<V;wt++){var kt=i()[R>>2],Vt=i()[R+4>>2];R+=8;for(var nr=0;nr<Vt;nr++)pp.printChar(k,n()[kt+nr]);ht+=Vt}return i()[Y>>2]=ht,0}function wI(k){Tt(k)}Ut.init();var Vg,CI=[null,Rg,Lg,Mg,zg,Bg],l1=!1,Gg={__clock_gettime:qv,__emscripten_init_main_thread_js:Kv,__emscripten_thread_cleanup:jv,__pthread_create_js:Xv,_emscripten_default_pthread_stack_size:Yv,_emscripten_notify_thread_queue:Zv,abort:Jv,emscripten_check_blocking_allowed:Qv,emscripten_get_heap_max:Og,emscripten_get_now:Mu,emscripten_memcpy_big:tI,emscripten_num_logical_cores:eI,emscripten_receive_on_main_thread_js:rI,emscripten_resize_heap:oI,emscripten_set_canvas_element_size:pI,emscripten_unwind_to_js_event_loop:mI,emscripten_webgl_create_context:bI,exit:Dg,fd_close:Mg,fd_seek:zg,fd_write:Bg,memory:Ft||l.wasmMemory,setTempRet0:wI},u1=Ov(),vI=l.___wasm_call_ctors=function(){return(vI=l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},II=l._init=function(){return(II=l._init=l.asm.init).apply(null,arguments)},SI=l._init_with_threads_count=function(){return(SI=l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},TI=l._get_threads_count=function(){return(TI=l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},NI=l._register_tensor=function(){return(NI=l._register_tensor=l.asm.register_tensor).apply(null,arguments)},kI=l._dispose_data=function(){return(kI=l._dispose_data=l.asm.dispose_data).apply(null,arguments)},_I=l._dispose=function(){return(_I=l._dispose=l.asm.dispose).apply(null,arguments)},EI=l._Abs=function(){return(EI=l._Abs=l.asm.Abs).apply(null,arguments)},AI=l._Add=function(){return(AI=l._Add=l.asm.Add).apply(null,arguments)},$I=l._AddN=function(){return($I=l._AddN=l.asm.AddN).apply(null,arguments)},DI=l._All=function(){return(DI=l._All=l.asm.All).apply(null,arguments)},RI=l._Any=function(){return(RI=l._Any=l.asm.Any).apply(null,arguments)},FI=l._ArgMax=function(){return(FI=l._ArgMax=l.asm.ArgMax).apply(null,arguments)},OI=l._AvgPool=function(){return(OI=l._AvgPool=l.asm.AvgPool).apply(null,arguments)},PI=l._BatchMatMul=function(){return(PI=l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},LI=l._Ceil=function(){return(LI=l._Ceil=l.asm.Ceil).apply(null,arguments)},MI=l._ClipByValue=function(){return(MI=l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},zI=l._Conv2D=function(){return(zI=l._Conv2D=l.asm.Conv2D).apply(null,arguments)},BI=l._Conv2DBackpropInput=function(){return(BI=l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},VI=l._Cos=function(){return(VI=l._Cos=l.asm.Cos).apply(null,arguments)},GI=l._Cosh=function(){return(GI=l._Cosh=l.asm.Cosh).apply(null,arguments)},WI=l._CropAndResize=function(){return(WI=l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},UI=l._Cumprod=function(){return(UI=l._Cumprod=l.asm.Cumprod).apply(null,arguments)},HI=l._Cumsum=function(){return(HI=l._Cumsum=l.asm.Cumsum).apply(null,arguments)},qI=l._DepthToSpace=function(){return(qI=l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},KI=l._DepthwiseConv2dNative=function(){return(KI=l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},jI=l._Elu=function(){return(jI=l._Elu=l.asm.Elu).apply(null,arguments)},XI=l._Equal=function(){return(XI=l._Equal=l.asm.Equal).apply(null,arguments)},YI=l._Exp=function(){return(YI=l._Exp=l.asm.Exp).apply(null,arguments)},ZI=l._FlipLeftRight=function(){return(ZI=l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},JI=l._Floor=function(){return(JI=l._Floor=l.asm.Floor).apply(null,arguments)},QI=l._FloorDiv=function(){return(QI=l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},t0=l._FusedBatchNorm=function(){return(t0=l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},e0=l._FusedConv2D=function(){return(e0=l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},Wg=l._FusedDepthwiseConv2D=function(){return(Wg=l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},Ug=l._Gather=function(){return(Ug=l._Gather=l.asm.Gather).apply(null,arguments)},jd=l._GatherNd=function(){return(jd=l._GatherNd=l.asm.GatherNd).apply(null,arguments)},r0=l._Greater=function(){return(r0=l._Greater=l.asm.Greater).apply(null,arguments)},n0=l._GreaterEqual=function(){return(n0=l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},mp=l._LeakyRelu=function(){return(mp=l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},Xd=l._Less=function(){return(Xd=l._Less=l.asm.Less).apply(null,arguments)},Yd=l._LessEqual=function(){return(Yd=l._LessEqual=l.asm.LessEqual).apply(null,arguments)},c1=l._Log=function(){return(c1=l._Log=l.asm.Log).apply(null,arguments)},fp=l._LogicalAnd=function(){return(fp=l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},dp=l._LogicalNot=function(){return(dp=l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},o0=l._LogicalOr=function(){return(o0=l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},U=l._LogicalXor=function(){return(U=l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},Q=l._Max=function(){return(Q=l._Max=l.asm.Max).apply(null,arguments)},xt=l._MaxPool=function(){return(xt=l._MaxPool=l.asm.MaxPool).apply(null,arguments)},$t=l._Maximum=function(){return($t=l._Maximum=l.asm.Maximum).apply(null,arguments)},he=l._Mean=function(){return(he=l._Mean=l.asm.Mean).apply(null,arguments)},xe=l._Min=function(){return(xe=l._Min=l.asm.Min).apply(null,arguments)},oe=l._Minimum=function(){return(oe=l._Minimum=l.asm.Minimum).apply(null,arguments)},ee=l._MirrorPad=function(){return(ee=l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},hr=l._Multiply=function(){return(hr=l._Multiply=l.asm.Multiply).apply(null,arguments)},Vo=l._Neg=function(){return(Vo=l._Neg=l.asm.Neg).apply(null,arguments)},Go=l._NonMaxSuppressionV3=function(){return(Go=l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},hp=l._NonMaxSuppressionV4=function(){return(hp=l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},Bu=l._NonMaxSuppressionV5=function(){return(Bu=l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},s0=l._NotEqual=function(){return(s0=l._NotEqual=l.asm.NotEqual).apply(null,arguments)},nn=l._OneHot=function(){return(nn=l._OneHot=l.asm.OneHot).apply(null,arguments)},Sl=l._PadV2=function(){return(Sl=l._PadV2=l.asm.PadV2).apply(null,arguments)},Hg=l._Pow=function(){return(Hg=l._Pow=l.asm.Pow).apply(null,arguments)},sU=l._Prelu=function(){return(sU=l._Prelu=l.asm.Prelu).apply(null,arguments)},iU=l._Prod=function(){return(iU=l._Prod=l.asm.Prod).apply(null,arguments)},aU=l._RealDiv=function(){return(aU=l._RealDiv=l.asm.RealDiv).apply(null,arguments)},lU=l._Relu=function(){return(lU=l._Relu=l.asm.Relu).apply(null,arguments)},uU=l._Relu6=function(){return(uU=l._Relu6=l.asm.Relu6).apply(null,arguments)},cU=l._ResizeBilinear=function(){return(cU=l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},pU=l._ResizeNearestNeighbor=function(){return(pU=l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},mU=l._Reverse=function(){return(mU=l._Reverse=l.asm.Reverse).apply(null,arguments)},fU=l._RotateWithOffset=function(){return(fU=l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},dU=l._Round=function(){return(dU=l._Round=l.asm.Round).apply(null,arguments)},hU=l._Rsqrt=function(){return(hU=l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},gU=l._ScatterNd=function(){return(gU=l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},xU=l._SelectV2=function(){return(xU=l._SelectV2=l.asm.SelectV2).apply(null,arguments)},yU=l._Sigmoid=function(){return(yU=l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},bU=l._Sin=function(){return(bU=l._Sin=l.asm.Sin).apply(null,arguments)},wU=l._Softmax=function(){return(wU=l._Softmax=l.asm.Softmax).apply(null,arguments)},CU=l._SparseFillEmptyRows=function(){return(CU=l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},vU=l._SparseReshape=function(){return(vU=l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},IU=l._SparseSegmentReduction=function(){return(IU=l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},SU=l._Sqrt=function(){return(SU=l._Sqrt=l.asm.Sqrt).apply(null,arguments)},TU=l._Square=function(){return(TU=l._Square=l.asm.Square).apply(null,arguments)},NU=l._SquaredDifference=function(){return(NU=l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},kU=l._Step=function(){return(kU=l._Step=l.asm.Step).apply(null,arguments)},_U=l._StridedSlice=function(){return(_U=l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},EU=l._Sub=function(){return(EU=l._Sub=l.asm.Sub).apply(null,arguments)},AU=l._Sum=function(){return(AU=l._Sum=l.asm.Sum).apply(null,arguments)},$U=l._Tan=function(){return($U=l._Tan=l.asm.Tan).apply(null,arguments)},DU=l._Tanh=function(){return(DU=l._Tanh=l.asm.Tanh).apply(null,arguments)},RU=l._Tile=function(){return(RU=l._Tile=l.asm.Tile).apply(null,arguments)},FU=l._TopK=function(){return(FU=l._TopK=l.asm.TopK).apply(null,arguments)},OU=l._Transform=function(){return(OU=l._Transform=l.asm.Transform).apply(null,arguments)},PU=l._Transpose=function(){return(PU=l._Transpose=l.asm.Transpose).apply(null,arguments)},LU=l.__FusedMatMul=function(){return(LU=l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},i0=l._malloc=function(){return(i0=l._malloc=l.asm.malloc).apply(null,arguments)},p1=l._free=function(){return(p1=l._free=l.asm.free).apply(null,arguments)},MU=l._emscripten_tls_init=function(){return(MU=l._emscripten_tls_init=l.asm.emscripten_tls_init).apply(null,arguments)},m1=l.___errno_location=function(){return(m1=l.___errno_location=l.asm.__errno_location).apply(null,arguments)},qg=l._pthread_self=function(){return(qg=l._pthread_self=l.asm.pthread_self).apply(null,arguments)},f1=l._emscripten_main_thread_process_queued_calls=function(){return(f1=l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},zU=l.__emscripten_thread_crashed=function(){return(zU=l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},d1=l.__emscripten_thread_init=function(){return(d1=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)},BU=l._emscripten_current_thread_process_queued_calls=function(){return(BU=l._emscripten_current_thread_process_queued_calls=l.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},VU=l._emscripten_main_browser_thread_id=function(){return(VU=l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)},GU=l._emscripten_sync_run_in_main_thread_2=function(){return(GU=l._emscripten_sync_run_in_main_thread_2=l.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},h1=l._emscripten_sync_run_in_main_thread_4=function(){return(h1=l._emscripten_sync_run_in_main_thread_4=l.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)},g1=l._emscripten_run_in_main_runtime_thread_js=function(){return(g1=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},a0=l._emscripten_dispatch_to_thread_=function(){return(a0=l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},l0=l.__emscripten_thread_free_data=function(){return(l0=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},WU=l.__emscripten_thread_exit=function(){return(WU=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},UU=l._memalign=function(){return(UU=l._memalign=l.asm.memalign).apply(null,arguments)},x1=l._emscripten_stack_set_limits=function(){return(x1=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},u0=l.stackSave=function(){return(u0=l.stackSave=l.asm.stackSave).apply(null,arguments)},Kg=l.stackRestore=function(){return(Kg=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},gp=l.stackAlloc=function(){return(gp=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)},HU=l.dynCall_iijjiiii=function(){return(HU=l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},qU=l.dynCall_jiji=function(){return(qU=l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},y1=l.__emscripten_allow_main_runtime_queued_calls=21672;l.cwrap=Me,l.keepRuntimeAlive=Pu,l.PThread=Ut,l.PThread=Ut,l.wasmMemory=Ft,l.ExitStatus=Zd;var jg;function Zd(k){this.name="ExitStatus",this.message="Program terminated with exit("+k+")",this.status=k}Bo=function k(){jg||c0(),jg||(Bo=k)};function c0(k){if(k=k||d,Il>0)return;if(C){c(l),Gd(),postMessage({cmd:"loaded"});return}if(en(),Il>0)return;function R(){jg||(jg=!0,l.calledRun=!0,!Ie&&(Gd(),c(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),Rv()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),R()},1)):R()}l.run=c0;function KU(k,R){if(le=k,!R&&C)throw Rg(k),"unwind";Pu()||Dv(),jU(k)}function jU(k){le=k,Pu()||(Ut.terminateAllThreads(),l.onExit&&l.onExit(k),Ie=!0),g(k,new Zd(k))}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();c0();var Xg;m&&(Xg={uncaughtException:process.listeners("uncaughtException").filter(function(k){return!m.uncaughtException.indexOf(k)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(k){return!m.unhandledRejection.indexOf(k)>-1})});var Yg;if(typeof WasmBackendModule!="undefined")Yg=WasmBackendModule;else if(typeof t!="undefined")Yg=t;else throw new Error("Could not find wasm module in post.js");if(Xg){var XU=Yg._dispose;Yg._dispose=function(){XU(),Xg.uncaughtException.forEach(function(k){process.removeListener("uncaughtException",k)}),Xg.unhandledRejection.forEach(function(k){process.removeListener("unhandledRejection",k)})}}return t.ready}})();typeof kv=="object"&&typeof qk=="object"?qk.exports=Hk:typeof define=="function"&&define.amd?define([],function(){return Hk}):typeof kv=="object"&&(kv.WasmBackendModuleThreadedSimd=Hk)});var ZW=gr((B5e,YW)=>{YW.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`});var JW=gr((_v,jk)=>{var Kk=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};var e=typeof t!="undefined"?t:{},n,o;e.ready=new Promise(function(U,Q){n=U,o=Q});var s;typeof process!="undefined"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i=Object.assign({},e),a=[],u="./this.program",l=(U,Q)=>{throw Q},c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function d(U){return e.locateFile?e.locateFile(U,f):f+U}var h,g,x,b;function w(U){if(U instanceof Xd)return;D("exiting due to exception: "+U)}var C,T,E;m?(p?f=hg().dirname(f)+"/":f=__dirname+"/",E=()=>{T||(C=pw(),T=hg())},h=function(Q,xt){return E(),Q=T.normalize(Q),C.readFileSync(Q,xt?void 0:"utf8")},x=U=>{var Q=h(U,!0);return Q.buffer||(Q=new Uint8Array(Q)),Q},g=(U,Q,xt)=>{E(),U=T.normalize(U),C.readFile(U,function($t,he){$t?xt($t):Q(he.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(U){if(!(U instanceof Xd))throw U}),process.on("unhandledRejection",function(U){throw U}),l=(U,Q)=>{if(Vd())throw process.exitCode=U,Q;w(Q),process.exit(U)},e.inspect=function(){return"[Emscripten Module object]"}):(c||p)&&(p?f=self.location.href:typeof document!="undefined"&&document.currentScript&&(f=document.currentScript.src),r&&(f=r),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",h=U=>{var Q=new XMLHttpRequest;return Q.open("GET",U,!1),Q.send(null),Q.responseText},p&&(x=U=>{var Q=new XMLHttpRequest;return Q.open("GET",U,!1),Q.responseType="arraybuffer",Q.send(null),new Uint8Array(Q.response)}),g=(U,Q,xt)=>{var $t=new XMLHttpRequest;$t.open("GET",U,!0),$t.responseType="arraybuffer",$t.onload=()=>{if($t.status==200||$t.status==0&&$t.response){Q($t.response);return}xt()},$t.onerror=xt,$t.send(null)},b=U=>document.title=U);var $=e.print||console.log.bind(console),D=e.printErr||console.warn.bind(console);Object.assign(e,i),i=null,e.arguments&&(a=e.arguments),e.thisProgram&&(u=e.thisProgram),e.quit&&(l=e.quit);var P=4;function M(U){M.shown||(M.shown={}),M.shown[U]||(M.shown[U]=1,D(U))}function W(U,Q){if(typeof WebAssembly.Function=="function"){for(var xt={i:"i32",j:"i64",f:"f32",d:"f64"},$t={parameters:[],results:Q[0]=="v"?[]:[xt[Q[0]]]},he=1;he<Q.length;++he)$t.parameters.push(xt[Q[he]]);return new WebAssembly.Function($t,U)}var xe=[1,0,1,96],oe=Q.slice(0,1),ee=Q.slice(1),hr={i:127,j:126,f:125,d:124};xe.push(ee.length);for(var he=0;he<ee.length;++he)xe.push(hr[ee[he]]);oe=="v"?xe.push(0):xe=xe.concat([1,hr[oe]]),xe[1]=xe.length-2;var Vo=new Uint8Array([0,97,115,109,1,0,0,0].concat(xe,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Go=new WebAssembly.Module(Vo),hp=new WebAssembly.Instance(Go,{e:{f:U}}),Bu=hp.exports.f;return Bu}var H=[],q;function X(){if(H.length)return H.pop();try{io.grow(1)}catch(U){throw U instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":U}return io.length-1}function j(U,Q){for(var xt=U;xt<U+Q;xt++){var $t=Ud(xt);$t&&q.set($t,xt)}}var Z=0,et=U=>{Z=U},K;e.wasmBinary&&(K=e.wasmBinary);var ot=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Ou("no native wasm support detected");var st,it=!1,pt;function at(U,Q){U||Ou(Q)}function gt(U){var Q=e["_"+U];return Q}function dt(U,Q,xt,$t,he){var xe={string:function(nn){var Sl=0;if(nn!=null&&nn!==0){var Hg=(nn.length<<2)+1;Sl=jd(Hg),me(nn,Sl,Hg)}return Sl},array:function(nn){var Sl=jd(nn.length);return Ie(nn,Sl),Sl}};function oe(nn){return Q==="string"?qt(nn):Q==="boolean"?Boolean(nn):nn}var ee=gt(U),hr=[],Vo=0;if($t)for(var Go=0;Go<$t.length;Go++){var hp=xe[xt[Go]];hp?(Vo===0&&(Vo=Wg()),hr[Go]=hp($t[Go])):hr[Go]=$t[Go]}var Bu=ee.apply(null,hr);function s0(nn){return Vo!==0&&Ug(Vo),oe(nn)}return Bu=s0(Bu),Bu}function bt(U,Q,xt,$t){xt=xt||[];var he=xt.every(function(oe){return oe==="number"}),xe=Q!=="string";return xe&&he&&!$t?gt(U):function(){return dt(U,Q,xt,arguments,$t)}}var Tt=1,At=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Rt(U,Q,xt){for(var $t=Q+xt,he=Q;U[he]&&!(he>=$t);)++he;if(he-Q>16&&U.subarray&&At)return At.decode(U.subarray(Q,he));for(var xe="";Q<he;){var oe=U[Q++];if(!(oe&128)){xe+=String.fromCharCode(oe);continue}var ee=U[Q++]&63;if((oe&224)==192){xe+=String.fromCharCode((oe&31)<<6|ee);continue}var hr=U[Q++]&63;if((oe&240)==224?oe=(oe&15)<<12|ee<<6|hr:oe=(oe&7)<<18|ee<<12|hr<<6|U[Q++]&63,oe<65536)xe+=String.fromCharCode(oe);else{var Vo=oe-65536;xe+=String.fromCharCode(55296|Vo>>10,56320|Vo&1023)}}return xe}function qt(U,Q){return U?Rt(Me,U,Q):""}function Kt(U,Q,xt,$t){if(!($t>0))return 0;for(var he=xt,xe=xt+$t-1,oe=0;oe<U.length;++oe){var ee=U.charCodeAt(oe);if(ee>=55296&&ee<=57343){var hr=U.charCodeAt(++oe);ee=65536+((ee&1023)<<10)|hr&1023}if(ee<=127){if(xt>=xe)break;Q[xt++]=ee}else if(ee<=2047){if(xt+1>=xe)break;Q[xt++]=192|ee>>6,Q[xt++]=128|ee&63}else if(ee<=65535){if(xt+2>=xe)break;Q[xt++]=224|ee>>12,Q[xt++]=128|ee>>6&63,Q[xt++]=128|ee&63}else{if(xt+3>=xe)break;Q[xt++]=240|ee>>18,Q[xt++]=128|ee>>12&63,Q[xt++]=128|ee>>6&63,Q[xt++]=128|ee&63}}return Q[xt]=0,xt-he}function me(U,Q,xt){return Kt(U,Me,Q,xt)}function Ft(U){for(var Q=0,xt=0;xt<U.length;++xt){var $t=U.charCodeAt(xt);$t>=55296&&$t<=57343&&($t=65536+(($t&1023)<<10)|U.charCodeAt(++xt)&1023),$t<=127?++Q:$t<=2047?Q+=2:$t<=65535?Q+=3:Q+=4}return Q}var Ae=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):void 0;function Ie(U,Q){Jr.set(U,Q)}function le(U,Q,xt){for(var $t=0;$t<U.length;++$t)Jr[Q++>>0]=U.charCodeAt($t);xt||(Jr[Q>>0]=0)}function qe(U,Q){return U%Q>0&&(U+=Q-U%Q),U}var Re,Jr,Me,Lo,Or,Qr,tn,qr,so;function $n(U){Re=U,e.HEAP8=Jr=new Int8Array(U),e.HEAP16=Lo=new Int16Array(U),e.HEAP32=Qr=new Int32Array(U),e.HEAPU8=Me=new Uint8Array(U),e.HEAPU16=Or=new Uint16Array(U),e.HEAPU32=tn=new Uint32Array(U),e.HEAPF32=qr=new Float32Array(U),e.HEAPF64=so=new Float64Array(U)}var Mo=e.INITIAL_MEMORY||16777216,io,Cl=[],Fu=[],np=[],dr=!1,op=!1,sp=0;function Vd(){return ot||sp>0}function wg(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Ig(e.preRun.shift());Wd(Cl)}function Cg(){dr=!0,Wd(Fu)}function Qk(){op=!0}function vg(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)Sg(e.postRun.shift());Wd(np)}function Ig(U){Cl.unshift(U)}function zo(U){Fu.unshift(U)}function Sg(U){np.unshift(U)}var Hn=0,ip=null,vl=null;function Av(U){Hn++,e.monitorRunDependencies&&e.monitorRunDependencies(Hn)}function Tg(U){if(Hn--,e.monitorRunDependencies&&e.monitorRunDependencies(Hn),Hn==0&&(ip!==null&&(clearInterval(ip),ip=null),vl)){var Q=vl;vl=null,Q()}}e.preloadedImages={},e.preloadedAudios={};function Ou(U){e.onAbort&&e.onAbort(U),U="Aborted("+U+")",D(U),it=!0,pt=1,U+=". Build with -s ASSERTIONS=1 for more info.";var Q=new WebAssembly.RuntimeError(U);throw o(Q),Q}var $v="data:application/octet-stream;base64,";function Ng(U){return U.startsWith($v)}function Pu(U){return U.startsWith("file://")}var en;en="tfjs-backend-wasm.wasm",Ng(en)||(en=d(en));function Gd(U){try{if(U==en&&K)return new Uint8Array(K);if(x)return x(U);throw"both async and sync fetching of the wasm failed"}catch(Q){Ou(Q)}}function Dv(){if(!K&&(c||p)){if(typeof fetch=="function"&&!Pu(en))return fetch(en,{credentials:"same-origin"}).then(function(U){if(!U.ok)throw"failed to load wasm binary file at '"+en+"'";return U.arrayBuffer()}).catch(function(){return Gd(en)});if(g)return new Promise(function(U,Q){g(en,function(xt){U(new Uint8Array(xt))},Q)})}return Promise.resolve().then(function(){return Gd(en)})}function Rv(){var U={env:up,wasi_snapshot_preview1:up};function Q(oe,ee){var hr=oe.exports;e.asm=hr,st=e.asm.memory,$n(st.buffer),io=e.asm.__indirect_function_table,zo(e.asm.__wasm_call_ctors),Tg("wasm-instantiate")}Av("wasm-instantiate");function xt(oe){Q(oe.instance)}function $t(oe){return Dv().then(function(ee){return WebAssembly.instantiate(ee,U)}).then(function(ee){return ee}).then(oe,function(ee){D("failed to asynchronously prepare wasm: "+ee),Ou(ee)})}function he(){return!K&&typeof WebAssembly.instantiateStreaming=="function"&&!Ng(en)&&!Pu(en)&&typeof fetch=="function"?fetch(en,{credentials:"same-origin"}).then(function(oe){var ee=WebAssembly.instantiateStreaming(oe,U);return ee.then(xt,function(hr){return D("wasm streaming compile failed: "+hr),D("falling back to ArrayBuffer instantiation"),$t(xt)})}):$t(xt)}if(e.instantiateWasm)try{var xe=e.instantiateWasm(U,Q);return xe}catch(oe){return D("Module.instantiateWasm callback failed with error: "+oe),!1}return he().catch(o),{}}var t1,e1;function Wd(U){for(;U.length>0;){var Q=U.shift();if(typeof Q=="function"){Q(e);continue}var xt=Q.func;typeof xt=="number"?Q.arg===void 0?Ud(xt)():Ud(xt)(Q.arg):xt(Q.arg===void 0?null:Q.arg)}}function Il(U){return U}function kg(U){var Q=/\b_Z[\w\d_]+/g;return U.replace(Q,function(xt){var $t=xt;return xt===$t?xt:$t+" ["+xt+"]"})}var Bo=[];function Ud(U){var Q=Bo[U];return Q||(U>=Bo.length&&(Bo.length=U+1),Bo[U]=Q=io.get(U)),Q}function r1(){var U=new Error;if(!U.stack){try{throw new Error}catch(Q){U=Q}if(!U.stack)return"(no stack trace available)"}return U.stack.toString()}function ap(U,Q){io.set(U,Q),Bo[U]=Q}function Fv(){Ou("")}function Hd(){return 2147483648}function _g(U,Q,xt){Me.copyWithin(U,Q,Q+xt)}function rn(U){try{return st.grow(U-Re.byteLength+65535>>>16),$n(st.buffer),1}catch(Q){}}function Eg(U){var Q=Me.length;U=U>>>0;var xt=Hd();if(U>xt)return!1;for(var $t=1;$t<=4;$t*=2){var he=Q*(1+.2/$t);he=Math.min(he,U+100663296);var xe=Math.min(xt,qe(Math.max(U,he),65536)),oe=rn(xe);if(oe)return!0}return!1}var lp={mappings:{},buffers:[null,[],[]],printChar:function(U,Q){var xt=lp.buffers[U];Q===0||Q===10?((U===1?$:D)(Rt(xt,0)),xt.length=0):xt.push(Q)},varargs:void 0,get:function(){lp.varargs+=4;var U=Qr[lp.varargs-4>>2];return U},getStr:function(U){var Q=qt(U);return Q},get64:function(U,Q){return U}};function Ov(U){return 0}function n1(U,Q,xt,$t,he){}function o1(U,Q,xt,$t){for(var he=0,xe=0;xe<xt;xe++){var oe=Qr[Q>>2],ee=Qr[Q+4>>2];Q+=8;for(var hr=0;hr<ee;hr++)lp.printChar(U,Me[oe+hr]);he+=ee}return Qr[$t>>2]=he,0}function Pv(U){et(U)}var Ag=!1,up={abort:Fv,emscripten_get_heap_max:Hd,emscripten_memcpy_big:_g,emscripten_resize_heap:Eg,fd_close:Ov,fd_seek:n1,fd_write:o1,setTempRet0:Pv},oU=Rv(),s1=e.___wasm_call_ctors=function(){return(s1=e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)},Lv=e._init=function(){return(Lv=e._init=e.asm.init).apply(null,arguments)},Mv=e._init_with_threads_count=function(){return(Mv=e._init_with_threads_count=e.asm.init_with_threads_count).apply(null,arguments)},$g=e._get_threads_count=function(){return($g=e._get_threads_count=e.asm.get_threads_count).apply(null,arguments)},Dg=e._register_tensor=function(){return(Dg=e._register_tensor=e.asm.register_tensor).apply(null,arguments)},zv=e._dispose_data=function(){return(zv=e._dispose_data=e.asm.dispose_data).apply(null,arguments)},Ut=e._dispose=function(){return(Ut=e._dispose=e.asm.dispose).apply(null,arguments)},Bv=e._Abs=function(){return(Bv=e._Abs=e.asm.Abs).apply(null,arguments)},Rg=e._Add=function(){return(Rg=e._Add=e.asm.Add).apply(null,arguments)},Lu=e._AddN=function(){return(Lu=e._AddN=e.asm.AddN).apply(null,arguments)},cp=e._All=function(){return(cp=e._All=e.asm.All).apply(null,arguments)},Vv=e._Any=function(){return(Vv=e._Any=e.asm.Any).apply(null,arguments)},i1=e._ArgMax=function(){return(i1=e._ArgMax=e.asm.ArgMax).apply(null,arguments)},Gv=e._AvgPool=function(){return(Gv=e._AvgPool=e.asm.AvgPool).apply(null,arguments)},a1=e._BatchMatMul=function(){return(a1=e._BatchMatMul=e.asm.BatchMatMul).apply(null,arguments)},Mu=e._Ceil=function(){return(Mu=e._Ceil=e.asm.Ceil).apply(null,arguments)},Wv=e._ClipByValue=function(){return(Wv=e._ClipByValue=e.asm.ClipByValue).apply(null,arguments)},Uv=e._Conv2D=function(){return(Uv=e._Conv2D=e.asm.Conv2D).apply(null,arguments)},Hv=e._Conv2DBackpropInput=function(){return(Hv=e._Conv2DBackpropInput=e.asm.Conv2DBackpropInput).apply(null,arguments)},qv=e._Cos=function(){return(qv=e._Cos=e.asm.Cos).apply(null,arguments)},Kv=e._Cosh=function(){return(Kv=e._Cosh=e.asm.Cosh).apply(null,arguments)},jv=e._CropAndResize=function(){return(jv=e._CropAndResize=e.asm.CropAndResize).apply(null,arguments)},Fg=e._Cumprod=function(){return(Fg=e._Cumprod=e.asm.Cumprod).apply(null,arguments)},Xv=e._Cumsum=function(){return(Xv=e._Cumsum=e.asm.Cumsum).apply(null,arguments)},Yv=e._DepthToSpace=function(){return(Yv=e._DepthToSpace=e.asm.DepthToSpace).apply(null,arguments)},Zv=e._DepthwiseConv2dNative=function(){return(Zv=e._DepthwiseConv2dNative=e.asm.DepthwiseConv2dNative).apply(null,arguments)},Jv=e._Elu=function(){return(Jv=e._Elu=e.asm.Elu).apply(null,arguments)},Qv=e._Equal=function(){return(Qv=e._Equal=e.asm.Equal).apply(null,arguments)},Og=e._Exp=function(){return(Og=e._Exp=e.asm.Exp).apply(null,arguments)},tI=e._FlipLeftRight=function(){return(tI=e._FlipLeftRight=e.asm.FlipLeftRight).apply(null,arguments)},eI=e._Floor=function(){return(eI=e._Floor=e.asm.Floor).apply(null,arguments)},zu=e._FloorDiv=function(){return(zu=e._FloorDiv=e.asm.FloorDiv).apply(null,arguments)},qd=e._FusedBatchNorm=function(){return(qd=e._FusedBatchNorm=e.asm.FusedBatchNorm).apply(null,arguments)},rI=e._FusedConv2D=function(){return(rI=e._FusedConv2D=e.asm.FusedConv2D).apply(null,arguments)},nI=e._FusedDepthwiseConv2D=function(){return(nI=e._FusedDepthwiseConv2D=e.asm.FusedDepthwiseConv2D).apply(null,arguments)},oI=e._Gather=function(){return(oI=e._Gather=e.asm.Gather).apply(null,arguments)},ne=e._GatherNd=function(){return(ne=e._GatherNd=e.asm.GatherNd).apply(null,arguments)},sI=e._Greater=function(){return(sI=e._Greater=e.asm.Greater).apply(null,arguments)},iI=e._GreaterEqual=function(){return(iI=e._GreaterEqual=e.asm.GreaterEqual).apply(null,arguments)},aI=e._LeakyRelu=function(){return(aI=e._LeakyRelu=e.asm.LeakyRelu).apply(null,arguments)},lI=e._Less=function(){return(lI=e._Less=e.asm.Less).apply(null,arguments)},uI=e._LessEqual=function(){return(uI=e._LessEqual=e.asm.LessEqual).apply(null,arguments)},cI=e._Log=function(){return(cI=e._Log=e.asm.Log).apply(null,arguments)},Kd=e._LogicalAnd=function(){return(Kd=e._LogicalAnd=e.asm.LogicalAnd).apply(null,arguments)},Pg=e._LogicalNot=function(){return(Pg=e._LogicalNot=e.asm.LogicalNot).apply(null,arguments)},Lg=e._LogicalOr=function(){return(Lg=e._LogicalOr=e.asm.LogicalOr).apply(null,arguments)},pI=e._LogicalXor=function(){return(pI=e._LogicalXor=e.asm.LogicalXor).apply(null,arguments)},mI=e._Max=function(){return(mI=e._Max=e.asm.Max).apply(null,arguments)},fI=e._MaxPool=function(){return(fI=e._MaxPool=e.asm.MaxPool).apply(null,arguments)},dI=e._Maximum=function(){return(dI=e._Maximum=e.asm.Maximum).apply(null,arguments)},hI=e._Mean=function(){return(hI=e._Mean=e.asm.Mean).apply(null,arguments)},gI=e._Min=function(){return(gI=e._Min=e.asm.Min).apply(null,arguments)},rr=e._Minimum=function(){return(rr=e._Minimum=e.asm.Minimum).apply(null,arguments)},xI=e._MirrorPad=function(){return(xI=e._MirrorPad=e.asm.MirrorPad).apply(null,arguments)},yI=e._Multiply=function(){return(yI=e._Multiply=e.asm.Multiply).apply(null,arguments)},bI=e._Neg=function(){return(bI=e._Neg=e.asm.Neg).apply(null,arguments)},pp=e._NonMaxSuppressionV3=function(){return(pp=e._NonMaxSuppressionV3=e.asm.NonMaxSuppressionV3).apply(null,arguments)},Mg=e._NonMaxSuppressionV4=function(){return(Mg=e._NonMaxSuppressionV4=e.asm.NonMaxSuppressionV4).apply(null,arguments)},zg=e._NonMaxSuppressionV5=function(){return(zg=e._NonMaxSuppressionV5=e.asm.NonMaxSuppressionV5).apply(null,arguments)},Bg=e._NotEqual=function(){return(Bg=e._NotEqual=e.asm.NotEqual).apply(null,arguments)},wI=e._OneHot=function(){return(wI=e._OneHot=e.asm.OneHot).apply(null,arguments)},Vg=e._PadV2=function(){return(Vg=e._PadV2=e.asm.PadV2).apply(null,arguments)},CI=e._Pow=function(){return(CI=e._Pow=e.asm.Pow).apply(null,arguments)},l1=e._Prelu=function(){return(l1=e._Prelu=e.asm.Prelu).apply(null,arguments)},Gg=e._Prod=function(){return(Gg=e._Prod=e.asm.Prod).apply(null,arguments)},u1=e._RealDiv=function(){return(u1=e._RealDiv=e.asm.RealDiv).apply(null,arguments)},vI=e._Relu=function(){return(vI=e._Relu=e.asm.Relu).apply(null,arguments)},II=e._Relu6=function(){return(II=e._Relu6=e.asm.Relu6).apply(null,arguments)},SI=e._ResizeBilinear=function(){return(SI=e._ResizeBilinear=e.asm.ResizeBilinear).apply(null,arguments)},TI=e._ResizeNearestNeighbor=function(){return(TI=e._ResizeNearestNeighbor=e.asm.ResizeNearestNeighbor).apply(null,arguments)},NI=e._Reverse=function(){return(NI=e._Reverse=e.asm.Reverse).apply(null,arguments)},kI=e._RotateWithOffset=function(){return(kI=e._RotateWithOffset=e.asm.RotateWithOffset).apply(null,arguments)},_I=e._Round=function(){return(_I=e._Round=e.asm.Round).apply(null,arguments)},EI=e._Rsqrt=function(){return(EI=e._Rsqrt=e.asm.Rsqrt).apply(null,arguments)},AI=e._ScatterNd=function(){return(AI=e._ScatterNd=e.asm.ScatterNd).apply(null,arguments)},$I=e._SelectV2=function(){return($I=e._SelectV2=e.asm.SelectV2).apply(null,arguments)},DI=e._Sigmoid=function(){return(DI=e._Sigmoid=e.asm.Sigmoid).apply(null,arguments)},RI=e._Sin=function(){return(RI=e._Sin=e.asm.Sin).apply(null,arguments)},FI=e._Softmax=function(){return(FI=e._Softmax=e.asm.Softmax).apply(null,arguments)},OI=e._SparseFillEmptyRows=function(){return(OI=e._SparseFillEmptyRows=e.asm.SparseFillEmptyRows).apply(null,arguments)},PI=e._SparseReshape=function(){return(PI=e._SparseReshape=e.asm.SparseReshape).apply(null,arguments)},LI=e._SparseSegmentReduction=function(){return(LI=e._SparseSegmentReduction=e.asm.SparseSegmentReduction).apply(null,arguments)},MI=e._Sqrt=function(){return(MI=e._Sqrt=e.asm.Sqrt).apply(null,arguments)},zI=e._Square=function(){return(zI=e._Square=e.asm.Square).apply(null,arguments)},BI=e._SquaredDifference=function(){return(BI=e._SquaredDifference=e.asm.SquaredDifference).apply(null,arguments)},VI=e._Step=function(){return(VI=e._Step=e.asm.Step).apply(null,arguments)},GI=e._StridedSlice=function(){return(GI=e._StridedSlice=e.asm.StridedSlice).apply(null,arguments)},WI=e._Sub=function(){return(WI=e._Sub=e.asm.Sub).apply(null,arguments)},UI=e._Sum=function(){return(UI=e._Sum=e.asm.Sum).apply(null,arguments)},HI=e._Tan=function(){return(HI=e._Tan=e.asm.Tan).apply(null,arguments)},qI=e._Tanh=function(){return(qI=e._Tanh=e.asm.Tanh).apply(null,arguments)},KI=e._Tile=function(){return(KI=e._Tile=e.asm.Tile).apply(null,arguments)},jI=e._TopK=function(){return(jI=e._TopK=e.asm.TopK).apply(null,arguments)},XI=e._Transform=function(){return(XI=e._Transform=e.asm.Transform).apply(null,arguments)},YI=e._Transpose=function(){return(YI=e._Transpose=e.asm.Transpose).apply(null,arguments)},ZI=e.__FusedMatMul=function(){return(ZI=e.__FusedMatMul=e.asm._FusedMatMul).apply(null,arguments)},JI=e._malloc=function(){return(JI=e._malloc=e.asm.malloc).apply(null,arguments)},QI=e._free=function(){return(QI=e._free=e.asm.free).apply(null,arguments)},t0=e.___errno_location=function(){return(t0=e.___errno_location=e.asm.__errno_location).apply(null,arguments)},e0=e._emscripten_main_thread_process_queued_calls=function(){return(e0=e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},Wg=e.stackSave=function(){return(Wg=e.stackSave=e.asm.stackSave).apply(null,arguments)},Ug=e.stackRestore=function(){return(Ug=e.stackRestore=e.asm.stackRestore).apply(null,arguments)},jd=e.stackAlloc=function(){return(jd=e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)},r0=e.dynCall_iijjiiii=function(){return(r0=e.dynCall_iijjiiii=e.asm.dynCall_iijjiiii).apply(null,arguments)},n0=e.dynCall_jiji=function(){return(n0=e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)};e.cwrap=bt;var mp;function Xd(U){this.name="ExitStatus",this.message="Program terminated with exit("+U+")",this.status=U}vl=function U(){mp||Yd(),mp||(vl=U)};function Yd(U){if(U=U||a,Hn>0||(wg(),Hn>0))return;function Q(){mp||(mp=!0,e.calledRun=!0,!it&&(Cg(),n(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),vg()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),Q()},1)):Q()}e.run=Yd;function c1(U){pt=U,Vd()||(e.onExit&&e.onExit(U),it=!0),l(U,new Xd(U))}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();Yd();var fp;s&&(fp={uncaughtException:process.listeners("uncaughtException").filter(function(U){return!s.uncaughtException.indexOf(U)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(U){return!s.unhandledRejection.indexOf(U)>-1})});var dp;if(typeof t!="undefined")dp=t;else if(typeof WasmBackendModuleThreadedSimd!="undefined")dp=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(fp){var o0=dp._dispose;dp._dispose=function(){o0(),fp.uncaughtException.forEach(function(U){process.removeListener("uncaughtException",U)}),fp.unhandledRejection.forEach(function(U){process.removeListener("unhandledRejection",U)})}}return t.ready}})();typeof _v=="object"&&typeof jk=="object"?jk.exports=Kk:typeof define=="function"&&define.amd?define([],function(){return Kk}):typeof _v=="object"&&(_v.WasmBackendModule=Kk)});var ra=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},Ho=class{refCount(t){return qn("refCount")}incRef(t){return qn("incRef")}timerAvailable(){return!0}time(t){return qn("time")}read(t){return qn("read")}readSync(t){return qn("readSync")}readToGPU(t,e){return qn("readToGPU")}numDataIds(){return qn("numDataIds")}disposeData(t,e){return qn("disposeData")}write(t,e,n){return qn("write")}move(t,e,n,o,s){return qn("move")}memory(){return qn("memory")}floatPrecision(){return qn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return qn("dispose")}};function qn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function w1(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Jg(r,t,e)}function n4(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Jg(r,e,n),Jg(t,e,n)}function yp(r,t,e){return Math.max(r,Math.min(t,e))}function o4(r){return r%2===0?r:r+1}function Jg(r,t,e){let n=r[t];r[t]=r[e],r[e]=n}function s4(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function i4(r,t){let e=Math.random();return t*e+(1-e)*r}function a4(r,t){let e=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(t[n]);e+=o*o}return e}function A(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Fe(r,t,e=""){A(Rn(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function Kn(r){A(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function qo(r,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(r)||xr(r)&&!e)for(let n=0;n<r.length;++n)qo(r[n],t,e);else t.push(r);return t}function Qt(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function l4(r){return r.length===0}function Rn(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function na(r){return r%1===0}function u4(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function c4(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function p4(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return w1(t),t}function Gu(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function m4(r,t=n=>0,e){return new Promise((n,o)=>{let s=0,i=()=>{if(r()){n();return}s++;let a=t(s);if(e!=null&&s>=e){o();return}setTimeout(i,a)};i()})}function f4(r,t){let e=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=r.slice();return o[n]=t/e,o}function ur(r,t){let e=t.length;return r=r==null?t.map((n,o)=>o):[].concat(r),A(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),A(r.every(n=>na(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function m0(r,t){let e=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:ur(t,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(e.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(e.push(r[a]),n.push(a))}return{newShape:e,keptDims:n}}function f0(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function d0(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function h0(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function g0(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function d4(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function xr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function Qg(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function x0(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function Ko(r){return typeof r=="string"||r instanceof String}function C1(r){return typeof r=="boolean"}function v1(r){return typeof r=="number"}function bp(r){return Array.isArray(r)?bp(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":v1(r)?"float32":Ko(r)?"string":C1(r)?"bool":"float32"}function ui(r){return!!(r&&r.constructor&&r.call&&r.apply)}function wp(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function ci(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function I1(r,t,e,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=e[r+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=I1(r+u*a,i,e,n)}return o}function Vu(r,t,e=!1){if(r.length===0)return t[0];let n=r.reduce((o,s)=>o*s)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return I1(0,r,t,e)}function Qd(r,t){let e=Cp(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function Cp(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function h4(r,t){let e=r.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Vu(r,new Float32Array(e));if(t==="int32")return Vu(r,new Int32Array(e));if(t==="bool")return Vu(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function th(r){r.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function g4(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function x4(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function eh(r){return r&&r.then&&typeof r.then=="function"}var S1="tfjsflags",rh=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=b4,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(eh(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);S1 in t&&t[S1].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=C4(o,s)})}};function b4(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(w4(t,n[0],n[1]),n.join("="))),t}function w4(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function C4(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function B(){return y0}var y0=null;function T1(r){y0=r}var b0;function w0(){if(b0==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");b0=r}return b0}function v4(){let r=w0();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function nh(r,t){let e=v4();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var pi="Abs",oa="Acos",sa="Acosh",jn="Add",jo="AddN",ia="All",aa="Any",Xo="ArgMax",Nl="ArgMin",la="Asin",ua="Asinh",ca="Atan",pa="Atanh",ma="Atan2",Yo="AvgPool",vp="AvgPoolGrad",kl="AvgPool3D",Ip="AvgPool3DGrad",Zo="BatchMatMul",mi="BatchToSpaceND",Sp="Bincount",N1="BroadcastTo",Tp="BroadcastArgs",ao="Cast",Jo="Ceil",lo="ClipByValue",Np="Complex",_l="ComplexAbs",fi="Concat",Qo="Conv2D",kp="Conv2DBackpropFilter",ts="Conv2DBackpropInput",El="Conv3D",_p="Conv3DBackpropFilterV2",Ep="Conv3DBackpropInputV2",es="Cos",rs="Cosh",fa="Cumprod",ns="Cumsum",da="CropAndResize",Ap="DenseBincount",ha="DepthToSpace",os="DepthwiseConv2dNative",$p="DepthwiseConv2dNativeBackpropFilter",Dp="DepthwiseConv2dNativeBackpropInput",Rp="Diag",Al="Dilation2D",oh="Dilation2DBackpropInput",sh="Dilation2DBackpropFilter",ss="RealDiv",Fp="Einsum",is="Elu",Op="EluGrad",ga="Erf",xa="Equal",as="Exp",di="ExpandDims",ya="Expm1",Pp="FFT",$l="Fill",ba="FlipLeftRight",ls="Floor",us="FloorDiv",cs="FusedBatchNorm",hi="GatherV2",wa="GatherNd",Ca="Greater",ps="GreaterEqual",uo="Identity",Lp="IFFT",Mp="Imag",va="IsFinite",Ia="IsInf",Sa="IsNan",ms="LeakyRelu",Ta="Less",Na="LessEqual",zp="LinSpace",fs="Log",ka="Log1p",_a="LogicalAnd",Ea="LogicalNot",Aa="LogicalOr",k1="LogicalXor",_1="LogSoftmax",Ilt="LowerBound",Dl="LRN",Bp="LRNGrad",ds="Max",hs="Maximum",gs="MaxPool",Vp="MaxPoolGrad",Rl="MaxPool3D",Gp="MaxPool3DGrad",Wp="MaxPoolWithArgmax",xs="Mean",ys="Min",bs="Minimum",ws="MirrorPad",$a="Mod",Up="Multinomial",Cs="Multiply",gi="Neg",Da="NotEqual",Ra="NonMaxSuppressionV3",Fa="NonMaxSuppressionV4",Oa="NonMaxSuppressionV5",xi="OnesLike",vs="OneHot",yi="Pack",Is="PadV2",Slt="Pool",Ss="Pow",Ts="Prelu",Ns="Prod",Hp="RaggedTensorToTensor",Fl="Range",qp="Real",Pa="Reciprocal",ks="Relu",bi="Reshape",_s="ResizeNearestNeighbor",Kp="ResizeNearestNeighborGrad",Es="ResizeBilinear",jp="ResizeBilinearGrad",As="Relu6",$s="Reverse",Ds="Round",Rs="Rsqrt",La="ScatterNd",Xp="SearchSorted",wi="Select",Ma="Selu",Ci="Slice",Fs="Sin",za="Sinh",Ba="Sign",Os="Sigmoid",Va="Softplus",Ps="Sqrt",Ls="Sum",vi="SpaceToBatchND",Ii="SplitV",Ms="Softmax",Ol="SparseFillEmptyRows",Ga="SparseReshape",Pl="SparseSegmentMean",Ll="SparseSegmentSum",Yp="SparseToDense",zs="SquaredDifference",Ml="Square",Wa="StridedSlice",zl="StringNGrams",Bl="StringSplit",Vl="StringToHashBucketFast",Bs="Sub",Vs="Tan",Gs="Tanh",Xn="Tile",Ua="TopK",Ha="Transform",Yn="Transpose",Zp="Unique",Si="Unpack",Gl="UnsortedSegmentSum",Tlt="UpperBound",Ti="ZerosLike",co="Step",ih="FromPixels",qa="RotateWithOffset",Ni="_FusedMatMul",ki="FusedConv2D",_i="FusedDepthwiseConv2D";function Ei(...r){B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(...r)}function I4(...r){B().getBool("IS_TEST")||B().getBool("PROD")||console.log(...r)}var Jp=nh("kernelRegistry",()=>new Map),ah=nh("gradRegistry",()=>new Map);function lh(r,t){let e=v0(r,t);return Jp.get(e)}function C0(r){return ah.get(r)}function tx(r){let t=Jp.entries(),e=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&e.push(i)}return e}function Wu(r){let{kernelName:t,backendName:e}=r,n=v0(t,e);Jp.has(n)&&Ei(`The kernel '${t}' for backend '${e}' is already registered`),Jp.set(n,r)}function A1(r){let{kernelName:t}=r;ah.has(t)&&B().getBool("DEBUG")&&Ei(`Overriding the gradient for '${t}'`),ah.set(t,r)}function Alt(r,t){let e=v0(r,t);if(!Jp.has(e))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);Jp.delete(e)}function $lt(r){if(!ah.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);ah.delete(r)}function Dlt(r,t){tx(r).forEach(n=>{let o=Object.assign({},n,{backendName:t});Wu(o)})}function v0(r,t){return`${t}_${r}`}var y={};jt(y,{arraysEqual:()=>Rn,assert:()=>A,assertNonNegativeIntegerDimensions:()=>th,assertNonNull:()=>Kn,assertShapesMatch:()=>Fe,bytesFromStringArray:()=>x0,bytesPerElement:()=>Qg,checkConversionForErrors:()=>h0,clamp:()=>yp,computeStrides:()=>ci,createScalarValue:()=>A4,createShuffledIndices:()=>p4,decodeString:()=>rm,distSquared:()=>a4,encodeString:()=>Ul,fetch:()=>D4,fingerPrint64:()=>E4,flatten:()=>qo,getArrayFromDType:()=>d0,getTypedArrayFromDType:()=>f0,hasEncodingLoss:()=>d4,hexToLong:()=>uh,indexToLoc:()=>x4,inferDtype:()=>bp,inferFromImplicitShape:()=>f4,isBoolean:()=>C1,isFunction:()=>ui,isInt:()=>na,isNumber:()=>v1,isPromise:()=>eh,isScalarShape:()=>l4,isString:()=>Ko,isTypedArray:()=>xr,isValidDtype:()=>g0,locToIndex:()=>g4,makeOnesTypedArray:()=>Qd,makeZerosNestedTypedArray:()=>h4,makeZerosTypedArray:()=>Cp,nearestDivisor:()=>wp,nearestLargerEven:()=>o4,now:()=>ju,parseAxisParam:()=>ur,randUniform:()=>i4,repeatedTry:()=>m4,rightPad:()=>Gu,shuffle:()=>w1,shuffleCombo:()=>n4,sizeFromShape:()=>Qt,sizeToSquarishShape:()=>c4,squeezeShape:()=>m0,sum:()=>s4,swap:()=>Jg,tanh:()=>u4,toNestedArray:()=>Vu,toTypedArray:()=>em});var N0=Tl(V1());var Ku=N0.default||N0;function uh(r){return Ku.fromString(r,!0,16)}var W1=uh("c3a5c85c97cb3127"),qu=uh("b492b66fbe98f273"),on=uh("9ae16a3b2f90404f");function T0(r){return r.xor(r.shru(47))}function U1(r,t,e){let n=r.slice(t,t+e);return Ku.fromBytes(Array.from(n),!0,!0)}function ze(r,t){return U1(r,t,8)}function G1(r,t){return U1(r,t,4)}function kr(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function Wl(r,t,e=uh("9ddfea08eb382d69")){let n=r.xor(t).mul(e);n=n.xor(n.shru(47));let o=t.xor(n).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function T4(r,t,e,n,o,s){o=o.add(r),s=kr(s.add(o).add(n),21);let i=o;return o=o.add(t),o=o.add(e),s=s.add(kr(o,44)),[o.add(n),s.add(i)]}function rx(r,t,e,n){return T4(ze(r,t),ze(r,t+8),ze(r,t+16),ze(r,t+24),e,n)}function N4(r,t=r.length){if(t>=8){let e=on.add(t*2),n=ze(r,0).add(on),o=ze(r,t-8),s=kr(o,37).mul(e).add(n),i=kr(n,25).add(o).mul(e);return Wl(s,i,e)}if(t>=4){let e=on.add(t*2),n=G1(r,0);return Wl(n.shl(3).add(t),G1(r,t-4),e)}if(t>0){let e=r[0],n=r[t>>1],o=r[t-1],s=e+(n<<8),i=t+(o<<2);return T0(on.mul(s).xor(W1.mul(i))).mul(on)}return on}function k4(r,t=r.length){let e=on.add(t*2),n=ze(r,0).mul(qu),o=ze(r,8),s=ze(r,t-8).mul(e),i=ze(r,t-16).mul(on);return Wl(kr(n.add(o),43).add(kr(s,30)).add(i),n.add(kr(o.add(on),18)).add(s),e)}function _4(r,t=r.length){let e=on.add(t*2),n=ze(r,0).mul(on),o=ze(r,8),s=ze(r,t-8).mul(e),i=ze(r,t-16).mul(on),a=kr(n.add(o),43).add(kr(s,30)).add(i),u=Wl(a,n.add(kr(o.add(on),18)).add(s),e),l=ze(r,16).mul(e),c=ze(r,24),p=a.add(ze(r,t-32)).mul(e),m=u.add(ze(r,t-24)).mul(e);return Wl(kr(l.add(c),43).add(kr(p,30)).add(m),l.add(kr(c.add(n),18)).add(p),e)}function E4(r,t=r.length){let e=Ku.fromNumber(81,!0);if(t<=32)return t<=16?N4(r,t):k4(r,t);if(t<=64)return _4(r,t);let n=e,o=e.mul(qu).add(113),s=T0(o.mul(on).add(113)).mul(on),i=[Ku.UZERO,Ku.UZERO],a=[Ku.UZERO,Ku.UZERO];n=n.mul(on).add(ze(r,0));let u=0,l=(t-1>>6)*64,c=l+(t-1&63)-63;do n=kr(n.add(o).add(i[0]).add(ze(r,u+8)),37).mul(qu),o=kr(o.add(i[1]).add(ze(r,u+48)),42).mul(qu),n=n.xor(a[1]),o=o.add(i[0]).add(ze(r,u+40)),s=kr(s.add(a[0]),33).mul(qu),i=rx(r,u,i[1].mul(qu),n.add(a[0])),a=rx(r,u+32,s.add(a[1]),o.add(ze(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let p=qu.add(s.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=kr(n.add(o).add(i[0]).add(ze(r,u+8)),37).mul(p),o=kr(o.add(i[1]).add(ze(r,u+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(ze(r,u+40))),s=kr(s.add(a[0]),33).mul(p),i=rx(r,u,i[1].mul(p),n.add(a[0])),a=rx(r,u+32,s.add(a[1]),o.add(ze(r,u+16))),[s,n]=[n,s],Wl(Wl(i[0],a[0],p).add(T0(o).mul(W1)).add(s),Wl(i[1],a[1],p).add(n),p)}function A4(r,t){return t==="string"?Ul(r):em([r],t)}function $4(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function em(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=qo(r)),B().getBool("DEBUG")&&h0(r,t),$4(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function ju(){return B().platform.now()}function D4(r,t){return B().platform.fetch(r,t)}function Ul(r,t="utf-8"){return t=t||"utf-8",B().platform.encode(r,t)}function rm(r,t="utf-8"){return t=t||"utf-8",B().platform.decode(r,t)}var nx=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new k0)}profileKernel(t,e,n){let o,s=()=>{o=n()},i,a=ju();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:ju()-a})}if(B().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let c=o[l];c.data().then(p=>{R4(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:o,inputs:s,extraInfo:i}=t;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(e,a,u[0],u[1],s,u[2])})})}};function R4(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var k0=class{logKernelProfile(t,e,n,o,s,i){let a=typeof o=="number"?Gu(`${o}ms`,9):o.error,u=Gu(t,25),l=e.rank,c=e.size,p=Gu(e.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||e.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function H1(r,t,e){let n={},o={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],c=l.inputs;for(let p in c){let m=c[p],f=!1;for(let d=0;d<t.length;d++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[e.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let c={};for(let m in l.inputs){let f=l.inputs[m];n[f.id]&&(c[m]=f)}let p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,a.push(p)}}return a}function q1(r,t,e,n){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=e(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=s.inputs[u];if(!Rn(l.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=l;else{let p=r[c.id];r[c.id]=n(p,l),p.dispose()}}}}var K1=20,ch=3,_0=7;function j1(r,t,e,n){let o=ci(t),s=F4(r,t,e,o),i=t.length,a=ox(r,t,e,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function F4(r,t,e,n){let o=Qt(t),s=n[n.length-1],i=new Array(s).fill(0),a=t.length,u=e==="complex64"?mh(r):r;if(a>1)for(let l=0;l<o/s;l++){let c=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],ph(u[c+p],0,e).length)}return i}function ph(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(_0))} + ${parseFloat(r[1].toFixed(_0))}j`:Ko(r)?n=`'${r}'`:e==="bool"?n=X1(r):n=parseFloat(r.toFixed(_0)).toString(),Gu(n,t)}function X1(r){return r===0?"false":"true"}function ox(r,t,e,n,o,s=!0){let i=e==="complex64"?2:1,a=t[0],u=t.length;if(u===0){if(e==="complex64"){let h=mh(r);return[ph(h[0],0,e)]}return e==="bool"?[X1(r[0])]:[r[0].toString()]}if(u===1){if(a>K1){let g=ch*i,x=Array.from(r.slice(0,g)),b=Array.from(r.slice((a-ch)*i,a*i));return e==="complex64"&&(x=mh(x),b=mh(b)),["["+x.map((w,C)=>ph(w,o[C],e)).join(", ")+", ..., "+b.map((w,C)=>ph(w,o[a-ch+C],e)).join(", ")+"]"]}let h=e==="complex64"?mh(r):Array.from(r);return["["+h.map((g,x)=>ph(g,o[x],e)).join(", ")+"]"]}let l=t.slice(1),c=n.slice(1),p=n[0]*i,m=[];if(a>K1){for(let h=0;h<ch;h++){let g=h*p,x=g+p;m.push(...ox(r.slice(g,x),l,e,c,o,!1))}m.push("...");for(let h=a-ch;h<a;h++){let g=h*p,x=g+p;m.push(...ox(r.slice(g,x),l,e,c,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,x=g+p;m.push(...ox(r.slice(g,x),l,e,c,o,h===a-1))}let f=u===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<u;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function mh(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var fe=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Qt(t),n!=null){let o=n.length;A(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||d0(e,this.size),this.strides=ci(t)}set(t,...e){e.length===0&&(e=[0]),A(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Us().makeTensor(this.values,this.shape,this.dtype)}},Us=null,nm=null,O4=null;function Y1(r){Us=r}function Z1(r){nm=r}function J1(r){O4=r}var Lt=class{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Qt(t),this.strides=ci(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return nm.buffer(this.shape,this.dtype,t)}bufferSync(){return nm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Vu(this.shape,t,this.dtype==="complex64")}arraySync(){return Vu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=Us().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>rm(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Us().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=Us().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>rm(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await Us().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Us().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return nm.print(this,t)}clone(){return this.throwIfDisposed(),nm.clone(this)}toString(t=!1){let e=this.dataSync();return j1(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),nm.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Us().makeVariable(this,t,e,n)}};Object.defineProperty(Lt,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function L(){return nh("Tensor",()=>Lt)}L();var Ka=class extends Lt{constructor(t,e,n,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Rn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Us().disposeTensor(this),this.dataId=t.dataId,Us().incRef(this,null)}dispose(){Us().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ka,Symbol.hasInstance,{value:r=>r instanceof Lt&&r.assign!=null&&r.assign instanceof Function});var ho={};jt(ho,{assertTypesMatch:()=>F0,getTensorsInContainer:()=>fh,isTensorInList:()=>L4,makeTypesMatch:()=>Xt});var E0;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(E0||(E0={}));var A0;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(A0||(A0={}));var $0;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})($0||($0={}));var D0;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(D0||(D0={}));var R0;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(R0||(R0={}));var P4={float32:D0,int32:A0,bool:$0,complex64:R0};function ir(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return P4[r][t]}function Xu(r){return ir(r,"int32")}function Xt(r,t){if(r.dtype===t.dtype)return[r,t];let e=ir(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function F0(r,t){A(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function L4(r,t){return t.some(e=>e.id===r.id)}function fh(r){let t=[];return Q1(r,t,new Set),t}function Q1(r,t,e){if(r==null)return;if(r instanceof Lt){t.push(r);return}if(!M4(r))return;let n=r;for(let o in n){let s=n[o];e.has(s)||(e.add(s),Q1(s,t,e))}}function M4(r){return Array.isArray(r)||typeof r=="object"}function O0(r){return r.kernelName!=null}var sx=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Hl=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new sx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Ei(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new nx(this.backendInstance),!0}setupRegisteredKernels(){tx(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){tx(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=e.factory();if(n&&!(n instanceof Ho)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Ei(`Initialization of backend ${t} failed`),Ei(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return Ei(`Initialization of backend ${t} failed`),Ei(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let n=this.state.tensorInfo.get(e),o=n.backend,s=this.readSync(e),i=o.refCount(e);o.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=e(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,e,n){t();try{let o=n();return e(),o}catch(o){throw e(),o}}nextTensorId(){return Hl.nextTensorId++}nextVariableId(){return Hl.nextVariableId++}clone(t){let e=_.runKernel(uo,{x:t}),n={x:t},o=i=>({x:()=>{let a="float32",u={x:i},l={dtype:a};return _.runKernel(ao,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[e],o,s,{}),e}runKernel(t,e,n){if(this.backendName==null&&this.backend,!(lh(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-e-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u,l=O0(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(O0(t)){let{kernelName:d,inputs:h,attrs:g}=t;this.backendName==null&&this.backend;let x=lh(d,this.backendName);A(x!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),a=()=>{let b=this.backend.numDataIds();u=x.kernelFunc({inputs:h,attrs:g,backend:this.backend});let w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,b,w);let C=w.map(T=>T.rank!=null?T:this.makeTensorFromTensorInfo(T));if(o){let T=this.getTensorsForGradient(d,h,C);n=this.saveTensorsForBackwardMode(T)}return C}}else{let{forwardFunc:d}=t,h=g=>{!o||(n=g.map(x=>this.keep(this.clone(x))))};a=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>d(this.backend,h));let x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,x),x}}let{inputs:c,attrs:p}=t,m=O0(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(f=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs)}),o&&this.addTapeNode(l,c,e,m,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:e.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){let o=C0(t);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(A(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(l=>e[l])):a=s.map(l=>e[l]);let u=n.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(t,e,n,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=t;n==="string"&&Ko(t[0])&&(s=t.map(u=>Ul(u)));let i=o.write(s,e,n),a=new Lt(e,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let u=this.state.tensorInfo.get(i),l=x0(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(t,e,n,o){n=n||"float32";let s={dataId:t,shape:e,dtype:n};return this.makeTensorFromTensorInfo(s,o)}makeTensorFromTensorInfo(t,e){let{dataId:n,shape:o,dtype:s}=t,i=new Lt(o,s,n,this.nextTensorId());return this.trackTensor(i,e),i}makeVariable(t,e=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));let s=new Ka(t,e,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*Qg(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Ka||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*Qg(t.dtype);this.state.numBytes-=n}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},u=C0(t);u!=null&&(o=u.gradFunc),o!=null&&(a.gradient=l=>(l=l.map((c,p)=>{if(c==null){let m=n[p],f=Cp(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),o(l.length>1?l:l[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=fh(t),n=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(t,e,n,o=!1){if(A(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));A(s instanceof Lt,()=>"The result y returned by f() must be a tensor.");let i=H1(this.state.activeTape,e,s);if(!o&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n==null?z4(s.shape):n,q1(a,i,l=>this.tidy(l),B4);let u=e.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let c of l.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return A(ui(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{A(e.every(a=>a instanceof Lt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};e.forEach((a,u)=>{o[u]=a});let s=(a,u)=>(n=t(...e,u),A(n.value instanceof Lt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(ui(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,u)=>{let l=n.gradFunc(a,u),c=Array.isArray(l)?l:[l];A(c.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(m=>m instanceof Lt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){let e=ju(),n=await this.backend.time(t);return n.wallMs=ju()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new sx;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Hl.nextTensorId=0;Hl.nextVariableId=0;function z4(r){let t=Qd(Qt(r),"float32");return _.makeTensor(t,r,"float32")}function P0(){let r=w0();if(r._tfengine==null){let t=new rh(r);r._tfengine=new Hl(t)}return T1(r._tfengine.ENV),Y1(()=>r._tfengine),r._tfengine}var _=P0();function B4(r,t){let e={a:r,b:t};return _.runKernel(jn,e)}var ql={};jt(ql,{isBrowser:()=>M0,isMobile:()=>W4,mockIsMobile:()=>G4});function V4(){return typeof navigator!="undefined"&&navigator!=null}var L0;function G4(r){L0=r}function W4(r){if(L0!==void 0)return L0;if(r||V4()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function M0(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Zn=B();Zn.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Zn.registerFlag("IS_BROWSER",()=>M0());Zn.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Zn.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Zn.registerFlag("PROD",()=>!1);Zn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Zn.getBool("DEBUG"));Zn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Zn.registerFlag("IS_TEST",()=>!1);Zn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Zn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Zn.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);Zn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);function Pr(r,t){let e=r;if(xr(r))return t==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||xr(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&B().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&e_(r,n,[]),n}function e_(r,t,e){if(e=e||[],!Array.isArray(r)&&!xr(r)){A(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),A(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let o=0;o<r.length;++o)e_(r[o],n,e.concat(o))}function t_(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function v(r,t,e,n="numeric"){if(r instanceof Lt)return t_(n,r.dtype,t,e),r;let o=bp(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),t_(n,o,t,e),r==null||!xr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Pr(r,o);!xr(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?em(r,o):qo(r,[],!0);return _.makeTensor(a,s,o)}function ja(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>v(s,`${t}[${i}]`,e,n))}var z0="__op";function N(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+z0;let o=(...s)=>{_.startScope(e);try{let i=n(...s);return eh(i)&&console.error("Cannot return a Promise inside of tidy."),_.endScope(i),i}catch(i){throw _.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function U4(r,t){let e=v(r,"real","complex"),n=v(t,"imag","complex");Fe(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:e,imag:n};return _.runKernel(Np,o)}var Cn=N({complex_:U4});function sn(r,t,e,n){if(n==null&&(n=bp(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!xr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){th(t);let o=Qt(t),s=Qt(e);A(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],u=i===e.length-1?a!==Qt(t.slice(i)):!0;A(e[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!xr(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?em(r,n):qo(r,[],!0),_.makeTensor(r,t,n)}function vr(r,t,e){let n=Pr(r,e);return sn(r,t,n,e)}var dh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var ix=4;async function n_(r,t){let e=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async p=>{let m=await u.bytes(),f=m.reduce((g,x)=>g+x.length,0)+ix*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let x=m[g],b=new Uint8Array(new Uint32Array([x.length]).buffer);d.set(b,h),h+=ix,d.set(x,h),h+=x.length}p(d)});n.push(c)}else n.push(u.data());t!=null&&(l.group=t),e.push(l)}let s=await Promise.all(n);return{data:H4(s),specs:e}}function ax(r,t){let e={},n,o=0;for(let s of t){let i=s.name,a=s.dtype,u=s.shape,l=Qt(u),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=dh[p.dtype],f=r.slice(o,o+l*m),d=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=X4()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*m}else if(a==="string"){let p=Qt(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(o,o+ix))[0];o+=ix;let d=new Uint8Array(r.slice(o,o+f));c.push(d),o+=f}}else{let p=dh[a],m=r.slice(o,o+l*p);if(a==="float32")c=new Float32Array(m);else if(a==="int32")c=new Int32Array(m);else if(a==="bool")c=new Uint8Array(m);else if(a==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let x=0;x<f.length;x++)f[x]=c[x*2],d[x]=c[x*2+1];let h=vr(f,u,"float32"),g=vr(d,u,"float32");e[i]=Cn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*p}a!=="complex64"&&(e[i]=vr(c,u,a))}return e}function H4(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return e.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var B0=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function r_(r){return B0?Buffer.byteLength(r):new Blob([r]).size}function o_(r){if(B0)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function s_(r){if(B0){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function om(r){if(r.length===1)return r[0];let t=0;r.forEach(o=>{t+=o.byteLength});let e=new Uint8Array(t),n=0;return r.forEach(o=>{e.set(new Uint8Array(o),n),n+=o.byteLength}),e.buffer}function V0(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function lx(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}async function sm(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await t(r.weightsManifest);e.weightSpecs=n,e.weightData=o}return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),e}function Ai(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:r_(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:r_(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function q4(){let r=e=>{let n=e<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function K4(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function j4(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function X4(){let r=q4(),t=K4(),e=j4();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[e[a>>10]+(a&1023)]+t[a>>10];s[i]=u}return new Float32Array(o)}}var Se=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Se.instance==null&&(Se.instance=new Se),Se.instance}static registerSaveRouter(t){Se.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Se.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Se.getHandlers(t,"save")}static getLoadHandlers(t,e){return Se.getHandlers(t,"load",e)}static getHandlers(t,e,n){let o=[];return(e==="load"?Se.getInstance().loadRouters:Se.getInstance().saveRouters).forEach(i=>{let a=i(t,n);a!==null&&o.push(a)}),o}},i_=r=>Se.registerSaveRouter(r),a_=r=>Se.registerLoadRouter(r),l_=r=>Se.getSaveHandlers(r),u_=(r,t)=>Se.getLoadHandlers(r,t);var G0="tensorflowjs",W0=1,Yu="models_store",Kl="model_info_store";function c_(){if(!B().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function U0(r){let t=r.result;t.createObjectStore(Yu,{keyPath:"modelPath"}),t.createObjectStore(Kl,{keyPath:"modelPath"})}var $i=class{constructor(t){if(this.indexedDB=c_(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,o)=>{let s=this.indexedDB.open(G0,W0);s.onupgradeneeded=()=>U0(s),s.onsuccess=()=>{let i=s.result;if(e==null){let a=i.transaction(Yu,"readonly"),l=a.objectStore(Yu).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=c=>(i.close(),o(l.error)),a.oncomplete=()=>i.close()}else{let a=Ai(e),u=i.transaction(Kl,"readwrite"),l=u.objectStore(Kl),c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(Yu,"readwrite");let f=p.objectStore(Yu).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a});f.onsuccess=()=>n({modelArtifactsInfo:a}),f.onerror=d=>{l=u.objectStore(Kl);let h=l.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(f.error)),h.onerror=g=>(i.close(),o(f.error))}},c.onerror=m=>(i.close(),o(c.error)),u.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};$i.URL_SCHEME="indexeddb://";var p_=r=>B().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith($i.URL_SCHEME)?Y4(r.slice($i.URL_SCHEME.length)):null;Se.registerSaveRouter(p_);Se.registerLoadRouter(p_);function Y4(r){return new $i(r)}function Z4(r){return r.startsWith($i.URL_SCHEME)?r.slice($i.URL_SCHEME.length):r}var ux=class{constructor(){this.indexedDB=c_()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(G0,W0);n.onupgradeneeded=()=>U0(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Kl,"readonly"),a=s.objectStore(Kl).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;t(u)},a.onerror=u=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>e(n.error)})}async removeModel(t){return t=Z4(t),new Promise((e,n)=>{let o=this.indexedDB.open(G0,W0);o.onupgradeneeded=()=>U0(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Kl,"readwrite"),a=i.objectStore(Kl),u=a.get(t),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{l=s.transaction(Yu,"readwrite");let f=l.objectStore(Yu).delete(t);f.onsuccess=()=>e(u.result.modelArtifactsInfo),f.onerror=d=>n(u.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),n(u.error))}},u.onerror=c=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var Xa="/",im="tensorflowjs_models",m_="info",J4="model_topology",Q4="weight_specs",tH="weight_data",eH="model_metadata";function f_(r){return{info:[im,r,m_].join(Xa),topology:[im,r,J4].join(Xa),weightSpecs:[im,r,Q4].join(Xa),weightData:[im,r,tH].join(Xa),modelMetadata:[im,r,eH].join(Xa)}}function d_(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function rH(r){let t=r.split(Xa);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(Xa)}function nH(r){return r.startsWith(Di.URL_SCHEME)?r.slice(Di.URL_SCHEME.length):r}var Di=class{constructor(t){if(!B().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=f_(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=Ai(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,o_(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw d_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=s_(i),e}};Di.URL_SCHEME="localstorage://";var h_=r=>B().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Di.URL_SCHEME)?oH(r.slice(Di.URL_SCHEME.length)):null;Se.registerSaveRouter(h_);Se.registerLoadRouter(h_);function oH(r){return new Di(r)}var cx=class{constructor(){A(B().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=im+Xa,n=Xa+m_;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(n)){let i=rH(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=nH(t);let e=f_(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return d_(e),n}};var am="://",_r=class{constructor(){this.managers={}}static getInstance(){return _r.instance==null&&(_r.instance=new _r),_r.instance}static registerManager(t,e){A(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(am)&&(t=t.slice(0,t.indexOf(am))),A(t.length>0,()=>"scheme must not be an empty string.");let n=_r.getInstance();A(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=_r.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(_r.getInstance().managers)}};function px(r){if(r.indexOf(am)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${_r.getSchemes().join(",")}`);return{scheme:r.split(am)[0],path:r.split(am)[1]}}async function g_(r,t,e=!1){A(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=Se.getLoadHandlers(r);A(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),A(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Se.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],a=px(r).scheme,u=px(r).path,l=a===px(r).scheme,c=await o.load();e&&l&&await _r.getManager(a).removeModel(u);let p=await i.save(c);return e&&!l&&await _r.getManager(a).removeModel(u),p.modelArtifactsInfo}async function x_(){let r=_r.getSchemes(),t={};for(let e of r){let n=await _r.getManager(e).listModels();for(let o in n){let s=e+am+o;t[s]=n[o]}}return t}async function y_(r){let t=px(r);return _r.getManager(t.scheme).removeModel(t.path)}async function b_(r,t){return g_(r,t,!1)}async function w_(r,t){return g_(r,t,!0)}var H0=class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}};if(B().get("IS_BROWSER")){B().setPlatform("browser",new H0);try{_r.registerManager(Di.URL_SCHEME,new cx)}catch(r){}try{_r.registerManager($i.URL_SCHEME,new ux)}catch(r){}}var sH={importFetch:()=>C_()},q0;var K0=class{constructor(){this.util=v_(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return B().global.fetch!=null?B().global.fetch(t,e):(q0==null&&(q0=sH.importFetch()),q0(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}};B().get("IS_NODE")&&!B().get("IS_BROWSER")&&B().setPlatform("node",new K0);function vt(r,t="float32",e){return t=t||"float32",th(r),new fe(r,t,e)}function iH(r,t){let e=v(r,"x","cast");if(!g0(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},o={dtype:t};return _.runKernel(ao,n,o)}var tt=N({cast_:iH});function aH(r){let e={x:v(r,"x","clone","string_or_numeric")};return _.runKernel(uo,e)}var an=N({clone_:aH});function mx(r,t=!1){console.log(r.toString(t))}P0();var lH={buffer:vt,cast:tt,clone:an,print:mx};Z1(lH);var vn={};jt(vn,{browserFiles:()=>S_,browserHTTPRequest:()=>k_,concatenateArrayBuffers:()=>om,copyModel:()=>b_,decodeWeights:()=>ax,encodeWeights:()=>n_,fromMemory:()=>__,fromMemorySync:()=>Q0,getLoadHandlers:()=>u_,getModelArtifactsForJSON:()=>sm,getModelArtifactsInfoForJSON:()=>Ai,getSaveHandlers:()=>l_,http:()=>dx,isHTTPScheme:()=>fx,listModels:()=>x_,loadWeights:()=>T_,moveModel:()=>w_,registerLoadRouter:()=>a_,registerSaveRouter:()=>i_,removeModel:()=>y_,weightsLoaderFactory:()=>Z0,withSaveHandler:()=>E_,withSaveHandlerSync:()=>A_});var uH="model",cH=".json",pH=".weights.bin";function I_(r){return new Promise(t=>setTimeout(t)).then(r)}var Ya=class{constructor(t){if(!B().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ya.URL_SCHEME)&&(t=t.slice(Ya.URL_SCHEME.length)),(t==null||t.length===0)&&(t=uH),this.modelJsonFileName=t+cH,this.weightDataFileName=t+pH}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=lx(t,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,await I_(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=e,await I_(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ai(t)}}}};Ya.URL_SCHEME="downloads://";var j0=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let u=sm(s,l=>this.loadWeights(l));t(u)},n.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){let e=[],n=[];for(let i of t)e.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,om(i)])}loadWeightsFile(t,e){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(s=>V0(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=V0(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},mH=r=>B().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ya.URL_SCHEME)?fH(r.slice(Ya.URL_SCHEME.length)):null;Se.registerSaveRouter(mH);function fH(r="model"){return new Ya(r)}function S_(r){return new j0(r)}function X0(r,t,e,n){i(r),e=e==null?0:e,n=n==null?1:n,a(e,n);let o=0,s=u=>(u.then(l=>{let c=e+ ++o/r.length*(n-e);return t(c),l}),u);function i(u){A(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),A(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function Y0(r,t){t==null&&(t={});let e=t.fetchFunc==null?B().platform.fetch:t.fetchFunc,n=r.map(p=>e(p,t.requestInit,{isBinary:!0})),o=0,s=.5,a=(t.onProgress==null?await Promise.all(n):await X0(n,t.onProgress,o,s)).map(p=>p.arrayBuffer()),u=.5,l=1;return t.onProgress==null?await Promise.all(a):await X0(a,t.onProgress,u,l)}async function T_(r,t="",e,n){return Z0(i=>Y0(i,{requestInit:n}))(r,t,e)}function Z0(r){return async(t,e="",n)=>{let o=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,b=dh[x]*Qt(g.shape),w=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:b})};n!=null?n.forEach((C,T)=>{C===g.name&&(w(),i[T]=!0)}):w(),a.push(g.name),h+=b})}),!i.every(f=>f)){let f=n.filter((d,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),l=[];u.forEach(f=>{t[f].paths.forEach(d=>{let h=e+(e.endsWith("/")?"":"/")+d;l.push(h)})});let c=await r(l),p={},m=0;return u.forEach(f=>{let d=t[f].paths.length,h=0;for(let C=0;C<d;C++)h+=c[m+C].byteLength;let g=new ArrayBuffer(h),x=new Uint8Array(g),b=0;for(let C=0;C<d;C++){let T=new Uint8Array(c[m+C]);x.set(T,b),b+=T.byteLength}s[f].forEach(C=>{let T=g.slice(C.groupOffset,C.groupOffset+C.sizeBytes),E=ax(T,[C.manifestEntry]);for(let $ in E)p[$]=E[$]}),m+=d}),p}}var dH="application/octet-stream",hH="application/json",hh=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(A(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=B().platform.fetch,A(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&A(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=lx(t,n);e.body.append("model.json",new Blob([JSON.stringify(o)],{type:hH}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:dH}),"model.weights.bin");let s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:Ai(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=e.modelTopology,o=e.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return sm(e,s=>this.loadWeights(s))}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=gH(e),s=this.weightPathPrefix||n,i=[];for(let c of t)i.push(...c.weights);let a=[],u=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(p)):a.push(s+p+o);this.weightUrlConverter&&a.push(...await Promise.all(u));let l=await Y0(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,om(l)]}};hh.URL_SCHEME_REGEX=/^https?:\/\//;function gH(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),o=e>t?r.substring(e):"";return[n+"/",o]}function fx(r){return r.match(hh.URL_SCHEME_REGEX)!=null}var N_=(r,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>fx(n)):e=fx(r),e)return dx(r,t)}return null};Se.registerSaveRouter(N_);Se.registerLoadRouter(N_);function dx(r,t){return new hh(r,t)}function k_(r,t){return dx(r,t)}var gh=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},hx=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},J0=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}};function __(r,t,e,n){let o=arguments;return new J0(Q0(...o))}function Q0(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new gh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gh({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function E_(r){return new hx(r)}function A_(r){return new hx(r)}var R_={};jt(R_,{confusionMatrix:()=>D_});function xH(r,t,e=!1,n=!1){let o=v(r,"a","matMul"),s=v(t,"b","matMul");[o,s]=Xt(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:n};return _.runKernel(Zo,i,a)}var Gt=N({matMul_:xH});function yH(r,t,e=1,n=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:v(r,"indices","oneHot","int32")},a={dtype:o,depth:t,onValue:e,offValue:n};return _.runKernel(vs,i,a)}var Ri=N({oneHot_:yH});function wpt(){B().set("PROD",!0)}function Cpt(){B().set("DEBUG",!0)}function vpt(){B().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function tS(r){B().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}J1(tS);function Ipt(){_.disposeVariables()}function go(){return _}function xh(){return _.memory()}function Spt(r){return _.profile(r)}function G(r,t){return _.tidy(r,t)}function _t(r){fh(r).forEach(e=>e.dispose())}function Oe(r){return _.keep(r)}function Tpt(r){return _.time(r)}function bH(r){return _.setBackend(r)}function Npt(){return _.ready()}function kpt(){return _.backendName}function _pt(r){_.removeBackend(r)}function Ept(r){return _.findBackend(r)}function Apt(r){return _.findBackendFactory(r)}function lm(r,t,e=1){return _.registerBackend(r,t,e)}function $_(){return _.backend}function $pt(r,t){B().setPlatform(r,t)}function wH(r){let e={input:v(r,"input","imag")};return _.runKernel(Mp,e)}var jl=N({imag_:wH});function CH(r){let e={x:v(r,"x","neg")};return _.runKernel(gi,e)}var Yt=N({neg_:CH});function vH(r){let e={input:v(r,"input","real")};return _.runKernel(qp,e)}var Za=N({real_:vH});function IH(r,t,e){let n=v(r,"x","transpose");if(t==null&&(t=n.shape.map((i,a)=>a).reverse()),A(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(i=>{A(i>=0&&i<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let o={x:n},s={perm:t};return n.dtype==="complex64"?G(()=>{let i=Za(n),a=jl(n);return i=_.runKernel(Yn,{x:i},s),a=_.runKernel(Yn,{x:a},s),e&&(a=Yt(a)),Cn(i,a)}):_.runKernel(Yn,o,s)}var Mt=N({transpose_:IH});function SH(r,t,e){let n=v(r,"labels","confusionMatrix"),o=v(t,"predictions","confusionMatrix");A(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),A(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),A(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),A(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),A(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let s=Ri(tt(n,"int32"),e),i=Ri(tt(o,"int32"),e),a=Mt(s),u=Gt(a,i);return tt(u,"int32")}var D_=N({confusionMatrix_:SH});var Lr={};jt(Lr,{assertAndGetBroadcastShape:()=>zt,getBroadcastDims:()=>F_,getReductionAxes:()=>ye});function F_(r,t){let e=r.length,n=[];for(let o=0;o<e;o++){let s=e-1-o,i=r[s]||1;(t[t.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function ye(r,t){let e=[];for(let n=0;n<t.length;n++){let o=r[r.length-n-1],s=t.length-n-1,i=t[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function zt(r,t){let e=[],n=Math.max(r.length,t.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)e.unshift(i);else if(i===1)e.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(a)}else e.unshift(s)}return e}var xx={};jt(xx,{fromPixels:()=>$H,fromPixelsAsync:()=>EH,toPixels:()=>AH});function gx(r,t,e){if(Kn(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Pr(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return sn(r,t,n,e)}var Zu;function O_(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(lh(ih,_.backendName)!=null){let d={pixels:r},h={numChannels:t};return _.runKernel(ih,d,h)}let[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;if(i)p=r.getContext("2d").getImageData(0,0,l,c).data;else if(n||e)p=r.data;else if(s||o||a){if(Zu==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Zu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Zu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Zu.canvas.width=l,Zu.canvas.height=c,Zu.drawImage(r,0,0,l,c),p=Zu.getImageData(0,0,l,c).data}let m;if(t===4)m=new Int32Array(p);else{let d=l*c;m=new Int32Array(d*t);for(let h=0;h<d;h++)for(let g=0;g<t;++g)m[h*t+g]=p[h*4+g]}return gx(m,[c,l,t],"int32")}function TH(r){return r!=null&&r.data instanceof Uint8Array}function NH(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function kH(r){return r!=null&&r.width!==0&&r.height!==0}function _H(r){return NH()&&!(r instanceof ImageBitmap)&&kH(r)&&!TH(r)}async function EH(r,t=3){let e=null;if(B().getBool("WRAP_TO_IMAGEBITMAP")&&_H(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?e=n:e=r}else e=r;return O_(e,t)}async function AH(r,t){let e=v(r,"img","toPixels");if(!(r instanceof Lt)){let l=e;e=tt(l,"int32"),l.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[n,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let i=await e.data(),a=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=i[l*s+m];if(e.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(e.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[m]=f*a}let p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(t!=null){t.width=o,t.height=n;let l=t.getContext("2d"),c=new ImageData(u,o,n);l.putImageData(c,0,0)}return e!==r&&e.dispose(),u}var $H=N({fromPixels_:O_});var yx={};jt(yx,{prepareAndValidate:()=>P_});function P_(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(Qt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=r.shape,u=o.slice();u.pop();let l=1;for(let p=s;p<e;++p)l*=a[p],u.push(a[p]);let c=[...ci(r.shape).map(p=>p/l),1].slice(0,s);return[u,i,l,c]}var yh={};jt(yh,{calculateShapes:()=>L_,validateInput:()=>bx,validateUpdateShape:()=>eS});function eS(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(e.rank-o))throw new Error(s+` Output shape length < ${n+(e.rank-o)}`);if(e.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function bx(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}eS(e,t,r)}function L_(r,t,e){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,u=Qt(t.shape)/a,l=[...ci(e.slice(0,o)),1],c=Qt(e);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}var Be={};jt(Be,{assertParamsValid:()=>RH,computeFlatOffset:()=>MH,computeOutShape:()=>OH,getNormalizedAxes:()=>PH,isSliceContinous:()=>LH,maskToAxes:()=>FH,parseSliceParams:()=>nS,sliceInfo:()=>zH,startForAxis:()=>H_,startIndicesWithElidedDims:()=>G_,stopForAxis:()=>q_,stopIndicesWithElidedDims:()=>W_,stridesForAxis:()=>U_,stridesWithElidedDims:()=>z_});var rS=-2,DH=-1;function RH(r,t,e){let n=r.shape.length;A(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),A(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)A(t[o]+e[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function FH(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function OH(r,t,e){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((t[o]-r[o])/e[o]);return n}function z_(r,t,e,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function B_(r,t,e){return e<=r?e:e-(t-1)}function V_(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function PH(r,t,e,n,o,s,i,a,u){let l=r.length,c=new Array(l),p=new Array(l),m=new Array(l);if(t.length&&e>0){let f=t[0],d=e+1;c=G_(i,f,d,n,r),p=W_(a,f,d,o,r),m=z_(s,f,d,r)}else for(let f=0;f<l;f++)c[f]=H_(i,n,s,r,f,u),p[f]=q_(a,o,s,r,f,u),m[f]=U_(s,f,u);return{begin:c,end:p,strides:m}}function G_(r,t,e,n,o){let s=[...o],i=V_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=B_(t,e,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function W_(r,t,e,n,o){let s=[...o],i=V_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=B_(t,e,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=yp(0,s[a],o[a])}return s}function U_(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function H_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=yp(0,i,u-1),i}function q_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=yp(0,i,u):i=yp(-1,i,u-1),i}function LH(r,t,e){let n=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){n=o;break}for(let o=n+1;o<e.length;o++)if(t[o]>0||e[o]!==r[o])return!1;return!0}function MH(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function nS(r,t,e){let n,o=r.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(i=>{A(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function zH(r,t,e,n,o,s,i,a,u){let l;if(n==null?(l=new Array(t.length),l.fill(1)):l=n,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let w=0;w<p.dims;w++)c&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};BH(p,m);let f=!0,d=!0,h=!0,g=[],x=[];for(let w=0;w<r.length;++w){if(m.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let C=!!(m.shrinkAxisMask&1<<w),T=r[w];if(T===-1){g.push(C?1:-1);continue}let E=[m.beginMask&1<<w,m.endMask&1<<w],$=[m.strides[w]>0?0:-1,m.strides[w]>0?T:T-1];if(C&&m.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&m.strides[w]===1;let D=!!(m.beginMask&1<<w&&m.endMask&1<<w);if(m.beginValid&&m.endValid){if(C){let H=m.begin[w]<0?T+m.begin[w]:m.begin[w];if(m.begin[w]=H,m.end[w]=m.begin[w]+1,H<0||H>=T)throw Error(`slice index ${m.begin[w]} of dimension ${w} out of bounds.`)}else m.begin[w]=M_(m.begin[w],0,m.strides[w],T,E,$),m.end[w]=M_(m.end[w],1,m.strides[w],T,E,$);let W=m.strides[w]===1&&m.begin[w]===0&&m.end[w]===T;f=f&&W,d=d&&(w===0&&m.strides[w]===1||W)}else f=f&&m.strides[w]===1&&D,d=d&&(w===0&&m.strides[w]===1||D);let P,M=!1;if(m.beginValid&&m.endValid?(P=m.end[w]-m.begin[w],M=!0):C?(P=1,M=!0):D&&T>=0&&(m.strides[w]<0?P=-T:P=T,M=!0),M){let W;P===0||P<0!=m.strides[w]<0?W=0:W=Math.trunc(P/m.strides[w])+(P%m.strides[w]!==0?1:0),g.push(W)}else g.push(-1)}for(let w=0;w<m.finalShapeGatherIndices.length;++w){let C=m.finalShapeGatherIndices[w];C>=0?x.push(g[C]):C===rS&&x.push(1)}return{finalShapeSparse:x.filter((w,C)=>m.finalShapeGatherIndices[C]!==rS),finalShape:x,isIdentity:f,sliceDim0:d,isSimpleSlice:h,begin:m.begin,end:m.end,strides:m.strides}}function BH(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(t.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&r.newAxisMask)t.finalShapeGatherIndices.push(rS),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[n]),r.end!=null&&(t.end[e]=r.end[n]),t.strides[e]=r.strides[n],r.beginMask&1<<n&&(t.beginMask|=1<<e),r.endMask&1<<n&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(DH),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function M_(r,t,e,n,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let i=r<0?n+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var rt={};jt(rt,{Serializable:()=>bh,SerializationMap:()=>Fi,registerClass:()=>In});var bh=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Fi=class{constructor(){this.classNameMap={}}static getMap(){return Fi.instance==null&&(Fi.instance=new Fi),Fi.instance}static register(t){Fi.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function In(r){A(r.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),A(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Fi.register(r)}var Y_={};jt(Y_,{TEST_EPSILON_FLOAT16:()=>K_,createVideoElement:()=>KH,encodeStrings:()=>X_,expectArrayBuffersEqual:()=>qH,expectArraysClose:()=>GH,expectArraysEqual:()=>UH,expectNumbersClose:()=>j_,expectPromiseToFail:()=>WH,expectValuesInRange:()=>HH,play:()=>jH,testEpsilon:()=>wx});var VH=.001,K_=.1;function GH(r,t,e){return e==null&&(e=wx()),oS(r,t,(n,o)=>sS(n,o,e))}function wx(){return _.backend.floatPrecision()===32?VH:K_}function oS(r,t,e){let n=!0;if((xr(r)||xr(t))&&(n=!1),xr(r)&&xr(t)&&(n=!0),n){let i=r.constructor.name,a=t.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(r)&&Array.isArray(t)){let i=Pr(r),a=Pr(t);if(!Rn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=xr(r)?r:qo(r),s=xr(t)?t:qo(t);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],u=s[i];if(!e(a,u))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect!="undefined"&&expect().nothing()}function WH(r,t){r().then(()=>t.fail(),()=>t()),typeof expect!="undefined"&&expect().nothing()}function UH(r,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Ko(r)||Ko(r[0])||Ko(t)||Ko(t[0])?oS(r,e,(n,o)=>n==o):oS(r,t,(n,o)=>sS(n,o,0))}function j_(r,t,e){if(e==null&&(e=wx()),!sS(r,t,e))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`);typeof expect!="undefined"&&expect().nothing()}function sS(r,t,e){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>e)}function HH(r,t,e){for(let n=0;n<r.length;n++)if(r[n]<t||r[n]>e)throw new Error(`Value out of range:${r[n]} low: ${t}, high: ${e}`)}function qH(r,t){let e=new Float32Array(r),n=new Float32Array(t);if(e.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${e.length}`);for(let o=0;o<n.length;o++)if(e[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${e[o]} instead`)}function X_(r){for(let t=0;t<r.length;t++){let e=r[t];Array.isArray(e)?X_(e):r[t]=Ul(e)}return r}function KH(r){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(r),new Promise(e=>{t.addEventListener("loadeddata",n=>e(t)),t.load()})}async function jH(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(t=>{r.requestVideoFrameCallback(t)})}var Z_="3.20.0";function XH(r,t){let e=v(r,"a","add"),n=v(t,"b","add");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel(jn,o)}var J=N({add_:XH});function YH(r,t){let e=v(r,"a","floorDiv"),n=v(t,"b","floorDiv");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel(us,o)}var um=N({floorDiv_:YH});function ZH(r,t){let e=v(r,"a","div"),n=v(t,"b","div");if([e,n]=Xt(e,n),e.dtype==="int32"&&n.dtype==="int32")return um(e,n);let o={a:e,b:n},s={};return _.runKernel(ss,o,s)}var ct=N({div_:ZH});function JH(r,t){let e=v(r,"a","mul"),n=v(t,"b","mul");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel(Cs,o)}var O=N({mul_:JH});function QH(r){let t=v(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return _.runKernel(_l,e)}else{let e={x:t};return _.runKernel(pi,e)}}var $e=N({abs_:QH});function tq(r){let e={x:v(r,"x","acos")};return _.runKernel(oa,e)}var Cx=N({acos_:tq});function eq(r){let e={x:v(r,"x","acosh")};return _.runKernel(sa,e)}var vx=N({acosh_:eq});function rq(r){A(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),A(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((o,s)=>v(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!Rn(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return _.runKernel(jo,n)}var J_=N({addN_:rq});function nq(r,t=null,e=!1){let o={x:v(r,"x","all","bool")},s={axis:t,keepDims:e};return _.runKernel(ia,o,s)}var cm=N({all_:nq});function oq(r,t=null,e=!1){let o={x:v(r,"x","any","bool")},s={axis:t,keepDims:e};return _.runKernel(aa,o,s)}var Ju=N({any_:oq});function sq(r,t=0){let n={x:v(r,"x","argMax")},o={axis:t};return _.runKernel(Xo,n,o)}var Oi=N({argMax_:sq});function iq(r,t=0){let n={x:v(r,"x","argMin")},o={axis:t};return _.runKernel(Nl,n,o)}var Ix=N({argMin_:iq});function aq(r){let e={x:v(r,"x","asin")};return _.runKernel(la,e)}var Sx=N({asin_:aq});function lq(r){let e={x:v(r,"x","asinh")};return _.runKernel(ua,e)}var Tx=N({asinh_:lq});function uq(r){let e={x:v(r,"x","atan")};return _.runKernel(ca,e)}var Nx=N({atan_:uq});function cq(r,t){let e=v(r,"a","atan2"),n=v(t,"b","atan2");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel(ma,o)}var kx=N({atan2_:cq});function pq(r){let e={x:v(r,"x","atanh")};return _.runKernel(pa,e)}var _x=N({atanh_:pq});function mq(r,t,e,n,o="NHWC",s){let i=r[3],a=[...t,i],u=tE(o);return tc(r,a,e,s,n,null,null,u)}function aS(r,t,e,n,o,s,i="channelsLast"){let[a,u]=Ex(t),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return tc(r,l,e,n,o,s,!1,i)}function fq(r,t,e,n,o,s,i="NDHWC"){let[a,u,l]=iS(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,u,l,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return Q_(r,c,e,n,o,!1,p,s)}function tc(r,t,e,n,o,s,i=!1,a="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,p]=r;else if(a==="channelsFirst")[u,p,l,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,f,,d]=t,[h,g]=Ex(e),[x,b]=Ex(n),w=pm(m,x),C=pm(f,b),{padInfo:T,outHeight:E,outWidth:$}=gq(o,l,c,h,g,w,C,s,a),D=i?d*p:d,P;return a==="channelsFirst"?P=[u,D,E,$]:a==="channelsLast"&&(P=[u,E,$,D]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:p,outHeight:E,outWidth:$,outChannels:D,padInfo:T,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:C,dilationHeight:x,dilationWidth:b,inShape:r,outShape:P,filterShape:t}}function Q_(r,t,e,n,o,s=!1,i="channelsLast",a){let[u,l,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p,m]=r;else if(i==="channelsFirst")[u,m,l,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,d,h,,g]=t,[x,b,w]=iS(e),[C,T,E]=iS(n),$=pm(f,C),D=pm(d,T),P=pm(h,E),{padInfo:M,outDepth:W,outHeight:H,outWidth:q}=xq(o,l,c,p,x,b,w,$,D,P,a),X=s?g*m:g,j;return i==="channelsFirst"?j=[u,X,W,H,q]:i==="channelsLast"&&(j=[u,W,H,q,X]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:m,outDepth:W,outHeight:H,outWidth:q,outChannels:X,padInfo:M,strideDepth:x,strideHeight:b,strideWidth:w,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:$,effectiveFilterHeight:D,effectiveFilterWidth:P,dilationDepth:C,dilationHeight:T,dilationWidth:E,inShape:r,outShape:j,filterShape:t}}function dq(r,t,e,n,o){n==null&&(n=lS(r,t,e));let s=r[0],i=r[1],a=Qu((s-t+2*n)/e+1,o),u=Qu((i-t+2*n)/e+1,o);return[a,u]}function hq(r,t,e,n,o,s){o==null&&(o=lS(r,t,n));let i=r[0],a=r[1],u=r[2],l=Qu((i-t+2*o)/n+1,s),c=Qu((a-t+2*o)/n+1,s),p=Qu((u-t+2*o)/n+1,s);return[l,c,p,e]}function lS(r,t,e,n=1){let o=pm(t,n);return Math.floor((r[0]*(e-1)-e+o)/2)}function Ex(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function iS(r){return typeof r=="number"?[r,r,r]:r}function pm(r,t){return t<=1?r:r+(r-1)*(t-1)}function gq(r,t,e,n,o,s,i,a,u){let l,c,p;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=dq([t,e],s,n,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(t/n),p=Math.ceil(e/o);let m=Math.max(0,(c-1)*n+s-t),f=Math.max(0,(p-1)*o+i-e),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),x=f-g;l={top:d,bottom:h,left:g,right:x,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),p=Math.ceil((e-i+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],d=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=Qu((t-s+m+f)/n+1,a),p=Qu((e-i+d+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:c,outWidth:p}}function xq(r,t,e,n,o,s,i,a,u,l,c){let p,m,f,d;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=hq([t,e,n,1],a,1,o,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(t/o),f=Math.ceil(e/s),d=Math.ceil(n/i);let h=(m-1)*o+a-t,g=(f-1)*s+u-e,x=(d-1)*i+l-n,b=Math.floor(h/2),w=h-b,C=Math.floor(g/2),T=g-C,E=Math.floor(x/2),$=x-E;p={top:C,bottom:T,left:E,right:$,front:b,back:w,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((t-a+1)/o),f=Math.ceil((e-u+1)/s),d=Math.ceil((n-l+1)/i);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:d}}function Qu(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Jn(r){let[t,e,n]=Ex(r);return t===1&&e===1&&n===1}function Er(r,t){return Jn(r)||Jn(t)}function tE(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Te(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")A(na(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{A(na(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function yq(r,t){let n={x:v(r,"x","reshape","string_or_numeric")},o={shape:t};return _.runKernel(bi,n,o)}var F=N({reshape_:yq});function bq(r,t,e,n,o){let s=v(r,"x","avgPool","float32"),i=1;A(Er(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Te("avgPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(Yo,l,c);return p=tt(p,s.dtype),u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Xl=N({avgPool_:bq});function wq(r,t,e,n,o,s="NDHWC"){let i=v(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Te("avgPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(kl,l,c);return p=tt(p,a.dtype),u?F(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Ax=N({avgPool3d_:wq});function Cq(r,t=0){A(r.length>=1,()=>"Pass at least one tensor to concat");let e=ja(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return an(e[0]);let n=e,o={axis:t};return _.runKernel(fi,n,o)}var se=N({concat_:Cq});function vq(r){let e={x:v(r,"x","sigmoid","float32")};return _.runKernel(Os,e)}var Kr=N({sigmoid_:vq});function Iq(r,t,e){let n=v(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:e};return _.runKernel(Ci,o,s)}var Ot=N({slice_:Iq});function Sq(r){let e={x:v(r,"x","tanh","float32")};return _.runKernel(Gs,e)}var Pi=N({tanh_:Sq});function Tq(r,t,e,n,o,s){let i=v(r,"forgetBias","basicLSTMCell"),a=v(t,"lstmKernel","basicLSTMCell"),u=v(e,"lstmBias","basicLSTMCell"),l=v(n,"data","basicLSTMCell"),c=v(o,"c","basicLSTMCell"),p=v(s,"h","basicLSTMCell"),m=se([l,p],1),f=Gt(m,a),d=J(f,u),h=d.shape[0],g=d.shape[1]/4,x=[h,g],b=Ot(d,[0,0],x),w=Ot(d,[0,g],x),C=Ot(d,[0,g*2],x),T=Ot(d,[0,g*3],x),E=J(O(Kr(b),Pi(w)),O(c,Kr(J(i,C)))),$=O(Pi(E),Kr(T));return[E,$]}var eE=N({basicLSTMCell_:Tq});function Nq(r,t,e){let n=v(r,"x","batchToSpaceND"),o=t.reduce((a,u)=>a*u);A(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),A(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),A(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},i={blockShape:t,crops:e};return _.runKernel(mi,s,i)}var Yl=N({batchToSpaceND_:Nq});function rE(r){let t;return r.rank===0||r.rank===1?t=F(r,[1,1,1,r.size]):r.rank===2?t=F(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function kq(r,t,e,n,o,s){s==null&&(s=.001);let i=v(r,"x","batchNorm"),a=v(t,"mean","batchNorm"),u=v(e,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let c;n!=null&&(c=v(n,"offset","batchNorm")),A(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:rE(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:s},d=_.runKernel(cs,m,f);return F(d,i.shape)}var Li=N({batchNorm_:kq});function _q(r,t,e,n,o,s){let i=v(r,"x","batchNorm"),a=v(t,"mean","batchNorm"),u=v(e,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let c;return n!=null&&(c=v(n,"offset","batchNorm")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Li(i,a,u,c,l,s)}var $x=N({batchNorm2d_:_q});function Eq(r,t,e,n,o,s){let i=v(r,"x","batchNorm"),a=v(t,"mean","batchNorm"),u=v(e,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let c;return n!=null&&(c=v(n,"offset","batchNorm")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Li(i,a,u,c,l,s)}var Dx=N({batchNorm3d_:Eq});function Aq(r,t,e,n,o,s){let i=v(r,"x","batchNorm"),a=v(t,"mean","batchNorm"),u=v(e,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let c;return n!=null&&(c=v(n,"offset","batchNorm")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Li(i,a,u,c,l,s)}var Rx=N({batchNorm4d_:Aq});function $q(r,t,e){let n=v(r,"x","bincount"),o=v(t,"weights","bincount");A(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:e};return _.runKernel(Sp,s,i)}var Fx=N({bincount_:$q});function Dq(r,t){let e=v(r,"s0","broadcastArgs","int32"),n=v(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:e,s1:n};return _.runKernel(Tp,o)}var nE=N({broadcastArgs_:Dq});function Rq(r,t){let e=v(r,"broadcastTo","x"),n=e.shape;if(t.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let l=e.shape.slice();for(;l.length<t.length;)l.unshift(1);e=F(e,l)}let o=e.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(o[l]===t[l])s[l]=1;else if(e.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return an(e);let a={x:e},u={reps:s};return _.runKernel(Xn,a,u)}var Mi=N({broadcastTo_:Rq});function Fq(r){let e={x:v(r,"x","ceil","float32")};return _.runKernel(Jo,e)}var Ox=N({ceil_:Fq});function Oq(r,t,e){let n=v(r,"x","clipByValue");A(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let o={x:n},s={clipValueMin:t,clipValueMax:e};return _.runKernel(lo,o,s)}var Ir=N({clipByValue_:Oq});function Pq(r){return se(r,0)}var Px=N({concat1d_:Pq});function Lq(r,t){return se(r,t)}var Lx=N({concat2d_:Lq});function Mq(r,t){return se(r,t)}var Mx=N({concat3d_:Mq});function zq(r,t){return se(r,t)}var zx=N({concat4d_:zq});function Bq(r,t,e,n,o="NHWC",s=[1,1],i){let a=v(r,"x","conv2d","float32"),u=v(t,"filter","conv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Te("conv2d",n,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];A(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),A(Er(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=_.runKernel(Qo,m,f);return c?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Sn=N({conv2d_:Bq});function Vq(r,t,e,n,o="NWC",s=1,i){let a=v(r,"x","conv1d"),u=v(t,"filter","conv1d"),l=a,c=!1;a.rank===2&&(c=!0,l=F(a,[1,a.shape[0],a.shape[1]])),A(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),A(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Te("conv1d",n,i),A(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),A(Er(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),A(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=F(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=F(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Sn(m,p,[1,e],n,"NHWC",[1,s],i);return c?F(g,[g.shape[2],g.shape[3]]):F(g,[g.shape[0],g.shape[2],g.shape[3]])}var mm=N({conv1d_:Vq});function Gq(r,t,e,n,o,s="NHWC",i){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,u=t,l=!1;t.rank===3&&(l=!0,u=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,r[0],r[1],r[2]]),A(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),A(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),A(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?u.shape[3]:u.shape[1];A(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),A(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Te("conv2dDerInput",o,i);let m={dy:u,filter:e},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},d=_.runKernel(ts,m,f);return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var fm=N({conv2DBackpropInput_:Gq});function Wq(r,t,e,n,o,s){let i=v(r,"x","conv2dTranspose"),a=v(t,"filter","conv2dTranspose");return fm(e,i,a,n,o,"NHWC",s)}var dm=N({conv2dTranspose_:Wq});function Uq(r,t,e,n,o="NDHWC",s=[1,1,1]){let i=v(r,"x","conv3d"),a=v(t,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),A(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),A(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),A(Er(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:u,filter:a},p={strides:e,pad:n,dataFormat:o,dilations:s},m=_.runKernel(El,c,p);return l?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Bx=N({conv3d_:Uq});function Hq(r,t,e,n,o){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,i=t,a=!1;t.rank===4&&(a=!0,i=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),A(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),A(l===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:n,inputShape:s},m=_.runKernel(Ep,c,p);return a?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Vx=N({conv3DBackpropInput_:Hq});function qq(r,t,e,n,o){let s=v(r,"x","conv3dTranspose"),i=v(t,"filter","conv3dTranspose");return Vx(e,s,i,n,o)}var Gx=N({conv3dTranspose_:qq});function Kq(r){let e={x:v(r,"x","cos","float32")};return _.runKernel(es,e)}var Zl=N({cos_:Kq});function jq(r){let e={x:v(r,"x","cosh","float32")};return _.runKernel(rs,e)}var hm=N({cosh_:jq});function Xq(r,t=0,e=!1,n=!1){let s={x:v(r,"x","cumprod")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(fa,s,i)}var ec=N({cumprod_:Xq});function Yq(r,t=0,e=!1,n=!1){let s={x:v(r,"x","cumsum")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(ns,s,i)}var gm=N({cumsum_:Yq});function Zq(r,t,e,n=!1){let o=v(r,"x","denseBincount"),s=v(t,"weights","denseBincount");A(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),A(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:n};return _.runKernel(Ap,i,a)}var oE=N({denseBincount_:Zq});function Jq(r,t,e="NHWC"){let n=v(r,"x","depthToSpace","float32"),o=e==="NHWC"?n.shape[1]:n.shape[2],s=e==="NHWC"?n.shape[2]:n.shape[3],i=e==="NHWC"?n.shape[3]:n.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:t,dataFormat:e};return _.runKernel(ha,a,u)}var Wx=N({depthToSpace_:Jq});function Qq(r,t,e,n,o="NHWC",s=[1,1],i){let a=v(r,"x","depthwiseConv2d","float32"),u=v(t,"filter","depthwiseConv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let p=o==="NHWC"?l.shape[3]:l.shape[1];A(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),Te("depthwiseConv2d",n,i);let m={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=_.runKernel(os,m,f);return c?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var zi=N({depthwiseConv2d_:Qq});function tK(r){let e={x:v(r,"x","diag")};return _.runKernel(Rp,e)}var sE=N({diag_:tK});function eK(r,t,e,n,o=[1,1],s="NHWC"){let i=v(r,"x","dilation2d"),a=v(t,"filter","dilation2d");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),A(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);let c={x:u,filter:a},p={strides:e,pad:n,dilations:o},m=_.runKernel(Al,c,p);return l?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ux=N({dilation2d_:eK});function rK(r,t){let e=v(r,"a","equal","string_or_numeric"),n=v(t,"b","equal","string_or_numeric");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(xa,o)}var Ar=N({equal_:rK});function nK(r,t,e){let n=v(t,"a","where"),o=v(e,"b","where"),s=v(r,"condition","where","bool"),i=zt(zt(s.shape,n.shape),o.shape),a=Mi(s,i),u=Mi(n,i),l=Mi(o,i),c={condition:a,t:u,e:l};return _.runKernel(wi,c)}var De=N({where_:nK});function oK(r){let e={x:v(r,"x","zerosLike")};return _.runKernel(Ti,e)}var St=N({zerosLike_:oK});function sK(r,t){let e=v(r,"a","div"),n=v(t,"b","div");[e,n]=Xt(e,n);let o=ct(e,n),s=St(o),i=Ar(n,s);return De(i,s,o)}var Hx=N({divNoNan_:sK});function iK(r,t){let e=v(r,"t1","dot"),n=v(t,"t2","dot");A((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=n.rank===1?n.size:n.shape[0];if(A(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&n.rank===1){let i=F(e,[1,-1]),a=F(n,[-1,1]),u=Gt(i,a);return F(u,[])}else if(e.rank===1&&n.rank===2){let i=F(e,[1,-1]),a=F(n,[n.shape[0],n.shape[1]]),u=Gt(i,a);return F(u,[u.size])}else if(e.rank===2&&n.rank===1){let i=F(n,[-1,1]),a=Gt(e,i);return F(a,[a.size])}else{let i=F(n,[n.shape[0],n.shape[1]]);return Gt(e,i)}}var qx=N({dot_:iK});function aK(r,...t){let e=t.map((o,s)=>v(o,`tensors${s}`,"einsum")),n={equation:r};return _.runKernel(Fp,e,n)}var iE=N({einsum_:aK});function lK(r){let e={x:v(r,"x","elu","float32")};return _.runKernel(is,e)}var Bi=N({elu_:lK});function uK(r){let t=v(r,"x","erf");A(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=tt(t,"float32"));let e={x:t};return _.runKernel(ga,e)}var Kx=N({erf_:uK});function uS(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function aE(r,t,e){let n=r.length+t.length,o=[],s=0,i=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?o.push(r[s++]):o.push(t[i++]);return o}function cS(r,t){let e=[],n=r.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&e.push(r[s]);let o=t.map(s=>r[s]);return[e,o]}function xo(r,t){let e=t.map(n=>1);return aE(r,e,t)}function cK(r,t,e){A(uS(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function pS(r,t){if(uS(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function wh(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function pK(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function mK(r,t=null,e=!1){let o={x:v(r,"x","max")},s={reductionIndices:t,keepDims:e};return _.runKernel(ds,o,s)}var Mr=N({max_:mK});function fK(r,t=null,e=!1){let o={x:v(r,"x","min")},s={axis:t,keepDims:e};return _.runKernel(ys,o,s)}var rc=N({min_:fK});function dK(r,t){let e=v(r,"base","pow"),n=v(t,"exp","pow");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel(Ss,o)}var ln=N({pow_:dK});function mt(r,t){if((xr(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&xr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return sn(r,[],[],t)}function hK(r){let e={x:v(r,"x","sqrt","float32")};return _.runKernel(Ps,e)}var Ne=N({sqrt_:hK});function gK(r){let t=v(r,"x","square"),e={};return _.runKernel("Square",{x:t},e)}var Ht=N({square_:gK});function xK(r,t=null,e=!1){let n=v(r,"x","sum");n.dtype==="bool"&&(n=tt(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(Ls,o,s)}var ft=N({sum_:xK});function yK(r,t="euclidean",e=null,n=!1){r=v(r,"x","norm");let o=lE(r,t,e),s=o.shape;if(n){let i=ur(e,r.shape);s=xo(o.shape,i)}return F(o,s)}function lE(r,t,e=null){if(r.rank===0)return $e(r);if(r.rank!==1&&e===null)return lE(F(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return ft($e(r),e);if(t===1/0)return Mr($e(r),e);if(t===-1/0)return rc($e(r),e);if(t==="euclidean"||t===2)return Ne(ft(ln($e(r),mt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Mr(ft($e(r),e[0]),e[1]-1);if(t===1/0)return Mr(ft($e(r),e[1]),e[0]);if(t===-1/0)return rc(ft($e(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Ne(ft(Ht(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var Ja=N({norm_:yK});function bK(r,t=null,e=!1){return Ja(r,"euclidean",t,e)}var jx=N({euclideanNorm_:bK});function wK(r){let e={x:v(r,"x","exp")};return _.runKernel(as,e)}var or=N({exp_:wK});function CK(r,t=0){let e=v(r,"x","expandDims","string_or_numeric");A(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},o={dim:t};return _.runKernel(di,n,o)}var yr=N({expandDims_:CK});function vK(r){let e={x:v(r,"x","expm1")};return _.runKernel(ya,e)}var Xx=N({expm1_:vK});function IK(r,t){let e=v(r,"x","tile","string_or_numeric");A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},o={reps:t};return _.runKernel(Xn,n,o)}var $r=N({tile_:IK});function SK(r,t,e,n="float32"){t==null&&(t=r);let o=vt([r,t],n),s=r<=t?r:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=F(o.toTensor(),[r,t]);if(e==null)return i;if(e.length===1)return $r(yr(i,0),[e[0],1,1]);if(e.length===2)return $r(yr(yr(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return $r(yr(yr(yr(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var nc=N({eye_:SK});function Vi(r,t,e){let n={shape:r,value:t,dtype:e};return _.runKernel($l,{},n)}function TK(r){let e={x:v(r,"x","floor","float32")};return _.runKernel(ls,e)}var Gi=N({floor_:TK});function NK(r,t,e=0,n=0){let o=v(r,"x","gather"),s=v(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:n};return _.runKernel(hi,i,a)}var Wi=N({gather_:NK});function kK(r,t){let e=v(r,"a","greater","string_or_numeric"),n=v(t,"b","greater","string_or_numeric");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ca,o)}var Xe=N({greater_:kK});function _K(r,t){let e=v(r,"a","greaterEqual","string_or_numeric"),n=v(t,"b","greaterEqual","string_or_numeric");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ps,o)}var Pn=N({greaterEqual_:_K});function EK(r){let e={x:v(r,"x","isFinite")};return _.runKernel(va,e)}var Yx=N({isFinite_:EK});function AK(r){let e={x:v(r,"x","isInf")};return _.runKernel(Ia,e)}var Zx=N({isInf_:AK});function $K(r){let e={x:v(r,"x","isNaN")};return _.runKernel(Sa,e)}var Jx=N({isNaN_:$K});function DK(r,t=.2){let n={x:v(r,"x","leakyRelu")},o={alpha:t};return _.runKernel(ms,n,o)}var Jl=N({leakyRelu_:DK});function RK(r,t){let e=v(r,"a","less","string_or_numeric"),n=v(t,"b","less","string_or_numeric");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ta,o)}var xm=N({less_:RK});function FK(r,t){let e=v(r,"a","lessEqual","string_or_numeric"),n=v(t,"b","lessEqual","string_or_numeric");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Na,o)}var Ln=N({lessEqual_:FK});function uE(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:t,num:e};return _.runKernel(zp,{},n)}function OK(r,t=5,e=1,n=1,o=.5){let s=v(r,"x","localResponseNormalization");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),A(na(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:t,bias:e,alpha:n,beta:o},c=_.runKernel(Dl,u,l);return a?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Qx=N({localResponseNormalization_:OK});function PK(r){let e={x:v(r,"x","log","float32")};return _.runKernel(fs,e)}var Sr=N({log_:PK});function LK(r){let e={x:v(r,"x","log1p")};return _.runKernel(ka,e)}var Ql=N({log1p_:LK});function MK(r){return A(ui(r),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let n=v(t,"x","tf.grad","string_or_numeric"),o=e!=null?v(e,"dy","tf.grad"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(n),[n],o);return o!=null&&Fe(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ey(i),i[0]})}}function zK(r){return A(ui(r),()=>"The f passed in grads(f) must be a function"),(t,e)=>{A(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=ja(t,"args","tf.grads","string_or_numeric"),o=e!=null?v(e,"dy","tf.grads"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(...n),n,o);return o!=null&&Fe(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ey(i),i})}}function BK(r){return A(ui(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{A(t instanceof Lt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),A(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=_.gradients(()=>r(t),[t],e);return ey(n),{grad:n[0],value:o}}}function VK(r){return A(ui(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{A(Array.isArray(t)&&t.every(o=>o instanceof Lt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),A(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=_.gradients(()=>r(...t),t,e);return e!=null&&Fe(n.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ey(n.grads),n}}function ty(r,t){A(ui(r),()=>"The f passed in variableGrads(f) must be a function"),A(t==null||Array.isArray(t)&&t.every(l=>l instanceof Ka),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let l in _.registeredVariables)t.push(_.registeredVariables[l])}let n=e?t.filter(l=>!l.trainable):null,o=t.length;t=t.filter(l=>l.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=_.gradients(r,t,null,s);A(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),n!=null&&n.forEach(l=>u[l.name]=null),{value:i,grads:u}}function un(r){return _.customGrad(r)}function ey(r){if(r.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function GK(r){let e={x:v(r,"x","softplus")};return _.runKernel(Va,e)}var Hs=N({softplus_:GK});function WK(r){let t=v(r,"x","logSigmoid");return un(n=>({value:Yt(Hs(Yt(n))),gradFunc:i=>O(i,Kr(Yt(n)))}))(t)}var ry=N({logSigmoid_:WK});function UK(r,t){let e=v(r,"a","sub"),n=v(t,"b","sub");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel(Bs,o)}var ut=N({sub_:UK});function HK(r,t=-1){let e=v(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return un((o,s)=>{let a=Mr(o,t,!0),u=ut(o,a),l=ut(tt(u,"float32"),Sr(ft(or(u),t,!0)));return s([l]),{value:l,gradFunc:(p,m)=>{let[f]=m,d=!0,h=or(f);return ut(p,O(ft(p,t,d),h))}}})(e)}var ym=N({logSoftmax_:HK});function qK(r,t=null,e=!1){let n=v(r,"x","logSumExp"),o=ur(t,n.shape),s=Mr(n,o,!0),i=ut(n,s),a=or(i),u=ft(a,o),l=Sr(u),c=J(F(s,l.shape),l);if(e){let p=xo(c.shape,o);return F(c,p)}return c}var bm=N({logSumExp_:qK});function KK(r,t){let e=v(r,"a","logicalAnd","bool"),n=v(t,"b","logicalAnd","bool");zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(_a,o)}var Dr=N({logicalAnd_:KK});function jK(r){let e={x:v(r,"x","logicalNot","bool")};return _.runKernel(Ea,e)}var tu=N({logicalNot_:jK});function XK(r,t){let e=v(r,"a","logicalOr","bool"),n=v(t,"b","logicalOr","bool");zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Aa,o)}var wm=N({logicalOr_:XK});function YK(r,t){let e=v(r,"a","logicalXor","bool"),n=v(t,"b","logicalXor","bool");return zt(e.shape,n.shape),Dr(wm(r,t),tu(Dr(r,t)))}var ny=N({logicalXor_:YK});var oy=2147483648;function ZK(r,t,e="left"){let n=v(r,"sortedSequence","searchSorted"),o=v(t,"values","searchSorted"),s=n.shape[n.shape.length-1],i=o.shape[o.shape.length-1],a=F(n,[-1,s]),u=F(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Qt(u.shape)>=oy)throw new Error(`values tensor size must less than ${oy}`);if(a.shape[1]>=oy)throw new Error(`trailing dim_size must less than ${oy} for int32 output type, was ${a.shape[1]}`);let l={sortedSequence:a,values:u},c={side:e};return _.runKernel(Xp,l,c)}var Ch=N({searchSorted_:ZK});function cE(r,t){return Ch(r,t,"left")}function JK(r,t,e,n,o){let s=v(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),A(Er(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Te("maxPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(gs,l,c);return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var eu=N({maxPool_:JK});function QK(r,t=[1,1,1],e,n,o,s="NDHWC"){let i=v(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Te("maxPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(Rl,l,c);return u?F(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var sy=N({maxPool3d_:QK});function tj(r,t,e,n,o=!1){let i={x:v(r,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:n,includeBatchInIndex:o},u=_.runKernel(Wp,i,a);return{result:u[0],indexes:u[1]}}var pE=N({maxPoolWithArgmax_:tj});function ej(r,t){let e=v(r,"a","maximum"),n=v(t,"b","maximum");[e,n]=Xt(e,n),e.dtype==="bool"&&(e=tt(e,"int32"),n=tt(n,"int32")),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(hs,o)}var Tn=N({maximum_:ej});function rj(r,t=null,e=!1){let o={x:v(r,"x","mean")},s={axis:t,keepDims:e};return _.runKernel(xs,o,s)}var ke=N({mean_:rj});function _e(r,t="float32"){if(t==="complex64"){let n=_e(r,"float32"),o=_e(r,"float32");return Cn(n,o)}let e=Cp(Qt(r),t);return _.makeTensor(e,r,t)}function cr(r,t="float32"){if(t==="complex64"){let n=cr(r,"float32"),o=_e(r,"float32");return Cn(n,o)}let e=Qd(Qt(r),t);return _.makeTensor(e,r,t)}function mE(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=v(r,"x","meshgrid",r instanceof Lt?r.dtype:"float32");if(t===void 0)return[n];let o=v(t,"y","meshgrid",t instanceof Lt?t.dtype:"float32"),s=Qt(n.shape),i=Qt(o.shape);return e==="xy"?(n=F(n,[1,-1]),o=F(o,[-1,1]),[Gt(cr([i,1],n.dtype),n),Gt(o,cr([1,s],o.dtype))]):(n=F(n,[-1,1]),o=F(o,[1,-1]),[Gt(n,cr([1,i],n.dtype)),Gt(cr([s,1],o.dtype),o)])}function nj(r,t){let e=v(r,"a","minimum"),n=v(t,"b","minimum");[e,n]=Xt(e,n),e.dtype==="bool"&&(e=tt(e,"int32"),n=tt(n,"int32")),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(bs,o)}var Ui=N({minimum_:nj});function oj(r,t,e){A(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=v(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<n.rank;a++)A(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(t[a][0]>=0&&t[a][0]<=n.shape[a]-o&&t[a][1]>=0&&t[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:e},i={x:n};return _.runKernel(ws,i,s)}var iy=N({mirrorPad_:oj});function sj(r,t){let e=v(r,"a","mod"),n=v(t,"b","mod");[e,n]=Xt(e,n);let o={a:e,b:n};return _.runKernel($a,o)}var ay=N({mod_:sj});function ij(r,t=null,e=!1){r=v(r,"x","moments");let n=ur(t,r.shape),o=ke(r,n,e),s=o.shape;e||(s=xo(o.shape,n));let i=Ht(ut(tt(r,"float32"),F(o,s))),a=ke(i,n,e);return{mean:o,variance:a}}var oc=N({moments_:ij});function aj(r,t,e,n){let o=v(t,"data","multiRNNCell"),s=ja(e,"c","multiRNNCell"),i=ja(n,"h","multiRNNCell"),a=o,u=[];for(let p=0;p<r.length;p++){let m=r[p](a,s[p],i[p]);u.push(m[0]),u.push(m[1]),a=m[1]}let l=[],c=[];for(let p=0;p<u.length;p+=2)l.push(u[p]),c.push(u[p+1]);return[l,c]}var fE=N({multiRNNCell_:aj});function lj(r,t,e,n=!1){let o=v(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let u={logits:i===1?F(o,[1,-1]):o},l={numSamples:t,seed:e,normalized:n},c=_.runKernel(Up,u,l);return i===1?F(c,[c.size]):c}var dE=N({multinomial_:lj});function uj(r,t){let e=v(r,"a","notEqual","string_or_numeric"),n=v(t,"b","notEqual","string_or_numeric");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Da,o)}var qs=N({notEqual_:uj});function cj(r){let e={x:v(r,"x","onesLike")};return _.runKernel(xi,e)}var br=N({onesLike_:cj});function pj(r,t){let e=v(r,"v1","outerProduct"),n=v(t,"v2","outerProduct");A(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);let o=F(e,[-1,1]),s=F(n,[1,-1]);return Gt(o,s)}var hE=N({outerProduct_:pj});function mj(r,t,e=0){let n=v(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:n};return _.runKernel(Is,s,o)}var cn=N({pad_:mj});function fj(r,t,e=0){return A(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),cn(r,[t],e)}var gE=N({pad1d_:fj});function dj(r,t,e=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),cn(r,t,e)}var xE=N({pad2d_:dj});function hj(r,t,e=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),cn(r,t,e)}var yE=N({pad3d_:hj});function gj(r,t,e=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),cn(r,t,e)}var bE=N({pad4d_:gj});function xj(r,t,e){let n=v(r,"x","spaceToBatchND");A(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),A(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),A(n.shape.reduce((i,a,u)=>u>0&&u<=t.length?i&&(a+e[u-1][0]+e[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:e};return _.runKernel(vi,o,s)}var ru=N({spaceToBatchND_:xj});function yj(r,t,e,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=v(r,"x","maxPool"),u=a,l=!1;a.rank===3&&(l=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(Er(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=aS(u.shape,t,s,o,n),p=[c.dilationHeight,c.dilationWidth],m;n==="same"?m=wj([c.filterHeight,c.filterWidth],p):m=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[d,h]=bj([c.inHeight,c.inWidth],p,m),g=f?n:"valid",x=f?u:ru(u,p,d),w=(e==="avg"?()=>Xl(x,t,s,g,i):()=>eu(x,t,s,g,i))(),C=f?w:Yl(w,p,h);return l?F(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function bj(r,t,e){let n=e.map(c=>c[0]),o=e.map(c=>c[1]),s=r.concat(n,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),u=t.map((c,p)=>[n[p],a[p]]),l=t.map((c,p)=>[0,i[p]]);return[u,l]}function wj(r,t){let n=r.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var ly=N({pool_:yj});function Cj(r,t){let e=v(r,"x","prelu"),n=v(t,"alpha","prelu"),o={x:e,alpha:n};return _.runKernel(Ts,o)}var nu=N({prelu_:Cj});function vj(r,t=null,e=!1){let n=v(r,"x","prod");n.dtype==="bool"&&(n=tt(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(Ns,o,s)}var uy=N({prod_:vj});function Ij(r,t,e,n,o){let s=v(r,"shape","raggedTensorToTensor","int32"),i=v(t,"values","raggedTensorToTensor"),a=v(e,"defaultValue","raggedTensorToTensor",i.dtype),u=n.map((p,m)=>v(p,`tensors${m}`,"raggedTensorToTensor","int32")),l={shape:s,values:i,defaultValue:a,rowPartitionTensors:u},c={rowPartitionTypes:o};return _.runKernel(Hp,l,c)}var wE=N({raggedTensorToTensor_:Ij});function Sj(r,t,e){let n=Qt(r),o=null;if(e==null||e==="float32")o=new Float32Array(n);else if(e==="int32")o=new Int32Array(n);else if(e==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<n;s++)o[s]=t();return _.makeTensor(o,r,e)}var CE=N({rand_:Sj});var fy=Tl(vh());var ic=class{constructor(t,e,n,o,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=fy.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},py=class{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;let s=o||Math.random();this.randu=fy.alea(s.toString()),this.randn=new ic(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,t=o*o,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},my=class{constructor(t=0,e=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=fy.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function $j(r,t,e=1,n="float32",o){if(e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new py(t,e,n,o),i=vt(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var ME=N({randomGamma_:$j});function Dj(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new ic(t,e,n,!1,o),i=vt(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var ac=N({randomNormal_:Dj});function Rj(r,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return ac(r,0,1,t,e)}var zE=N({randomStandardNormal_:Rj});function Fj(r,t=0,e=1,n="float32",o){let s=vt(r,n),i=new my(t,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Hi=N({randomUniform_:Fj});function ou(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:t,step:e,dtype:n};return _.runKernel(Fl,{},o)}function Oj(r){let e={x:v(r,"x","reciprocal")};return _.runKernel(Pa,e)}var dy=N({reciprocal_:Oj});function Pj(r){let e={x:v(r,"x","relu")};return _.runKernel(ks,e)}var Rr=N({relu_:Pj});function Lj(r){let e={x:v(r,"x","relu6")};return _.runKernel(As,e)}var Cm=N({relu6_:Lj});function Mj(r,t){let n={x:v(r,"x","reverse")},o={dims:t};return _.runKernel($s,n,o)}var pr=N({reverse_:Mj});function zj(r){let t=v(r,"x","reverse");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),pr(t,0)}var BE=N({reverse1d_:zj});function Bj(r,t){let e=v(r,"x","reverse");return A(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),pr(e,t)}var VE=N({reverse2d_:Bj});function Vj(r,t){let e=v(r,"x","reverse");return A(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),pr(e,t)}var GE=N({reverse3d_:Vj});function Gj(r,t){let e=v(r,"x","reverse");return A(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),pr(e,t)}var WE=N({reverse4d_:Gj});function Wj(r){let e={x:v(r,"x","round")};return _.runKernel(Ds,e)}var vm=N({round_:Wj});function Uj(r){let e={x:v(r,"x","rsqrt","float32")};return _.runKernel(Rs,e)}var Im=N({rsqrt_:Uj});function Hj(r){let e={x:v(r,"x","selu")};return _.runKernel(Ma,e)}var Sm=N({selu_:Hj});function qj(r,t,e,n,o,s=[1,1],i="NHWC"){let a=v(r,"x","separableConv2d"),u=v(t,"depthwiseFilter","separableConv2d"),l=v(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),A(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let m=u.shape[2],f=u.shape[3];A(l.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${l.shape[2]}.`);let d=zi(c,u,n,o,i,s),g=Sn(d,l,1,"valid",i);return p?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Tm=N({separableConv2d_:qj});async function Kj(r,t){let e=v(r,"x","setdiff1d"),n=v(t,"y","setdiff1d");A(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),A(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),A(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await e.data(),s=await n.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let u=new fe([a],e.dtype),l=new fe([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]}var UE=Kj;function jj(r){let e={x:v(r,"x","sign")};return _.runKernel(Ba,e)}var hy=N({sign_:jj});function Xj(r){let e={x:v(r,"x","sin","float32")};return _.runKernel(Fs,e)}var Nm=N({sin_:Xj});function Yj(r){let e={x:v(r,"x","sinh")};return _.runKernel(za,e)}var km=N({sinh_:Yj});function Zj(r,t,e){let n=v(r,"x","slice1d");return A(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Ot(n,[t],[e])}var _m=N({slice1d_:Zj});function Jj(r,t,e){let n=v(r,"x","slice2d");return A(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Ot(n,t,e)}var Ih=N({slice2d_:Jj});function Qj(r,t,e){let n=v(r,"x","slice3d");return A(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Ot(n,t,e)}var Em=N({slice3d_:Qj});function t6(r,t,e){let n=v(r,"x","slice4d");return A(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Ot(n,t,e)}var lc=N({slice4d_:t6});function e6(r,t=-1){let e=v(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},o={dim:t};return _.runKernel(Ms,n,o)}var su=N({softmax_:e6});function r6(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Pp,t)}var iu=N({fft_:r6});function n6(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Lp,t)}var Qa=N({ifft_:n6});function o6(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let o=F(r,[e,t]);n=Qa(o)}else{let o=[e,2*(t-1)],s=F(Za(r),[e,t]),i=F(jl(r),[e,t]),a=pr(Ot(s,[0,1],[e,t-2]),1),u=O(pr(Ot(i,[0,1],[e,t-2]),1),mt(-1)),l=se([s,a],1),c=se([i,u],1),p=F(Cn(l,c),[o[0],o[1]]);n=Qa(p)}if(n=Za(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=F(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var Am=N({irfft_:o6});function s6(r,t,e=0){let o={x:v(r,"x","split")},s={numOrSizeSplits:t,axis:e};return _.runKernel(Ii,o,s)}var mr=N({split_:s6});function i6(r,t){A(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,o;if(t!=null&&t<e){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=t,o=Ot(r,d,h),e=t}else if(t!=null&&t>e){let d=r.shape.map(h=>h);d[r.shape.length-1]=t-e,o=se([r,_e(d)],r.shape.length-1),e=t}else o=r;let s=St(o),i=F(Cn(o,s),[n,e]),a=iu(i),u=Math.floor(e/2)+1,l=Za(a),c=jl(a),p=mr(l,[u,e-u],l.shape.length-1),m=mr(c,[u,e-u],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,F(Cn(p[0],m[0]),f)}var au=N({rfft_:i6});function a6(r,t){let e=v(r,"a","squaredDifference"),n=v(t,"b","squaredDifference");[e,n]=Xt(e,n),zt(e.shape,n.shape);let o={a:e,b:n},s={};return _.runKernel(zs,o,s)}var $m=N({squaredDifference_:a6});function l6(r,t){let e=v(r,"x","squeeze","string_or_numeric");return F(e,m0(e.shape,t).newShape)}var Mn=N({squeeze_:l6});function u6(r,t=0){let e=ja(r,"tensors","stack","string_or_numeric");A(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&A(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,o={axis:t};return _.runKernel(yi,n,o)}var sr=N({stack_:u6});function c6(r,t=0){let n={x:v(r,"x","step")},o={alpha:t};return _.runKernel(co,n,o)}var yo=N({step_:c6});function p6(r,t,e,n,o=0,s=0,i=0,a=0,u=0){let c={x:v(r,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return _.runKernel(Wa,c,p)}var gy=N({stridedSlice_:p6});function m6(r){let e={x:v(r,"x","tan","float32")};return _.runKernel(Vs,e)}var xy=N({tan_:m6});function Ve(r,t){Kn(r);let e=Pr(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return sn(r,null,e,t)}function Ks(r,t,e){if(Kn(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Pr(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return sn(r,t,n,e)}function HE(r,t,e){if(Kn(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Pr(r,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return sn(r,t,n,e)}function qE(r,t,e){if(Kn(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Pr(r,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return sn(r,t,n,e)}function KE(r,t,e){if(Kn(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Pr(r,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,sn(r,t,n,e)}function f6(r,t=1,e=!0){let n=v(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},i={k:t,sorted:e},[a,u]=_.runKernel(Ua,s,i);return{values:a,indices:u}}var yy=N({topk_:f6});function d6(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new ic(t,e,n,!0,o),i=vt(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Dm=N({truncatedNormal_:d6});function h6(r,t=0){let e=v(r,"x","unique","string_or_numeric");A(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},o={axis:t},[s,i]=_.runKernel(Zp,n,o);return{values:s,indices:i}}var by=N({unique_:h6});function g6(r,t,e){let n=v(r,"x","unsortedSegmentSum"),o=v(t,"segmentIds","unsortedSegmentSum","int32");A(na(e),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:e};return _.runKernel(Gl,s,i)}var Rm=N({unsortedSegmentSum_:g6});function x6(r,t=0){let e=v(r,"x","unstack","string_or_numeric");A(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},o={axis:t};return _.runKernel(Si,n,o)}var Tr=N({unstack_:x6});function jE(r,t){return Ch(r,t,"right")}function wy(r,t=!0,e,n){return _.makeVariable(r,t,e,n)}function Cy(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let n=vt(r,"int32"),o=vt([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let i=n.indexToLoc(e[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}async function y6(r){let t=v(r,"condition","whereAsync","bool"),e=await t.data(),n=Cy(t.shape,e);return r!==t&&t.dispose(),n}var vy=y6;async function b6(r,t,e){let n=v(r,"tensor","boolMask"),o=v(t,"mask","boolMask","bool"),s=e==null?0:e,i=o.rank,a=n.shape;A(i>0,()=>"mask cannot be scalar"),Fe(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+i;h++)u*=a[h];let l=a.slice(0,s).concat([u],a.slice(s+i)),c=F(n,l),p=F(o,[-1]),m=await vy(p),f=Mn(m,[1]),d=Wi(c,f,s);return r!==n&&n.dispose(),t!==o&&o.dispose(),f.dispose(),c.dispose(),p.dispose(),m.dispose(),d}var w6=b6;function C6(r,t,e,n,o=!0){let s=v(r,"v","movingAverage"),i=v(t,"x","movingAverage"),a=v(e,"decay","movingAverage");F0(s,i),A(Rn(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=mt(1),l=ut(u,a),c=O(ut(i,s),l);if(o){A(n!=null,()=>"When using zeroDebias: true, step is required.");let p=v(n,"step","movingAverage");c=ct(c,ut(u,ln(a,p)))}return J(s,c)}var v6=N({movingAverage_:C6});function I6(r,t,e){let n=v(r,"indices","scatterND","int32"),o=v(t,"updates","scatterND");bx(o,n,e);let s={indices:n,updates:o},i={shape:e};return _.runKernel(La,s,i)}var S6=N({scatterND_:I6});function XE(r,t,e,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function N6(r,t,e,n=0){let o=v(r,"sparseIndices","sparseToDense","int32"),s=v(t,"sparseValues","sparseToDense","string_or_numeric"),i=v(n,"defaultValue","sparseToDense",s.dtype);XE(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:e};return _.runKernel(Yp,a,u)}var k6=N({sparseToDense_:N6});function _6(r,t){let e=v(t,"indices","gatherND","int32"),o={params:v(r,"x","gatherND","string_or_numeric"),indices:e};return _.runKernel(wa,o)}var E6=N({gatherND_:_6});function YE(r,t){if(t==null)return r.shape.slice();if(Rn(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function A6(r,t,e,n){let o=v(r,"x","dropout");if(A(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof Lt?o.clone():o;let s=YE(o,e),i=1-t,a=ct(Gi(J(Hi(s,0,1,"float32",n),i)),i);return O(o,a)}var bS=N({dropout_:A6});function wS(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Sh(r,t,e){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let i=2*Math.PI*s/(r+n-1);o[s]=t-e*Math.cos(i)}return Ve(o,"float32")}async function $6(r,t,e=1){let n=v(r,"predictions","inTopK"),o=v(t,"targets","inTopK");A(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),A(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Fe(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];A(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=await n.data(),a=await o.data(),[u,l]=[i.length/s,s],c=f0("bool",u);for(let p=0;p<u;p++){let m=p*l,f=i.subarray(m,m+l),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),c[p]=0;for(let h=0;h<e;h++)if(d[h].index===a[p]){c[p]=1;break}}return r!==n&&n.dispose(),t!==o&&o.dispose(),vr(c,o.shape,"bool")}var D6=$6;var lu={};jt(lu,{conv2d:()=>ZE,depthwiseConv2d:()=>JE,matMul:()=>QE});function R6(r,t,e,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),A(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),A(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];A(l===e[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`),A(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),Te("conv2dDerFilter",o,i);let p={x:a,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return _.runKernel(kp,p,m)}var Fm=N({conv2DBackpropFilter_:R6});function uc(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return O(r,yo(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function cc(r,t){let e=t,n=ye(r.shape,t.shape);return n.length>0&&(e=ft(e,n)),F(e,r.shape)}function pc(r,t,e,n){if(t==="linear")return r;if(t==="relu")return Rr(r);if(t==="elu")return Bi(r);if(t==="relu6")return Cm(r);if(t==="prelu")return nu(r,e);if(t==="leakyrelu")return Jl(r,n);if(t==="sigmoid")return Kr(r);throw new Error(`Unknown fused activation ${t}.`)}var mc=(r,t)=>!(r>0)||t==="linear";function F6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",mc(_.state.gradientDepth,u)===!1){A(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=Sn(r,t,e,n,o,s,i);return a!=null&&(E=J(E,a)),pc(E,u,l,c)}let p=v(r,"x","conv2d","float32"),m=v(t,"filter","conv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=F(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Te("fused conv2d",n,i);let h=o==="NHWC"?f.shape[3]:f.shape[1];A(m.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${m.shape[2]}.`),A(Er(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let g=tc(f.shape,m.shape,e,s,n,i),x;a!=null&&(x=v(a,"bias","fused conv2d"),[x]=Xt(x,p),o==="NHWC"?zt(g.outShape,x.shape):(A(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),A(x.shape.length===0||x.shape[0]===g.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(l!=null){let E=l.shape;if(A(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)A(E[0]===1||E[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${g.outChannels}).`);else if(E.length===3)try{zt(E,g.outShape)}catch($){let D=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(D)}b=v(l,"prelu weights","fused conv2d")}let w=(E,$)=>{A(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[D,P,M,W]=$,H=uc(E,M,u);A(Jn(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let q=fm(P.shape,H,D,e,n),X=Fm(P,H,D.shape,e,n),j=[q,X];if(W!=null){let Z=cc(W,H);j.push(Z)}return j},C={x:f,filter:m,bias:x,preluActivationWeights:b},T={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?un(($,D,P)=>{let M=_.runKernel(ki,C,T);return P([D,$,M]),d&&(M=F(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:w}})(f,m):un(($,D,P,M)=>{let W=_.runKernel(ki,C,T);return M([D,$,W,P]),d&&(W=F(W,[W.shape[1],W.shape[2],W.shape[3]])),{value:W,gradFunc:w}})(f,m,x)}var ZE=N({fusedConv2d_:F6});function O6(r,t,e,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:a,dy:u},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return _.runKernel($p,l,c)}var Iy=N({depthwiseConv2dNativeBackpropFilter_:O6});function P6(r,t,e,n,o,s=[1,1],i){let a=t,u=!1;t.rank===3&&(u=!0,a=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:a,filter:e},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},p=_.runKernel(Dp,l,c);return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Sy=N({depthwiseConv2dNativeBackpropInput_:P6});function L6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(mc(_.state.gradientDepth,u)===!1){let T=zi(r,t,e,n,o,s,i);return a!=null&&(T=J(T,a)),pc(T,u,l,c)}let p=v(r,"x","depthwiseConv2d","float32"),m=v(t,"filter","depthwiseConv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=F(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),A(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),A(Er(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),Te("fused depthwiseConv2d",n,i);let h=tc(f.shape,m.shape,e,s,n,i,!0),g;a!=null&&(g=v(a,"bias","fused conv2d"),[g]=Xt(g,p),zt(h.outShape,g.shape));let x;l!=null&&(x=v(l,"prelu weights","fused depthwiseConv2d"));let b=(T,E)=>{A(Jn(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[$,D,P,M]=E,W=uc(T,P,u),H=Sy(D.shape,W,$,e,n,s,i),q=Iy(D,W,$.shape,e,n,s,i);if(M!=null){let X=cc(g,W);return[H,q,X]}return[H,q]},w={x:f,filter:m,bias:g,preluActivationWeights:x},C={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?un((E,$,D)=>{let P=_.runKernel(_i,w,C);return D([$,E,P]),d&&(P=F(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m):un((E,$,D,P)=>{let M=_.runKernel(_i,w,C);return P([$,E,M,D]),d&&(M=F(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(f,m,g)}var JE=N({fusedDepthwiseConv2d_:L6});function M6({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(mc(_.state.gradientDepth,s)===!1){let W=Gt(r,t,e,n);return o!=null&&(W=J(W,o)),pc(W,s,i,a)}let u=v(r,"a","fused matMul"),l=v(t,"b","fused matMul");[u,l]=Xt(u,l);let c=e?u.shape[u.rank-2]:u.shape[u.rank-1],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=e?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=Qt(d),x=Qt(h);A(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${e} and transposeB=${n} must match.`);let w=zt(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([m,f]),C=e?F(u,[g,c,m]):F(u,[g,m,c]),T=n?F(l,[x,f,p]):F(l,[x,p,f]),E;o!=null&&(E=v(o,"bias","fused matMul"),[E]=Xt(E,u),zt(w,E.shape));let $;i!=null&&($=v(i,"prelu weights","fused matMul"));let D=(W,H)=>{let[q,X,j,Z]=H,et=uc(F(W,j.shape),j,s),K,ot;if(!e&&!n?(K=Gt(et,X,!1,!0),ot=Gt(q,et,!0,!1)):!e&&n?(K=Gt(et,X,!1,!1),ot=Gt(et,q,!0,!1)):e&&!n?(K=Gt(X,et,!1,!0),ot=Gt(q,et,!1,!1)):(K=Gt(X,et,!0,!0),ot=Gt(et,q,!0,!0)),o!=null){let st=cc(Z,et);return[K,ot,st]}else return[K,ot]},P={a:C,b:T,bias:E,preluActivationWeights:$},M={transposeA:e,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?un((H,q,X)=>{let j=_.runKernel(Ni,P,M);return X([H,q,j]),{value:F(j,w),gradFunc:D}})(C,T):un((H,q,X,j)=>{let Z=_.runKernel(Ni,P,M);return j([H,q,Z,X]),{value:F(Z,w),gradFunc:D}})(C,T,E)}var QE=N({fusedMatMul_:M6});function z6(r){return Sh(r,.54,.46)}var tA=N({hammingWindow_:z6});function B6(r){return Sh(r,.5,.5)}var Ty=N({hannWindow_:B6});function V6(r,t,e,n=!1,o=0){let s=0,i=[];for(;s+t<=r.size;)i.push(Ot(r,s,t)),s+=e;if(n)for(;s<r.size;){let a=s+t-r.size,u=se([Ot(r,s,t-a),Vi([a],o)]);i.push(u),s+=e}return i.length===0?Ks([],[0,t]):F(se(i),[i.length,t])}var Ny=N({frame_:V6});function G6(r,t,e,n,o=Ty){n==null&&(n=wS(t));let s=Ny(r,t,e),i=O(s,o(t));return au(i,n)}var eA=N({stft_:G6});function W6(r,t,e,n,o="bilinear",s=0){let i=v(r,"image","cropAndResize"),a=v(t,"boxes","cropAndResize","float32"),u=v(e,"boxInd","cropAndResize","int32"),l=a.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),A(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),A(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),A(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),A(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:u},p={method:o,extrapolationValue:s,cropSize:n};return _.runKernel(da,c,p)}var rA=N({cropAndResize_:W6});function U6(r){let t=v(r,"image","flipLeftRight","float32");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return _.runKernel(ba,e,{})}var nA=N({flipLeftRight_:U6});function H6(r){let t=v(r,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,$r(t,o)}var oA=N({grayscaleToRGB_:H6});function q6(r,t,e=0,n=.5){let o=v(r,"image","rotateWithOffset","float32");A(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:e,center:n};return _.runKernel(qa,s,i)}var sA=N({rotateWithOffset_:q6});function bo(r,t,e,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return e=Math.min(e,i),A(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),A(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),A(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),A(t.rank===1,()=>"scores must be a 1D tensor"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function K6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppression","float32"),i=v(t,"scores","nonMaxSuppression","float32"),a=bo(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:e,iouThreshold:n,scoreThreshold:o};return _.runKernel(Ra,{boxes:s,scores:i},u)}var iA=N({nonMaxSuppression_:K6});function aA(r,t,e){let n=j6(r,t,e),o=n<0?-(n+1):n;r.splice(o,0,t)}function j6(r,t,e){return Y6(r,t,e||X6)}function X6(r,t){return r>t?1:r<t?-1:0}function Y6(r,t,e){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=e(t,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function ky(r,t,e,n,o){return CS(r,t,e,n,o,0)}function _y(r,t,e,n,o,s){return CS(r,t,e,n,o,0,!1,s,!0)}function Ey(r,t,e,n,o,s){return CS(r,t,e,n,o,s,!0)}function CS(r,t,e,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<t.length;g++)t[g]>o&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(lA);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<e&&l.length>0;){let g=l.pop(),{score:x,boxIndex:b,suppressBeginIndex:w}=g;if(x<o)break;let C=!1;for(let T=p.length-1;T>=w;--T){let E=Z6(r,b,p[T]);if(E>=n){C=!0;break}if(g.score=g.score*J6(n,c,E),g.score<=o)break}g.suppressBeginIndex=p.length,C||(g.score===x?(p.push(b),m.push(g.score)):g.score>o&&aA(l,g,lA))}let f=p.length,d=e-f;a&&d>0&&(p.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=m),u&&(h.validOutputs=f),h}function Z6(r,t,e){let n=r.subarray(t*4,t*4+4),o=r.subarray(e*4,e*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(a-s)*(u-i),d=(p-l)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,l),g=Math.max(i,c),x=Math.min(a,p),b=Math.min(u,m),w=Math.max(x-h,0)*Math.max(b-g,0);return w/(f+d-w)}function J6(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function lA(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}async function Q6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppressionAsync"),i=v(t,"scores","nonMaxSuppressionAsync"),a=bo(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:p}=ky(l,c,e,n,o);return s!==r&&s.dispose(),i!==t&&i.dispose(),Ve(p,"int32")}var uA=Q6;function t5(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=v(r,"boxes","nonMaxSuppression"),a=v(t,"scores","nonMaxSuppression"),u=bo(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=_.runKernel(Oa,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}var cA=N({nonMaxSuppressionWithScore_:t5});async function e5(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=v(r,"boxes","nonMaxSuppressionAsync"),a=v(t,"scores","nonMaxSuppressionAsync"),u=bo(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),c=l[0],p=l[1],{selectedIndices:m,selectedScores:f}=Ey(c,p,e,n,o,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Ve(m,"int32"),selectedScores:Ve(f)}}var pA=e5;function r5(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=v(r,"boxes","nonMaxSuppression"),a=v(t,"scores","nonMaxSuppression"),u=bo(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,m={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=_.runKernel(Fa,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var mA=N({nonMaxSuppressionPadded_:r5});async function n5(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=v(r,"boxes","nonMaxSuppressionAsync"),a=v(t,"scores","nonMaxSuppressionAsync"),u=bo(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,[m,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:d,validOutputs:h}=_y(m,f,l,c,p,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Ve(d,"int32"),validOutputs:mt(h,"int32")}}var fA=n5;function o5(r,t,e=!1,n=!1){let o=v(r,"images","resizeBilinear");A(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel(Es,a,u);return i?F(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var Ay=N({resizeBilinear_:o5});function s5(r,t,e=!1,n=!1){let o=v(r,"images","resizeNearestNeighbor");A(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel(_s,a,u);return i?F(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var $y=N({resizeNearestNeighbor_:s5});function i5(r,t="binary",e=!1,n=.5){let o=v(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=O(Ve([n]),255),c,p,m,f;if(A(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),A(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),A(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),A(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,m]=mr(o,[1,1,1],-1);let g=O(c,s),x=O(p,i),b=O(m,a);f=J(J(g,x),b)}else f=r;if(t==="otsu"){let g=Fx(tt(vm(f),"int32"),vr([]),256);l=a5(g,u)}let d=e?Ln(f,l):Xe(f,l);return tt(O(d,255),"int32")}function a5(r,t){let e=Ve([-1]),n=Ve([0]),o=Ve([0]),s,i,a,u,l,c;for(let p=0;p<r.size-1;p++){s=Ot(r,0,p+1),i=Ot(r,p+1),l=ct(ft(s),t),c=ct(ft(i),t);let m=ft(O(s,ou(0,s.size)));a=ct(m,ft(s));let f=Vi(i.shape,s.size),d=J(ou(0,i.size),f),h=O(i,d);u=ct(ft(h),ft(i));let g=ut(a,u),x=ut(a,u),b=O(l,c);o=O(O(b,g),x);let w=Xe(o,n);n=De(w,o,n),e=De(w,Ve([p]),e)}return e}var dA=N({threshold_:i5});function l5(r,t,e="nearest",n="constant",o=0,s){let i=v(r,"image","transform","float32"),a=v(t,"transforms","transform","float32");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:e,fillMode:n,fillValue:o,outputShape:s};return _.runKernel(Ha,u,l)}var hA=N({transform_:l5});function u5(r,t,e){A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let n=v(r,"a","bandPart");A(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),e<0&&(e=i);let a=F(ou(0,s,1,"int32"),[-1,1]),u=ou(0,i,1,"int32"),l=ut(a,u),c=Dr(Ln(l,mt(+t,"int32")),Pn(l,mt(-e,"int32"))),p=_e([s,i],n.dtype);return F(sr(Tr(F(n,[-1,s,i])).map(m=>De(c,m,p))),o)}var gA=N({bandPart_:u5});function c5(r){let t;if(Array.isArray(r)){t=!1,A(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)A(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else t=!0,r=mr(r,r.shape[0],0).map(o=>Mn(o,[0]));A(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let o=0;o<r.length;++o)e.push(_.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=O(ft(O(e[i],s)),e[i]);s=ut(s,a)}return ct(s,Ja(s,"euclidean"))}));return t?sr(e,0):e}var xA=N({gramSchmidt_:c5});function p5(r,t=!1){if(A(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return yA(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=Tr(F(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,c]=yA(u,t);o.push(l),s.push(c)});let i=F(sr(o,0),r.shape),a=F(sr(s,0),r.shape);return[i,a]}}function yA(r,t=!1){return _.tidy(()=>{A(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],o=nc(e),s=an(r),i=Ks([[1]],[1,1]),a=an(i),u=e>=n?n:e;for(let l=0;l<u;++l){let c=s,p=a,m=o;[a,s,o]=_.tidy(()=>{let f=Ot(s,[l,l],[e-l,1]),d=Ja(f),h=Ot(s,[l,l],[1,1]),g=De(Xe(h,0),Ks([[-1]]),Ks([[1]])),x=ut(h,O(g,d)),b=ct(f,x);b.shape[0]===1?a=an(i):a=se([i,Ot(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let w=Yt(ct(Gt(g,x),d)),C=Ot(s,[l,0],[e-l,n]),T=O(w,a),E=Mt(a);if(l===0)s=ut(C,Gt(T,Gt(E,C)));else{let P=ut(C,Gt(T,Gt(E,C)));s=se([Ot(s,[0,0],[l,n]),P],0)}let $=Mt(T),D=Ot(o,[0,l],[e,o.shape[1]-l]);if(l===0)o=ut(D,Gt(Gt(D,a),$));else{let P=ut(D,Gt(Gt(D,a),$));o=se([Ot(o,[0,0],[e,l]),P],1)}return[a,s,o]}),_t([c,p,m])}return!t&&e>n&&(o=Ot(o,[0,0],[e,n]),s=Ot(s,[0,0],[n,n])),[o,s]})}var bA=N({qr_:p5});var Ye;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ye||(Ye={}));function m5(r,t,e=Ye.SUM_BY_NONZERO_WEIGHTS){let n=v(r,"losses","computeWeightedLoss"),o=null;t!=null&&(o=v(t,"weights","computeWeightedLoss"));let s=o==null?n:O(n,o);if(e===Ye.NONE)return s;if(e===Ye.SUM)return ft(s);if(e===Ye.MEAN){if(o==null)return ke(s);{let i=n.size/o.size,a=ct(ft(s),ft(o));return i>1?ct(a,mt(i)):a}}if(e===Ye.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ct(ft(s),mt(n.size));{let i=O(o,cr(n.shape)),a=tt(ft(qs(i,mt(0))),"float32");return ct(ft(s),a)}}throw Error(`Unknown reduction: ${e}`)}var zr=N({computeWeightedLoss_:m5});function f5(r,t,e,n=Ye.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"labels","absoluteDifference"),s=v(t,"predictions","absoluteDifference"),i=null;e!=null&&(i=v(e,"weights","absoluteDifference")),Fe(o.shape,s.shape,"Error in absoluteDifference: ");let a=$e(ut(o,s));return zr(a,i,n)}var wA=N({absoluteDifference_:f5});function d5(r,t,e,n,o=Ye.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","cosineDistance"),i=v(t,"predictions","cosineDistance"),a=null;n!=null&&(a=v(n,"weights","cosineDistance")),Fe(s.shape,i.shape,"Error in cosineDistance: ");let u=mt(1),l=ut(u,ft(O(s,i),e,!0));return zr(l,a,o)}var CA=N({cosineDistance_:d5});function h5(r,t,e,n=Ye.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"labels","hingeLoss"),s=v(t,"predictions","hingeLoss"),i=null;e!=null&&(i=v(e,"weights","hingeLoss")),Fe(o.shape,s.shape,"Error in hingeLoss: ");let a=mt(1);o=ut(O(mt(2),o),a);let u=Rr(ut(a,O(o,s)));return zr(u,i,n)}var vA=N({hingeLoss_:h5});function g5(r,t,e,n=1,o=Ye.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","huberLoss"),i=v(t,"predictions","huberLoss"),a=null;e!=null&&(a=v(e,"weights","huberLoss")),Fe(s.shape,i.shape,"Error in huberLoss: ");let u=mt(n),l=$e(ut(i,s)),c=Ui(l,u),p=ut(l,c),m=J(O(mt(.5),Ht(c)),O(u,p));return zr(m,a,o)}var IA=N({huberLoss_:g5});function x5(r,t,e,n=1e-7,o=Ye.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","logLoss"),i=v(t,"predictions","logLoss"),a=null;e!=null&&(a=v(e,"weights","logLoss")),Fe(s.shape,i.shape,"Error in logLoss: ");let u=mt(1),l=mt(n),c=Yt(O(s,Sr(J(i,l)))),p=O(ut(u,s),Sr(J(ut(u,i),l))),m=ut(c,p);return zr(m,a,o)}var SA=N({logLoss_:x5});function y5(r,t,e,n=Ye.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"labels","meanSquaredError"),s=v(t,"predictions","meanSquaredError"),i=null;e!=null&&(i=v(e,"weights","meanSquaredError")),Fe(o.shape,s.shape,"Error in meanSquaredError: ");let a=$m(o,s);return zr(a,i,n)}var TA=N({meanSquaredError_:y5});function b5(r,t){let e=v(r,"labels","sigmoidCrossEntropyWithLogits"),n=v(t,"logits","sigmoidCrossEntropyWithLogits");Fe(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Rr(n),s=O(n,e),i=Ql(or(Yt($e(n))));return J(ut(o,s),i)}function w5(r,t,e,n=0,o=Ye.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"multiClassLabels","sigmoidCrossEntropy"),i=v(t,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=v(e,"weights","sigmoidCrossEntropy")),Fe(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=mt(n),c=mt(1),p=mt(.5);s=J(O(s,ut(c,l)),O(p,l))}let u=b5(s,i);return zr(u,a,o)}var NA=N({sigmoidCrossEntropy_:w5});function C5(r,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return un((o,s,i)=>{let u=bm(s,[e],!0),l=ut(tt(s,"float32"),u);i([o,l]);let c=Yt(O(l,o));return{value:ft(c,[e]),gradFunc:(f,d)=>{let[h,g]=d,x=xo(f.shape,[e]);return[O(F(f,x),ut(tt(h,"float32"),or(g))),O(F(f,x),ut(or(g),tt(h,"float32")))]}}})(r,t)}function v5(r,t,e,n=0,o=Ye.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"onehotLabels","softmaxCrossEntropy"),i=v(t,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=v(e,"weights","softmaxCrossEntropy")),Fe(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let l=mt(n),c=mt(1),p=mt(s.shape[1]);s=J(O(s,ut(c,l)),ct(l,p))}let u=C5(s,i);return zr(u,a,o)}var kA=N({softmaxCrossEntropy_:v5});function I5(r,t,e,n){let o=v(r,"indices","sparseFillEmptyRows","int32"),s=v(t,"values","sparseFillEmptyRows"),i=v(e,"denseShape","sparseFillEmptyRows","int32"),a=v(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=_.runKernel(Ol,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var _A=N({sparseFillEmptyRows_:I5});function S5(r,t,e){let n=v(r,"inputIndices","sparseReshape","int32"),o=v(t,"inputShape","sparseReshape","int32"),s=v(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=_.runKernel(Ga,i);return{outputIndices:a[0],outputShape:a[1]}}var EA=N({sparseReshape_:S5});function T5(r,t,e){let n=v(r,"data","sparseSegmentMean"),o=v(t,"indices","sparseSegmentMean","int32"),s=v(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Pl,i)}var AA=N({sparseSegmentMean_:T5});function N5(r,t,e){let n=v(r,"data","sparseSegmentSum"),o=v(t,"indices","sparseSegmentSum","int32"),s=v(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Ll,i)}var $A=N({sparseSegmentSum_:N5});function k5(r,t,e,n,o,s,i,a){let u=v(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=v(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:u,dataSplits:l},m=_.runKernel(zl,p,c);return{nGrams:m[0],nGramsSplits:m[1]}}var DA=N({stringNGrams_:k5});function _5(r,t,e=!0){let n=v(r,"input","stringSplit","string"),o=v(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:n,delimiter:o},a=_.runKernel(Bl,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var RA=N({stringSplit_:_5});function E5(r,t){let e=v(r,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return _.runKernel(Vl,o,n)}var FA=N({stringToHashBucketFast_:E5});var A5={fft:iu,ifft:Qa,rfft:au,irfft:Am},$5={hammingWindow:tA,hannWindow:Ty,frame:Ny,stft:eA},uu={flipLeftRight:nA,grayscaleToRGB:oA,resizeNearestNeighbor:$y,resizeBilinear:Ay,rotateWithOffset:sA,cropAndResize:rA,nonMaxSuppression:iA,nonMaxSuppressionAsync:uA,nonMaxSuppressionWithScore:cA,nonMaxSuppressionWithScoreAsync:pA,nonMaxSuppressionPadded:mA,nonMaxSuppressionPaddedAsync:fA,threshold:dA,transform:hA},vS={bandPart:gA,gramSchmidt:xA,qr:bA},D5={absoluteDifference:wA,computeWeightedLoss:zr,cosineDistance:CA,hingeLoss:vA,huberLoss:IA,logLoss:SA,meanSquaredError:TA,sigmoidCrossEntropy:NA,softmaxCrossEntropy:kA},R5={sparseFillEmptyRows:_A,sparseReshape:EA,sparseSegmentMean:AA,sparseSegmentSum:$A},F5={stringNGrams:DA,stringSplit:RA,stringToHashBucketFast:FA};var Br=class extends bh{minimize(t,e=!1,n){let{value:o,grads:s}=this.computeGradients(t,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return _t(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return ty(t,e)}dispose(){this.iterations_!=null&&_t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:mt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(Br,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var cu=class extends Br{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:G(()=>St(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:G(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;G(()=>{let c=J(O(u,this.rho),O(Ht(a),1-this.rho)),p=O(ct(Ne(J(l,this.epsilon)),Ne(J(u,this.epsilon))),a),m=J(O(l,this.rho),O(Ht(p),1-this.rho));u.assign(c),l.assign(m);let f=J(O(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_t(this.accumulatedGrads.map(t=>t.variable)),_t(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};cu.className="Adadelta";In(cu);var pu=class extends Br{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:G(()=>Vi(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;G(()=>{let u=J(a,Ht(i));a.assign(u);let l=J(O(ct(i,Ne(J(u,_.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_t(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};pu.className="Adagrad";In(pu);var mu=class extends Br{constructor(t,e,n,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],G(()=>{this.accBeta1=mt(e).variable(),this.accBeta2=mt(n).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);G(()=>{let n=ut(1,this.accBeta1),o=ut(1,this.accBeta2);e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:G(()=>St(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:G(()=>St(a).variable(u))});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,m=J(O(c,this.beta1),O(l,1-this.beta1)),f=J(O(p,this.beta2),O(Ht(l),1-this.beta2)),d=ct(m,n),h=ct(f,o);c.assign(m),p.assign(f);let g=J(O(ct(d,J(Ne(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(O(this.accBeta1,this.beta1)),this.accBeta2.assign(O(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&_t(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),G(()=>{this.accBeta1.assign(ln(this.beta1,this.iterations_+1)),this.accBeta2.assign(ln(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};mu.className="Adam";In(mu);var fu=class extends Br{constructor(t,e,n,o=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],G(()=>{this.iteration=mt(0).variable(),this.accBeta1=mt(e).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);G(()=>{let n=ut(1,this.accBeta1),o=ct(-this.learningRate,J(O(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:St(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:St(a).variable(u)});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,m=J(O(c,this.beta1),O(l,1-this.beta1)),f=O(p,this.beta2),d=$e(l),h=Tn(f,d);c.assign(m),p.assign(h);let g=J(O(ct(o,n),ct(m,J(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(J(this.iteration,1)),this.accBeta1.assign(O(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&_t(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};fu.className="Adamax";In(fu);var qi=class extends Br{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=Array.isArray(t)?t[o].tensor:t[n];if(s==null)return;let i=_.registeredVariables[n];G(()=>{let a=J(O(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Oe(mt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};qi.className="SGD";In(qi);var du=class extends qi{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=mt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${n}/momentum`,variable:G(()=>St(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[n];a!=null&&G(()=>{let u,l=J(O(this.m,i),a);this.useNesterov?u=J(O(this.c,J(a,O(l,this.m))),s):u=J(O(this.c,l),s),i.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_t(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};du.className="Momentum";In(du);var hu=class extends Br{constructor(t,e=.9,n=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=_.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:G(()=>St(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:G(()=>St(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:G(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;G(()=>{let c=J(O(u,this.decay),O(Ht(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,m=J(O(p,this.decay),O(a,1-this.decay)),f=ct(O(a,this.learningRate),Ne(ut(c,J(Ht(m),this.epsilon)))),d=J(O(l,this.momentum),f);u.assign(c),p.assign(m),l.assign(d);let h=ut(s,d);s.assign(h)}else{let p=J(O(u,this.decay),O(Ht(a),1-this.decay)),m=J(O(l,this.momentum),ct(O(a,this.learningRate),Ne(J(p,this.epsilon))));u.assign(p),l.assign(m);let f=ut(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_t(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_t(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&_t(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};hu.className="RMSProp";In(hu);var js=class{static sgd(t){return new qi(t)}static momentum(t,e,n=!1){return new du(t,e,n)}static rmsprop(t,e=.9,n=0,o=null,s=!1){return new hu(t,e,n,o,s)}static adam(t=.001,e=.9,n=.999,o=null){return new mu(t,e,n,o)}static adadelta(t=.001,e=.95,n=null){return new cu(t,e,n)}static adamax(t=.002,e=.9,n=.999,o=null,s=0){return new fu(t,e,n,o,s)}static adagrad(t,e=.1){return new pu(t,e)}};var fc={sgd:js.sgd,momentum:js.momentum,adadelta:js.adadelta,adagrad:js.adagrad,rmsprop:js.rmsprop,adamax:js.adamax,adam:js.adam};var O5=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function Th(){return new Promise(r=>O5(()=>r()))}var S={};jt(S,{ERF_A1:()=>Y5,ERF_A2:()=>Z5,ERF_A3:()=>J5,ERF_A4:()=>Q5,ERF_A5:()=>tX,ERF_P:()=>X5,PARALLELIZE_THRESHOLD:()=>Dy,RowPartitionType:()=>Ki,SELU_SCALE:()=>SS,SELU_SCALEALPHA:()=>IS,applyActivation:()=>pc,assertAndGetBroadcastShape:()=>zt,assertAxesAreInnerMostDims:()=>cK,assertParamsConsistent:()=>P5,assignToTypedArray:()=>iX,axesAreInnerMostDims:()=>uS,calculateShapes:()=>L_,checkEinsumDimSizes:()=>mX,checkPadOnDimRoundingMode:()=>Te,combineLocations:()=>aE,combineRaggedTensorToTensorShapes:()=>M5,complexWithEvenIndex:()=>nX,complexWithOddIndex:()=>oX,computeConv2DInfo:()=>tc,computeConv3DInfo:()=>Q_,computeDefaultPad:()=>lS,computeDilation2DInfo:()=>mq,computeOptimalWindowSize:()=>G5,computeOutAndReduceShapes:()=>cS,computeOutShape:()=>L5,computePool2DInfo:()=>aS,computePool3DInfo:()=>fq,convertConv2DDataFormat:()=>tE,decodeEinsumEquation:()=>cX,eitherStridesOrDilationsAreOne:()=>Er,expandShapeToKeepDim:()=>xo,exponent:()=>lX,exponents:()=>aX,fromStringArrayToUint8:()=>RX,fromUint8ToStringArray:()=>DX,getAxesPermutation:()=>pS,getBroadcastDims:()=>F_,getComplexWithIndex:()=>sX,getEinsumComputePath:()=>fX,getEinsumPermutation:()=>pX,getFusedBiasGradient:()=>cc,getFusedDyActivation:()=>uc,getImageCenter:()=>W5,getInnerMostAxes:()=>pK,getPermuted:()=>H5,getRaggedRank:()=>B5,getReductionAxes:()=>ye,getReshaped:()=>U5,getReshapedPermuted:()=>q5,getRowPartitionTypesHelper:()=>z5,getSliceBeginCoords:()=>K5,getSliceSize:()=>j5,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>xX,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>yX,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>bX,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>vX,getSparseReshapeInputOutputMismatchErrorMessage:()=>SX,getSparseReshapeInputOutputMultipleErrorMessage:()=>IX,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>wX,getSparseReshapeNegativeOutputDimErrorMessage:()=>CX,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>_X,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>TX,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>NX,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>kX,getUndoAxesPermutation:()=>wh,isIdentityPermutation:()=>dX,log:()=>I4,mergeRealAndImagArrays:()=>eX,prepareAndValidate:()=>P_,prepareSplitSize:()=>gX,segment_util:()=>NS,shouldFuse:()=>mc,slice_util:()=>Be,splitRealAndImagArrays:()=>rX,tupleValuesAreOne:()=>Jn,upcastType:()=>ir,validateDefaultValueShape:()=>V5,validateInput:()=>bx,validateUpdateShape:()=>eS,warn:()=>Ei});function P5(r,t){let e=r[0].length;r.forEach((o,s)=>{A(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),A(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<e;i++)A(i===t||o[i]===n[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function L5(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var Ki;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(Ki||(Ki={}));function M5(r,t,e){let n=new Array;if(e==null&&t==null)return n;if(t==null)for(;n.length<r+e.length;)n.push(-1);else n=t.slice();if(e==null)return n;if(r+e.length!==n.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${r+e.length}, but shape.rank = ${n.length}`);for(let o=1;o<e.length;++o){let s=e[o],i=n[n.length-e.length+o],a=n[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o+r}] = ${s} but shape[${o+r}] = ${a}`)}else n[i]=s}return n}function z5(r){let t={FIRST_DIM_SIZE:Ki.FIRST_DIM_SIZE,VALUE_ROWIDS:Ki.VALUE_ROWIDS,ROW_LENGTHS:Ki.ROW_LENGTHS,ROW_SPLITS:Ki.ROW_SPLITS,ROW_LIMITS:Ki.ROW_LIMITS,ROW_STARTS:Ki.ROW_STARTS},e=[];for(let n of r)if(n in t)e.push(t[n]);else break;return e}function B5(r){return r.length===0?0:r[0]===Ki.FIRST_DIM_SIZE?r.length-1:r.length}function V5(r,t){if(r==null||t==null)return;let e=r.length,n=t.length;if(e>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${n})`);for(let o=0;o<Math.min(e,n-1);++o){let s=r[o],i=t[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o-r.length}] = ${s} but ragged tensor input.flatValues.shape[${o-r.length}] = ${i}`)}}var Dy=30;function G5(r){return r<=Dy?r:wp(r,Math.floor(Math.sqrt(r)))}function W5(r,t,e){let n=e*(typeof r=="number"?r:r[0]),o=t*(typeof r=="number"?r:r[1]);return[n,o]}function U5(r,t,e,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(r[0]/e),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/t[i],t[i]]);o=o.concat(r.slice(s+1))}return o}function H5(r,t,e=!0){let n=[];if(e){n.push(t);for(let o=t+1;o<r;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function q5(r,t,e,n=!0){let o=[];n?o.push(r[0]/e):o.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?n?o.push(t[s-1]*r[s]):o.push(r[s]/t[s-1]):o.push(r[s]);return o}function K5(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function j5(r,t,e){let n=r.slice(0,1);for(let o=0;o<e;++o)n.push(r[o+1]-t[o][0]-t[o][1]);return n}var IS=1.7580993408473768,SS=1.0507009873554805;var X5=.3275911,Y5=.254829592,Z5=-.284496736,J5=1.421413741,Q5=-1.453152027,tX=1.061405429;function eX(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function rX(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function nX(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function oX(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function sX(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function iX(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function aX(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(t?2:-2)*Math.PI*(o/r);e[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:e,imag:n}}function lX(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var TS="->",uX=/->/g,OA=",",PA="...";function cX(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(uX,"").length)/TS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${TS}").`);let[n,o]=r.split(TS);A(n.indexOf(PA)===-1,()=>`The ellipsis notation ("${PA}") is not supported yet.`);let s=n.split(OA),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let m=0;m<n.length;++m){let f=n[m];a.indexOf(f)===-1&&f!==OA&&a.push(f)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let f=0;f<s[m].length;++f)u[m].push(a.indexOf(s[m][f]))}let l=a.length,c=o.length,p=[];for(let m=c;m<l;++m)p.push(m);return{allDims:a,summedDims:p,idDims:u}}function pX(r,t){let e=new Array(r);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let n=[];for(let o=0;o<r;++o)e[o]===-1&&n.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:n}}function mX(r,t,e){let n=new Array(r);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<t[o].length;++i)n[t[o][i]]===void 0?n[t[o][i]]=s[i]:A(n[t[o][i]]===s[i],()=>`Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function fX(r,t){let e=r,n=[],o=0;r.length===0&&e.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],u=hX(t,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:e,steps:n}}function dX(r){return r.every((t,e)=>t===e)}function hX(r,t){let e=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function gX(r,t,e=0){let n=[];if(typeof t=="number")A(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);A(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,u)=>u>0?a+u:a);t[s]=r.shape[e]-i}A(r.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function xX(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function yX(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function bX(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function wX(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function CX(r,t){return`size ${r} must be non-negative, not ${t}`}function vX(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function IX(r,t){let e=Qt(r),n=Qt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${t}`}function SX(r,t){let e=Qt(r),n=Qt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${t}`}function TX(){return"segment ids must be >= 0"}function NX(){return"segment ids are not increasing"}function kX(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function _X(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var NS={};jt(NS,{collectGatherOpShapeInfo:()=>$X,computeOutShape:()=>AX,segOpComputeOptimalWindowSize:()=>EX});function EX(r,t){let e=!1,n;for(r<=Dy?(n=r,e=!0):n=wp(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=wp(r,n+1);return n}function AX(r,t,e){let n=[],o=r.length;for(let s=0;s<o;s++)s!==t?n.push(r[s]):n.push(e);return n}function $X(r,t,e,n){let o=t.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let p=0;p<n;++p)if(r.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=r.shape[e],a=[],u=1,l=1,c=1;for(let p=0;p<n;++p)a.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<e;p++)a.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<o;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function DX(r){try{return r.map(t=>rm(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function RX(r){return r.map(t=>Ul(t))}var Vr={};jt(Vr,{nonMaxSuppressionV3Impl:()=>ky,nonMaxSuppressionV4Impl:()=>_y,nonMaxSuppressionV5Impl:()=>Ey,whereImpl:()=>Cy});var Ry={kernelName:pi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,yo(tt(e,"float32"),-1))}}};var LA={kernelName:oa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ht(tt(e,"float32")),o=Ne(ut(mt(1),n));return Yt(ct(r,o))}}}};var MA={kernelName:sa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ne(ut(Ht(tt(e,"float32")),1));return ct(r,n)}}}};var zA={kernelName:jn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=r,u=ye(e.shape,o);return u.length>0&&(a=ft(a,u)),F(a,e.shape)},b:()=>{let a=r,u=ye(n.shape,o);return u.length>0&&(a=ft(a,u)),F(a,n.shape)}}}};var BA={kernelName:jo,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,o)=>{e[o]=()=>r.clone()}),e}};var VA={kernelName:Xo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var GA={kernelName:Nl,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var WA={kernelName:la,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Ne(ut(mt(1),Ht(tt(e,"float32")))))}}};var UA={kernelName:ua,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ne(J(mt(1),Ht(tt(e,"float32"))));return ct(r,n)}}}};var HA={kernelName:ma,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=J(Ht(e),Ht(n)),u=O(r,ct(n,a)),l=ye(e.shape,o);return l.length>0&&(u=ft(u,l)),F(u,e.shape)},b:()=>{let a=J(Ht(e),Ht(n)),u=Yt(O(r,ct(e,a))),l=ye(n.shape,o);return l.length>0&&(u=ft(u,l)),F(u,n.shape)}}}};var qA={kernelName:ca,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(Ht(tt(e,"float32")),1))}}};var KA={kernelName:pa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,ut(mt(1),Ht(tt(e,"float32"))))}}};function FX(r,t,e,n,o,s){let i=v(r,"dy","avgPool3dGrad"),a=v(t,"input","avgPool3dGrad"),u=i,l=a,c=!1;a.rank===4&&(c=!0,u=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),A(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),A(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Te("avgPool3dGrad",o,s);let p={dy:u,input:l},m={filterSize:e,strides:n,pad:o,dimRoundingMode:s},f=_.runKernel(Ip,p,m);return c?F(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var jA=N({avgPool3dGrad_:FX});var XA={kernelName:kl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>jA(r,n,o,s,i,a)}}};function OX(r,t,e,n,o){let s=v(r,"dy","avgPoolGrad"),i=v(t,"input","avgPoolGrad");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,u=s,l=!1;i.rank===3&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),A(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:u,input:a},p={filterSize:e,strides:n,pad:o},m=_.runKernel(vp,c,p);return l?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var YA=N({avgPoolGrad_:OX});var ZA={kernelName:Yo,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i}=e;return{x:()=>YA(r,n,o,s,i)}}};var JA={kernelName:Zo,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,o]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>Gt(r,o,!1,!0),b:()=>Gt(n,r,!0,!1)}:!s&&i?{a:()=>Gt(r,o,!1,!1),b:()=>Gt(r,n,!0,!1)}:s&&!i?{a:()=>Gt(o,r,!1,!0),b:()=>Gt(n,r,!1,!1)}:{a:()=>Gt(o,r,!0,!0),b:()=>Gt(r,n,!0,!0)}}};var QA={kernelName:mi,gradFunc:(r,t,e)=>{let{blockShape:n,crops:o}=e;return{x:()=>ru(r,n,o)}}};var t2={kernelName:N1,gradFunc:(r,t,e)=>{let n=e,o=n.inputShape,s=n.shape,i=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])i[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>ft(r,a,!0)}}};var e2={kernelName:ao,gradFunc:r=>({x:()=>r.clone()})};var r2={kernelName:Jo,gradFunc:r=>({x:()=>St(r)})};var n2={kernelName:lo,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>De(Dr(Pn(n,o),Ln(n,s)),r,St(r))}}};var o2={kernelName:_l,inputsToSave:["x"],gradFunc:Ry.gradFunc};var s2={kernelName:fi,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:o}=e,s=ur(o,t[0].shape)[0],i=n.map(u=>u[s]);return mr(r,i,s).map(u=>()=>u)}};var i2={kernelName:Qo,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{dilations:s,strides:i,pad:a,dataFormat:u}=e;return A(Jn(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>fm(n.shape,r,o,i,a,u),filter:()=>Fm(n,r,o.shape,i,a,u)}}};var a2={kernelName:ts,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>Sn(r,o,s,i,a,1,u),filter:()=>Fm(r,n,o.shape,s,i,a,u)}}};function PX(r,t,e,n,o){let s=r;r.rank===4&&(s=F(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=t;i.rank===4&&(i=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),A(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),A(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},u={strides:n,pad:o,filterShape:e};return _.runKernel(_p,a,u)}var l2=N({conv3DBackpropFilter_:PX});var u2={kernelName:El,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s}=e;A(Jn(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=t;return{x:()=>Vx(i.shape,r,a,o,s),filter:()=>l2(i,r,a.shape,o,s)}}};var c2={kernelName:es,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(Yt(Nm(tt(e,"float32"))),r)}}};var p2={kernelName:rs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(km(tt(e,"float32")),r)}}};var m2={kernelName:ns,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=pS([o],n.rank),u=gm(r,o,s,!i);return a!=null&&(u=Mt(u,a)),u}}}};var f2={kernelName:os,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=e,a=n==null?[1,1]:n;A(Jn(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[u,l]=t;return A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),A(Er(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),Te("depthwiseConv2d",s,i),{x:()=>Sy(u.shape,r,l,o,s,a,i),filter:()=>Iy(u,r,l.shape,o,s,a,i)}}};var d2={kernelName:Al,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,s={x:n,filter:o,dy:r},i={x:n,filter:o,dy:r};return{x:()=>_.runKernel(oh,s,e),filter:()=>_.runKernel(sh,i,e)}}};var h2={kernelName:is,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>_.runKernel(Op,n)}}};var g2={kernelName:ga,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=O(or(Yt(Ht(e))),2/Math.sqrt(Math.PI));return{x:()=>O(r,n)}}};var x2={kernelName:as,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,e)}}};var y2={kernelName:di,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>F(r,e.shape)}}};var b2={kernelName:ya,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,or(e))}}};var w2={kernelName:ls,gradFunc:r=>({x:()=>St(r)})};var C2={kernelName:us,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=ct(r,tt(n,"float32")),u=ye(e.shape,o);return u.length>0?F(ft(a,u),e.shape):a},b:()=>{let a=O(r,tt(e,"float32")),u=ye(n.shape,o);u.length>0&&(a=F(ft(a,u),n.shape));let l=Ht(n);return Yt(ct(a,tt(l,"float32")))}}}};var v2={kernelName:cs,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[o,s,i,a]=t,u=a==null?mt(1):a,l=ye(s.shape,o.shape),c=[];if(s.rank===1){for(let C=0;C<o.shape.length-1;++C)c.push(o.shape[C]);c.push(1)}let p=ut(o,s),m=O(r,u),f=Im(J(i,mt(n))),d=O(O(O(f,f),f),mt(-.5));return{x:()=>s.rank===1?F(O(O(r,$r(F(f,[1,1,1,s.shape[0]]),c)),u),o.shape):F(O(O(r,f),u),o.shape),mean:()=>{let C=O(O(f,mt(-1)),m);return s.rank===1&&(C=ft(C,l)),F(C,s.shape)},variance:()=>{let C=O(O(d,p),m);return s.rank===1&&(C=ft(C,l)),F(C,s.shape)},scale:()=>{let C=O(p,f),T=O(r,C);return s.rank===1&&(T=ft(T,l)),F(T,s.shape)},offset:()=>{let C=r;return s.rank===1&&(C=ft(C,l)),F(C,s.shape)}}}};var T2={kernelName:hi,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,o]=t,{axis:s}=e,i=ur(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,c=u.slice(0,i),p=c.length,m=u.slice(s,u.length).slice(1),f=m.length,d=I2(0,p),h=I2(p+1,p+1+f),g=S2([c,[l],m]),x=F(r,g),b=F(o,[l]),w=S2([[p],d,h]),C=Mt(x,w),T=Rm(C,b,n.shape[i]),E=wh(w);return T=Mt(T,E),T},indices:()=>o}}};function I2(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function S2(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var N2={kernelName:ps,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>St(e),b:()=>St(n)}}};var k2={kernelName:uo,gradFunc:r=>({x:()=>tt(r,"float32")})};var _2={kernelName:va,gradFunc:r=>({x:()=>St(r)})};var E2={kernelName:Ia,gradFunc:r=>({x:()=>St(r)})};var A2={kernelName:Sa,gradFunc:r=>({x:()=>St(r)})};var $2={kernelName:ms,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:o}=e,s=Xe(n,0);return{x:()=>De(s,r,O(r,o))}}};var D2={kernelName:ka,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(e,1))}}};var R2={kernelName:fs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,tt(e,"float32"))}}};var F2={kernelName:_1,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e;return{logits:()=>{let i=or(n);return ut(r,O(ft(r,o,!0),i))}}}};function LX(r,t,e,n=5,o=1,s=1,i=.5){let a={x:r,y:t,dy:e},u={depthRadius:n,bias:o,alpha:s,beta:i};return _.runKernel(Bp,a,u)}var O2=N({localResponseNormalizationBackprop_:LX});var P2={kernelName:Dl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{depthRadius:s,bias:i,alpha:a,beta:u}=e;return{x:()=>O2(n,o,r,s,i,a,u)}}};function Fy(r,t,e,n){return t.rank<e.rank&&(t=F(t,xo(t.shape,n))),r.rank<e.rank&&(r=F(r,xo(r.shape,n))),{x:()=>O(r,tt(Ar(e,t),r.dtype))}}var kS={kernelName:ds,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:o}=n,s=t[0],i=t[1],a=ur(o,s.shape),u=Fy(r,i,s,a);return{x:()=>u.x()}}};var L2={kernelName:hs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>O(r,tt(Pn(e,n),"float32")),b:()=>O(r,tt(xm(e,n),"float32"))}}};function MX(r,t,e,n,o,s,i){let a=v(r,"dy","maxPool3dGrad"),u=v(t,"input","maxPool3dGrad"),l=v(e,"output","maxPool3dGrad"),c=a,p=u,m=l,f=!1;u.rank===4&&(f=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=F(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),A(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),A(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),A(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Te("maxPool3dGrad",s,i);let d={dy:c,input:p,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:i},g=_.runKernel(Gp,d,h);return f?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var M2=N({maxPool3dGrad_:MX});var z2={kernelName:Rl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=e;return{x:()=>M2(r,n,o,s,i,a,u)}}};function zX(r,t,e,n,o,s,i){let a=v(r,"dy","maxPoolGrad"),u=v(t,"input","maxPoolGrad"),l=v(e,"output","maxPoolGrad");A(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),A(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),A(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Te("maxPoolGrad",s,i);let c={dy:a,input:u,output:l},p={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return _.runKernel(Vp,c,p)}var B2=N({maxPoolGrad_:zX});var V2={kernelName:gs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>B2(r,n,o,s,i,a)}}};var G2={kernelName:xs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=ur(o,n.shape),a=cS(n.shape,s)[1],u=Qt(a);return{x:()=>{let c=n.shape.slice();s.forEach(f=>{c[f]=1});let p=F(r,c);return ct(O(p,cr(n.shape,"float32")),u)}}}};var W2={kernelName:ys,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:o}=n,[s,i]=t,a=ur(o,s.shape),u=Fy(r,i,s,a);return{x:()=>u.x()}}};var U2={kernelName:bs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>O(r,tt(Ln(e,n),"float32")),b:()=>O(r,tt(Xe(e,n),"float32"))}}};var H2={kernelName:ws,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ot(r,s,n.shape)}}};var q2={kernelName:$a,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=ye(e.shape,o);return a.length>0?F(ft(r,a),e.shape):r},b:()=>{let a=O(r,Yt(Gi(ct(e,n)))),u=ye(n.shape,o);return u.length>0?F(ft(a,u),n.shape):a}}}};var K2={kernelName:Cs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=O(r,tt(n,"float32")),u=ye(e.shape,o);return u.length>0?F(ft(a,u),e.shape):a},b:()=>{let a=O(r,tt(e,"float32")),u=ye(n.shape,o);return u.length>0?F(ft(a,u),n.shape):a}}}};var j2={kernelName:gi,gradFunc:r=>({x:()=>Yt(r)})};var X2={kernelName:vs,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>_e(e.shape,"float32")}}};var Y2={kernelName:xi,gradFunc:r=>({x:()=>St(r)})};var Z2={kernelName:yi,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return Tr(r,n).map(s=>()=>s)}};var _S={kernelName:Is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ot(r,s,n.shape)}}};var J2={kernelName:Ss,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,o]=t,s=e,i=n,a=zt(s.shape,i.shape);return{a:()=>{let c=tt(i,"float32"),p=O(r,O(c,ln(s,ut(c,mt(1))))),m=ye(s.shape,a);return m.length>0&&(p=ft(p,m)),F(p,s.shape)},b:()=>{let c=Xe(s,0),p=De(c,Sr(s),St(s)),m=O(r,O(o,p)),f=ye(i.shape,a);return f.length>0&&(m=ft(m,f)),F(m,i.shape)}}}};var Q2={kernelName:Ts,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,o=Xe(e,0);return{x:()=>De(o,r,O(r,n)),alpha:()=>{let s=De(o,St(r),O(r,e)),i=ye(n.shape,r.shape);return i.length>0&&(s=ft(s,i)),F(s,n.shape)}}}};function BX(r,t,e){let n=r.shape.slice();n[e]=1;let o=F(t,n),s=ec(r,e,!0,!1),i=ec(r,e,!0,!0),a=O(s,i);return O(o,a)}function VX(r,t,e){let n=r.shape.length,o=n-e.length,s=S.getAxesPermutation(e,n),i=r;s!=null&&(i=Mt(r,s));let a=i.shape.slice(),l=a.splice(n-e.length,e.length).reduce((m,f)=>m*f,1);a.push(l);let c=i.reshape(a),p=BX(c,t,o);if(p=p.reshape(i.shape),s!=null){let m=S.getUndoAxesPermutation(s);p=Mt(p,m)}return p}var t$={kernelName:Ns,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=[];return o==null?s=n.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>VX(n,r,s)}}};var e$={kernelName:ss,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=ct(r,tt(n,"float32")),u=ye(e.shape,o);return u.length>0?F(ft(a,u),e.shape):a},b:()=>{let a=O(r,tt(e,"float32")),u=ye(n.shape,o);u.length>0&&(a=F(ft(a,u),n.shape));let l=Ht(n);return Yt(ct(a,tt(l,"float32")))}}}};var r$={kernelName:Pa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Yt(Ht(e)))}}};var n$={kernelName:As,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=O(Ln(e,6),yo(e));return{x:()=>O(r,tt(n,"float32"))}}};var o$={kernelName:ks,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,tt(yo(e),"float32"))}}};var s$={kernelName:bi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>F(r,e.shape)}}};var i$={kernelName:Es,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(jp,o,e)}}};var a$={kernelName:_s,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(Kp,o,e)}}};var l$={kernelName:$s,gradFunc:(r,t,e)=>{let{dims:n}=e,o=ur(n,r.shape);return{x:()=>pr(r,o)}}};var u$={kernelName:Ds,gradFunc:r=>({x:()=>St(r)})};var c$={kernelName:Rs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Yt(ct(r,O(ln(e,1.5),2)))}}};var p$={kernelName:wi,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>tt(St(e),"float32"),t:()=>O(r,tt(e,r.dtype)),e:()=>O(r,tt(tu(e),r.dtype))}}};var m$={kernelName:Ma,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Xe(e,mt(0)),o=mt(IS),s=mt(SS),i=O(r,s),a=O(O(r,o),or(tt(e,"float32")));return De(n,i,a)}}}};var f$={kernelName:Os,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,O(e,ut(mt(1),e)))}}};var d$={kernelName:Ba,gradFunc:r=>({x:()=>St(r)})};var h$={kernelName:Fs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(Zl(tt(e,"float32")),r)}}};var g$={kernelName:za,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(hm(tt(e,"float32")),r)}}};var x$={kernelName:Ci,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:o,size:s}=e,i=n.shape,[a,u]=nS(n,o,s),l=[];for(let c=0;c<r.rank;c++)l.push([a[c],i[c]-a[c]-u[c]]);return{x:()=>cn(r,l)}}};var y$={kernelName:Ms,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:o}=e,s=!0,i=O(r,n);return{logits:()=>ut(i,O(ft(i,[o],s),n))}}};var b$={kernelName:Va,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,Kr(e))}}};var ES={kernelName:vi,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:o}=e;return{x:()=>Yl(r,n,o)}}};var AS={kernelName:Ii,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>se(r,n)}}};var w$={kernelName:Ps,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,O(Ne(tt(e,"float32")),2))}}};var C$={kernelName:Ml,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,O(tt(e,"float32"),2))}}};var v$={kernelName:zs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=mt(2);return{a:()=>O(r,O(o,ut(e,n))),b:()=>O(r,O(o,ut(n,e)))}}};var I$={kernelName:co,gradFunc:r=>({x:()=>St(r)})};var S$={kernelName:Bs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=r,u=ye(e.shape,o);return u.length>0&&(a=ft(a,u)),F(a,e.shape)},b:()=>{let a=r,u=ye(n.shape,o);return u.length>0&&(a=ft(a,u)),F(Yt(a),n.shape)}}}};var T$={kernelName:Ls,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,o=n.shape.slice(),{axis:s}=e;ur(s,n.shape).forEach(l=>{o[l]=1});let a=F(r,o),u=O(a,cr(n.shape,"float32"));return{x:()=>u}}};var N$={kernelName:Vs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Ht(Zl(e)))}}};var k$={kernelName:Gs,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(ut(mt(1),Ht(e)),r)}}};var _$={kernelName:Xn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:o}=e;return{x:()=>{let i=St(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=J(i,Ot(r,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)i=J(i,Ot(r,[a*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)i=J(i,Ot(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let c=0;c<o[3];++c)i=J(i,Ot(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var E$={kernelName:Yn,gradFunc:(r,t,e)=>{let n=e,{perm:o}=n,s=wh(o);return{x:()=>Mt(r,s)}}};var A$={kernelName:Si,gradFunc:(r,t,e)=>{let n=e,{axis:o}=n;return{value:()=>sr(r,o)}}};var $$={kernelName:Gl,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>GX(r,e)}}};function GX(r,t){let e=Tn(t,St(t)),n=Wi(r,e),o=Pn(t,mt(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=yr(o,a+1);o=Dr(o,cr(n.shape,"bool"));let i=St(n);return De(o,n,i)}var D$={kernelName:Ti,gradFunc:r=>({x:()=>St(r)})};var WX=[Ry,LA,MA,zA,BA,VA,GA,WA,UA,HA,qA,KA,XA,ZA,JA,QA,t2,e2,r2,n2,o2,s2,a2,i2,u2,c2,p2,m2,f2,d2,e$,h2,g2,x2,y2,b2,C2,w2,v2,T2,N2,k2,_2,E2,A2,$2,D2,R2,F2,P2,kS,kS,L2,z2,V2,G2,W2,U2,H2,q2,K2,j2,X2,Y2,Z2,_S,_S,J2,Q2,t$,r$,n$,o$,s$,i$,a$,l$,u$,c$,p$,m$,f$,d$,h$,g$,x$,y$,b$,ES,ES,AS,AS,w$,v$,C$,I$,S$,T$,N$,k$,_$,E$,A$,$$,D$];for(let r of WX)A1(r);L().prototype.abs=function(){return this.throwIfDisposed(),$e(this)};L().prototype.acos=function(){return this.throwIfDisposed(),Cx(this)};L().prototype.acosh=function(){return this.throwIfDisposed(),vx(this)};L().prototype.add=function(r){return this.throwIfDisposed(),J(this,r)};L().prototype.all=function(r,t){return this.throwIfDisposed(),cm(this,r,t)};L().prototype.any=function(r,t){return this.throwIfDisposed(),Ju(this,r,t)};L().prototype.argMax=function(r){return this.throwIfDisposed(),Oi(this,r)};L().prototype.argMin=function(r){return this.throwIfDisposed(),Ix(this,r)};L().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),F(this,[])};L().prototype.asType=function(r){return this.throwIfDisposed(),tt(this,r)};L().prototype.as1D=function(){return this.throwIfDisposed(),F(this,[this.size])};L().prototype.as2D=function(r,t){return this.throwIfDisposed(),F(this,[r,t])};L().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),F(this,[r,t,e])};L().prototype.as4D=function(r,t,e,n){return this.throwIfDisposed(),F(this,[r,t,e,n])};L().prototype.as5D=function(r,t,e,n,o){return this.throwIfDisposed(),F(this,[r,t,e,n,o])};L().prototype.asin=function(){return this.throwIfDisposed(),Sx(this)};L().prototype.asinh=function(){return this.throwIfDisposed(),Tx(this)};L().prototype.atan=function(){return this.throwIfDisposed(),Nx(this)};L().prototype.atan2=function(r){return this.throwIfDisposed(),kx(this,r)};L().prototype.atanh=function(){return this.throwIfDisposed(),_x(this)};L().prototype.avgPool=function(r,t,e,n){return this.throwIfDisposed(),Xl(this,r,t,e,n)};L().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),Yl(this,r,t)};L().prototype.batchNorm=function(r,t,e,n,o){return this.throwIfDisposed(),Li(this,r,t,e,n,o)};L().prototype.broadcastTo=function(r){return this.throwIfDisposed(),Mi(this,r)};L().prototype.cast=function(r){return this.throwIfDisposed(),tt(this,r)};L().prototype.ceil=function(){return this.throwIfDisposed(),Ox(this)};L().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),Ir(this,r,t)};L().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof Lt&&(r=[r]),se([this,...r],t)};L().prototype.conv1d=function(r,t,e,n,o,s){return this.throwIfDisposed(),mm(this,r,t,e,n,o,s)};L().prototype.conv2dTranspose=function(r,t,e,n,o){return this.throwIfDisposed(),dm(this,r,t,e,n,o)};L().prototype.conv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Sn(this,r,t,e,n,o,s)};L().prototype.cos=function(){return this.throwIfDisposed(),Zl(this)};L().prototype.cosh=function(){return this.throwIfDisposed(),hm(this)};L().prototype.cumprod=function(r,t,e){return this.throwIfDisposed(),ec(this,r,t,e)};L().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),gm(this,r,t,e)};L().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),Wx(this,r,t)};L().prototype.depthwiseConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),zi(this,r,t,e,n,o,s)};L().prototype.dilation2d=function(r,t,e,n,o){return this.throwIfDisposed(),Ux(this,r,t,e,n,o)};L().prototype.divNoNan=function(r){return this.throwIfDisposed(),Hx(this,r)};L().prototype.div=function(r){return this.throwIfDisposed(),ct(this,r)};L().prototype.dot=function(r){return this.throwIfDisposed(),qx(this,r)};L().prototype.elu=function(){return this.throwIfDisposed(),Bi(this)};L().prototype.equal=function(r){return this.throwIfDisposed(),Ar(this,r)};L().prototype.erf=function(){return this.throwIfDisposed(),Kx(this)};L().prototype.euclideanNorm=function(r,t){return this.throwIfDisposed(),jx(this,r,t)};L().prototype.exp=function(){return this.throwIfDisposed(),or(this)};L().prototype.expandDims=function(r){return this.throwIfDisposed(),yr(this,r)};L().prototype.expm1=function(){return this.throwIfDisposed(),Xx(this)};L().prototype.fft=function(){return this.throwIfDisposed(),iu(this)};L().prototype.flatten=function(){return this.throwIfDisposed(),F(this,[this.size])};L().prototype.floor=function(){return this.throwIfDisposed(),Gi(this)};L().prototype.floorDiv=function(r){return this.throwIfDisposed(),um(this,r)};L().prototype.gather=function(r,t){return this.throwIfDisposed(),Wi(this,r,t)};L().prototype.greaterEqual=function(r){return this.throwIfDisposed(),Pn(this,r)};L().prototype.greater=function(r){return this.throwIfDisposed(),Xe(this,r)};L().prototype.ifft=function(){return this.throwIfDisposed(),Qa(this)};L().prototype.irfft=function(){return this.throwIfDisposed(),Am(this)};L().prototype.isFinite=function(){return this.throwIfDisposed(),Yx(this)};L().prototype.isInf=function(){return this.throwIfDisposed(),Zx(this)};L().prototype.isNaN=function(){return this.throwIfDisposed(),Jx(this)};L().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Jl(this,r)};L().prototype.lessEqual=function(r){return this.throwIfDisposed(),Ln(this,r)};L().prototype.less=function(r){return this.throwIfDisposed(),xm(this,r)};L().prototype.localResponseNormalization=function(r,t,e,n){return this.throwIfDisposed(),Qx(this,r,t,e,n)};L().prototype.logSigmoid=function(){return this.throwIfDisposed(),ry(this)};L().prototype.logSoftmax=function(r){return this.throwIfDisposed(),ym(this,r)};L().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),bm(this,r,t)};L().prototype.log=function(){return this.throwIfDisposed(),Sr(this)};L().prototype.log1p=function(){return this.throwIfDisposed(),Ql(this)};L().prototype.logicalAnd=function(r){return this.throwIfDisposed(),Dr(this,r)};L().prototype.logicalNot=function(){return this.throwIfDisposed(),tu(this)};L().prototype.logicalOr=function(r){return this.throwIfDisposed(),wm(this,r)};L().prototype.logicalXor=function(r){return this.throwIfDisposed(),ny(this,r)};L().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),Gt(this,r,t,e)};L().prototype.maxPool=function(r,t,e,n){return this.throwIfDisposed(),eu(this,r,t,e,n)};L().prototype.max=function(r,t){return this.throwIfDisposed(),Mr(this,r,t)};L().prototype.maximum=function(r){return this.throwIfDisposed(),Tn(this,r)};L().prototype.mean=function(r,t){return this.throwIfDisposed(),ke(this,r,t)};L().prototype.min=function(r,t){return this.throwIfDisposed(),rc(this,r,t)};L().prototype.minimum=function(r){return this.throwIfDisposed(),Ui(this,r)};L().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),iy(this,r,t)};L().prototype.mod=function(r){return this.throwIfDisposed(),ay(this,r)};L().prototype.mul=function(r){return this.throwIfDisposed(),O(this,r)};L().prototype.neg=function(){return this.throwIfDisposed(),Yt(this)};L().prototype.norm=function(r,t,e){return this.throwIfDisposed(),Ja(this,r,t,e)};L().prototype.notEqual=function(r){return this.throwIfDisposed(),qs(this,r)};L().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),Ri(this,r,t,e)};L().prototype.onesLike=function(){return this.throwIfDisposed(),br(this)};L().prototype.pad=function(r,t){return this.throwIfDisposed(),cn(this,r,t)};L().prototype.pool=function(r,t,e,n,o,s){return this.throwIfDisposed(),ly(this,r,t,e,n,o,s)};L().prototype.pow=function(r){return this.throwIfDisposed(),ln(this,r)};L().prototype.prelu=function(r){return this.throwIfDisposed(),nu(this,r)};L().prototype.prod=function(r,t){return this.throwIfDisposed(),uy(this,r,t)};L().prototype.reciprocal=function(){return this.throwIfDisposed(),dy(this)};L().prototype.relu=function(){return this.throwIfDisposed(),Rr(this)};L().prototype.relu6=function(){return this.throwIfDisposed(),Cm(this)};L().prototype.reshapeAs=function(r){return this.throwIfDisposed(),F(this,r.shape)};L().prototype.reshape=function(r){return this.throwIfDisposed(),F(this,r)};L().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),Ay(this,r,t,e)};L().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),$y(this,r,t,e)};L().prototype.reverse=function(r){return this.throwIfDisposed(),pr(this,r)};L().prototype.rfft=function(){return this.throwIfDisposed(),au(this)};L().prototype.round=function(){return this.throwIfDisposed(),vm(this)};L().prototype.rsqrt=function(){return this.throwIfDisposed(),Im(this)};L().prototype.selu=function(){return this.throwIfDisposed(),Sm(this)};L().prototype.separableConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Tm(this,r,t,e,n,o,s)};L().prototype.sigmoid=function(){return this.throwIfDisposed(),Kr(this)};L().prototype.sign=function(){return this.throwIfDisposed(),hy(this)};L().prototype.sin=function(){return this.throwIfDisposed(),Nm(this)};L().prototype.sinh=function(){return this.throwIfDisposed(),km(this)};L().prototype.slice=function(r,t){return this.throwIfDisposed(),Ot(this,r,t)};L().prototype.softmax=function(r){return this.throwIfDisposed(),su(this,r)};L().prototype.softplus=function(){return this.throwIfDisposed(),Hs(this)};L().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),ru(this,r,t)};L().prototype.split=function(r,t){return this.throwIfDisposed(),mr(this,r,t)};L().prototype.sqrt=function(){return this.throwIfDisposed(),Ne(this)};L().prototype.square=function(){return this.throwIfDisposed(),Ht(this)};L().prototype.squaredDifference=function(r){return this.throwIfDisposed(),$m(this,r)};L().prototype.squeeze=function(r){return this.throwIfDisposed(),Mn(this,r)};L().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof Lt?[this,r]:[this,...r];return sr(e,t)};L().prototype.step=function(r){return this.throwIfDisposed(),yo(this,r)};L().prototype.stridedSlice=function(r,t,e,n,o,s,i,a){return this.throwIfDisposed(),gy(this,r,t,e,n,o,s,i,a)};L().prototype.sub=function(r){return this.throwIfDisposed(),ut(this,r)};L().prototype.sum=function(r,t){return this.throwIfDisposed(),ft(this,r,t)};L().prototype.tan=function(){return this.throwIfDisposed(),xy(this)};L().prototype.tanh=function(){return this.throwIfDisposed(),Pi(this)};L().prototype.tile=function(r){return this.throwIfDisposed(),$r(this,r)};L().prototype.toBool=function(){return this.throwIfDisposed(),tt(this,"bool")};L().prototype.toFloat=function(){return this.throwIfDisposed(),tt(this,"float32")};L().prototype.toInt=function(){return this.throwIfDisposed(),tt(this,"int32")};L().prototype.topk=function(r,t){return this.throwIfDisposed(),yy(this,r,t)};L().prototype.transpose=function(r){return this.throwIfDisposed(),Mt(this,r)};L().prototype.unique=function(r){return this.throwIfDisposed(),by(this,r)};L().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),Rm(this,r,t)};L().prototype.unstack=function(r){return this.throwIfDisposed(),Tr(this,r)};L().prototype.where=function(r,t){return this.throwIfDisposed(),De(r,this,t)};L().prototype.zerosLike=function(){return this.throwIfDisposed(),St(this)};var Nn=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nn.prototype)}},Gr=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Gr.prototype)}},z=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}},Nt=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nt.prototype)}},Om=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Om.prototype)}};var Nh=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function Co(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function to(r,t){if(!r)throw new Om(t)}function DS(r,t){let e=0;for(let n of r)n===t&&e++;return e}function Nr(r){return r.length===1?r[0]:r}function be(r){return Array.isArray(r)?r:[r]}function vo(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function tl(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var wo={};function Pm(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function $S(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>$S(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:$S(n))}}}function ji(r,t={},e={},n="object",o=!1){if(typeof r=="string"){let s=r,i;if(s in e)i=e[s];else if(s in wo)i=wo[s];else if(i=t[s],i==null)throw new z(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new z(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,u;if(i in e?[a,u]=e[i]:i in wo?[a,u]=wo.className:i in t&&([a,u]=t[i]),a==null)throw new z(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let f of Object.keys(wo))l[f]=wo[f];for(let f of Object.keys(e))l[f]=e[f];let c=s.config;c.customObjects=l;let p=Object.assign({},wo);for(let f of Object.keys(e))wo[f]=e[f];$S(s.config);let m=u(a,s.config,e,o);return wo=Object.assign({},p),m}else{let l=Object.assign({},wo);for(let p of Object.keys(e))wo[p]=e[p];let c=new a(s.config);return wo=Object.assign({},l),c}}}function UX(r,t){return r<t?-1:r>t?1:0}function kh(r,t){return-1*UX(r,t)}function Io(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function R$(r){if(r==null)throw new z(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function Xi(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new z(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function Oy(r,t,e=0,n=1/0){return to(e>=0),to(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(o=>typeof o===t)}function Je(r,t){Array.isArray(r)?(y.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>Je(e,`element ${n+1} of ${t}`))):y.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${F$(r)}.`)}function F$(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>F$(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function O$(r,t,e){let n=e!=null?e():y.now(),o;return(...i)=>{let a=e!=null?e():y.now();return a-n<t||(n=a,o=r(...i)),o}}function Py(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var HX=0;function My(){return HX++}var Ly={};function gu(r=""){return r in Ly||(Ly[r]=0),Ly[r]+=1,r+Ly[r].toString()}var P$=["channelsFirst","channelsLast"],L$=["nearest","bilinear"],M$=["valid","same","causal"],z$=["max","avg"],B$=["sum","mul","concat","ave"];var Lm=new Map;function Pe(r){Xi(P$,"DataFormat",r)}function G$(r){Xi(L$,"InterpolationFormat",r)}function pn(r){Xi(M$,"PaddingMode",r)}function RS(r){Xi(z$,"PoolMode",r)}var _h=[],V$="/";function Ys(r,t){_h.push(r);try{let e=t();return _h.pop(),e}catch(e){throw _h.pop(),e}}function qX(){return _h.length===0?"":_h.join(V$)+V$}function zy(r){if(!W$(r))throw new Error("Not a valid tensor name: '"+r+"'");return qX()+r}function By(r){if(!W$(r))throw new Error("Not a valid tensor name: '"+r+"'");Lm.has(r)||Lm.set(r,0);let t=Lm.get(r);if(Lm.set(r,Lm.get(r)+1),t>0){let e=`${r}_${t}`;return Lm.set(e,1),e}else return r}var KX=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function W$(r){return!!r.match(KX)}function U$(r){return r===parseInt(r.toString(),10)}function So(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let o=t;o<e;++o)n*=r[o];return n}function dc(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n<t&&(t=n)}return t}function Zs(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n>t&&(t=n)}return t}function jr(r,t){if(t<r)throw new z(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}var FS;function ar(){return FS==null&&(FS=$_().epsilon()),FS}function mn(){return"channelsLast"}function hc(r,t){return tt(r,t)}function rl(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),F(r,e)}function H$(r,t){return G(()=>{if(r.shape.length!==2)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=rl(r,1);return Gy(e,[1,t,1])})}function q$(r){let t=[So(r.shape)];return F(r,t)}function K$(r){if(r.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],So(r.shape,1)];return F(r,t)}function el(r,t,e){return G(()=>{switch(r.rank){case 1:return _m(r,t,e);case 2:return Ih(r,[t,0],[e,r.shape[1]]);case 3:return Em(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return lc(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Ot(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Ot(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function OS(r,t,e){return G(()=>{switch(r.rank){case 1:return _m(r,t,e);case 2:return Ih(r,[0,t],[r.shape[0],e]);case 3:return Em(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return lc(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Eh(r,t,e,n){return G(()=>{switch(r.rank){case 1:return _m(r,t,e);case 2:switch(n){case 1:return el(r,t,e);case 2:return OS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return el(r,t,e);case 2:return Em(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return OS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return el(r,t,e);case 2:return lc(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return lc(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return OS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Mm(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),se(r,t)}function LS(r,t){switch(r.rank){case 1:return Px([r,t]);case 2:return Lx([r,t],0);case 3:return Mx([r,t],0);case 4:return zx([r,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function Gy(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return $r(r,t)}function zm(r,t=0,e=1,n,o){return ac(r,t,e,n,o)}function To(r,t,e,n){if(r.rank<2||t.rank<2)throw new Nt(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new Nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return lu.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?PS(r.rank,n,mn()):null,activation:e});{let o=r.shape.slice(),s=o.pop();r=F(r,[-1,s]);let i=t.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],c=Array.from({length:t.rank},(d,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=F(Mt(t,c),[u,-1]);let p=[...o,...l],m=!1,f=!1;return F(lu.matMul({a:r,b:t,transposeA:m,transposeB:f,bias:n?PS(r.rank,n,mn()):null,activation:e}),p)}}function Wy(r,t,e){return G(()=>(Array.isArray(t)?t=Ve(t,"int32"):t=tt(t,"int32"),Wi(r,t,e)))}function gc(r){return O(r,r)}function PS(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?F(t,[1,n[0],1,1,1]):F(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?F(t,[1,1,1,1,n[0]]):F(t,[1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?F(t,[1,n[0],1,1]):F(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?F(t,[1,1,1,n[0]]):F(t,[1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?F(t,[1,n[0],1]):F(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?F(t,[1,1,n[0]]):F(t,[1].concat(n))}else if(r<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function fn(r,t,e){return G(()=>(e==null&&(e=mn()),Pe(e),J(r,PS(r.rank,t,e))))}function j$(r,t=1){if(t!==1)throw new Nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Bi(r)}function X$(r){return G(()=>ct(r,J($e(r),1)))}function Uy(r,t,e,n){return G(()=>bS(r,t,e,n))}function Y$(r){return G(()=>{let t=J(.5,O(.2,r));return Ir(t,0,1)})}function xu(r,t,e=!1){return e?r():t()}var Z$=["fanIn","fanOut","fanAvg"],J$=["normal","uniform","truncatedNormal"];function jX(r){Xi(Z$,"FanMode",r)}function XX(r){Xi(J$,"Distribution",r)}var hn=class extends rt.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Bm=class extends hn{apply(t,e){return _e(t,e)}};Bm.className="Zeros";rt.registerClass(Bm);var yu=class extends hn{apply(t,e){return cr(t,e)}};yu.className="Ones";rt.registerClass(yu);var Vm=class extends hn{constructor(t){if(super(),typeof t!="object")throw new z(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new z(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return G(()=>O(mt(this.value),cr(t,e)))}getConfig(){return{value:this.value}}};Vm.className="Constant";rt.registerClass(Vm);var Gm=class extends hn{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Hi(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Gm.className="RandomUniform";rt.registerClass(Gm);var Wm=class extends hn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`randomNormal does not support dType ${e}.`);return zm(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Wm.className="RandomNormal";rt.registerClass(Wm);var Um=class extends hn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`truncatedNormal does not support dType ${e}.`);return Dm(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Um.className="TruncatedNormal";rt.registerClass(Um);var Hm=class extends hn{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return G(()=>{if(t.length!==2||t[0]!==t[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return O(this.gain,nc(t[0]))})}getConfig(){return{gain:this.gain}}};Hm.className="Identity";rt.registerClass(Hm);function YX(r,t="channelsLast"){let e,n;if(Pe(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let o=So(r,2);e=r[1]*o,n=r[0]*o}else if(t==="channelsLast"){let o=So(r,0,r.length-2);e=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=So(r);e=Math.sqrt(o),n=Math.sqrt(o)}return[e,n]}var Wr=class extends hn{constructor(t){if(super(),t.scale<0)throw new z(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,jX(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,XX(this.distribution),this.seed=t.seed}apply(t,e){let n=YX(t),o=n[0],s=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,o):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(o+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`${this.getClassName()} does not support dType ${e}.`);return Dm(t,0,a,e,this.seed)}else{let a=Math.sqrt(3*i);return Hi(t,-a,a,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Wr.className="VarianceScaling";rt.registerClass(Wr);var xc=class extends Wr{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Wr.className}};xc.className="GlorotUniform";rt.registerClass(xc);var yc=class extends Wr{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Wr.className}};yc.className="GlorotNormal";rt.registerClass(yc);var bc=class extends Wr{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Wr.className}};bc.className="HeNormal";rt.registerClass(bc);var wc=class extends Wr{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Wr.className}};wc.className="HeUniform";rt.registerClass(wc);var Cc=class extends Wr{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Wr.className}};Cc.className="LeCunNormal";rt.registerClass(Cc);var vc=class extends Wr{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Wr.className}};vc.className="LeCunNormal";rt.registerClass(vc);var qm=class extends hn{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new Nt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return G(()=>{if(t.length<2)throw new Nt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let n=t[0]>t[1]?[t[1],t[0]]:t,o=zm(n,0,1,"float32"),s=vS.gramSchmidt(o);return t[0]>t[1]&&(s=Mt(s)),O(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};qm.className="Orthogonal";rt.registerClass(qm);var Q$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tD(r,t={}){return ji(r,rt.SerializationMap.getMap().classNameMap,t,"initializer")}function Ee(r){return Pm(r)}function ge(r){if(typeof r=="string"){let t=r in Q$?Q$[r]:r;if(t==="GlorotNormal")return new yc;if(t==="GlorotUniform")return new xc;if(t==="HeNormal")return new bc;if(t==="HeUniform")return new wc;if(t==="LeCunNormal")return new Cc;if(t==="LeCunUniform")return new vc;{let e={};return e.className=t,e.config={},tD(e)}}else return r instanceof hn?r:tD(r)}function Hy(r){return Array.isArray(r)&&Array.isArray(r[0])}function Km(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Pt(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new z(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function te(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new z(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function jm(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,o)=>n*o);return t}var rD="Variable",Ah=class{constructor(t,e="float32",n=rD,o=!0,s=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=My(),n=n==null?rD:n,this.originalName=zy(n),this.name=By(this.originalName),this.trainable_=o,this.constraint=s,this.val=wy(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),JX(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function JX(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function $h(r){return r.map(t=>t.read())}function Xm(r){r.forEach(t=>{t[0].write(t[1])})}var we=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Xr=class{constructor(t,e,n,o,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=My(),i!=null&&(this.originalName=zy(i),this.name=By(this.originalName)),this.rank=e.length}},QX=0,nl=class{constructor(t,e){this.callArgs=e,this.id=QX++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},t8=0,Bt=class extends rt.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=t8++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=vo(n)+"_"+gu(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),n=[s].concat(t.inputShape)}this.batchInputShape=n;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Gr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Nr(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Nr(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Nn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Nn(`Layer ${this.name} is not connected, no input to return.`);return Nr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Nn(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Nn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Nr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=be(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=be(this.inputSpec);if(t.length!==e.length)throw new z(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){let o=t[n],s=e[n];if(s==null)continue;let i=o.rank;if(s.ndim!=null&&i!==s.ndim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new z(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let a=o.shape;for(let u in s.axes){let l=Number(u),c=s.axes[u],p=l>=0?a[l]:a[a.length+l];if(c!=null&&[c,null].indexOf(p)===-1)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let u=s.shape[a],l=o.shape[a];if(u!=null&&l!=null&&u!==l)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=be(t),o=!0;for(let i of n)if(!(i instanceof Xr)){o=!1;break}let s=!0;for(let i of n)if(i instanceof Xr){s=!1;break}if(o===s)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ys(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of be(t))i.push(a.shape);this.build(Nr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e),a=be(i),u=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=Nr(u),this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=e8(t),a=this.computeOutputShape(i),u,l=r8(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,p)=>new Xr(l,c,this,be(t),e,this.name,p)):u=new Xr(l,a,this,be(t),e,this.name),this.addInboundNode(t,u,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&t[o]!=null&&t[o]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Nn(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Nn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Gr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return jm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return $h(t?this.trainableWeights:this.weights)}setWeights(t){G(()=>{let e=this.weights;if(e.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],o=$h(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],u=t[s];if(!y.arraysEqual(i.shape,u.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);n.push([a,u])}Xm(n)})}addWeight(t,e,n,o,s,i,a,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():ge("zeros"));let l=o.apply(e,n),c=new Ah(l,n,t,i,a);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=be(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,n,o,s,i,a=null){let u=be(t);e=be(e),n=be(n),o=be(o),s=Km(s),i=Km(i);let l=[],c=[],p=[];for(let m of u)l.push(m.sourceLayer),c.push(m.nodeIndex),p.push(m.tensorIndex);new nl({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function e8(r){r=be(r);let t=[];for(let e of r)t.push(e.shape);return Nr(t)}function r8(r){return"float32"}function MS(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],u=n.nodeIndices[s],l=MS(i,a,u);for(let c of l)o.indexOf(c)===-1&&o.push(c)}return o}}}var Js=class extends Bt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:gu("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];let o=new Xr(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new nl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Js.className="InputLayer";rt.registerClass(Js);function qy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new Js({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function n8(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return tt(t,r.dtype)}catch(e){throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var No=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof No)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=n8(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Xr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Xr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&_t(this.id2Mask)}},Ky=new Nh,jy=new Nh;function oD(r){Ky!=null&&Ky.setMaxEntries(r),jy!=null&&jy.setMaxEntries(r)}function Ic(r,t,e,n){let o=e==null?!1:e.training,s=Array.isArray(r),i=s?r:[r],a=i.map(d=>d.name),u=[],l=t.names();for(let d of a)l.indexOf(d)!==-1?u.push(t.getValue(d)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().sort().join(","),p=Ky.get(c),m;if(p==null){let d=o8(i,t);p=d.sorted,m=d.recipientCounts,Ky.put(c,p),jy.put(c,m)}m={},o||Object.assign(m,jy.get(c));let f=new No(t);for(let d=0;d<p.length;++d){if(n!=null){let P=xh().numTensors;P>n.maxNumTensors&&(n.maxNumTensors=P),P<n.minNumTensors&&(n.minNumTensors=P)}let h=p[d],g=h.sourceLayer;if(g instanceof Js)continue;let x=[],b=[],w=[],C=!1;for(let P of h.inputs){let M=f.getValue(P),W=f.getMask(P);x.push(M),b.push(W),W!=null&&(C=!0),o||(m[P.name]--,m[P.name]===0&&!t.hasKey(P)&&a.indexOf(P.name)===-1&&!M.isDisposed&&P.sourceLayer.stateful!==!0&&w.push(M))}C&&(e=e||{},e.mask=b[0]);let T=be(g.apply(x,e)),E=null;g.supportsMasking&&(E=g.computeMask(x,b));let $=i8(h),D=Array.isArray($)?$:[$];for(let P=0;P<D.length;++P){f.hasKey(D[P])||f.add(D[P],T[P],Array.isArray(E)?E[0]:E);let M=a.indexOf(D[P].name);M!==-1&&(u[M]=T[P])}o||_t(w)}return f.disposeMasks(),s?u:u[0]}function o8(r,t){y.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let o=nD(r[0],t);e=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:i,recipientMap:a}=nD(s,t);for(let u of i)o.has(u.name)||(e.push(u),o.add(u.name));for(let u in a)n[u]==null&&(n[u]=new Set),a[u].forEach(l=>n[u].add(l))}}return{sorted:e,recipientCounts:s8(n)}}function s8(r){let t={};for(let e in r)t[e]=r[e].size;return t}function nD(r,t){let e=new Set,n=[],o={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(a.inputs.length===0||u)s.pop(),n.push(a),e.add(a.name),u&&i.pop();else{i.push(s.length-1);for(let l of a.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(a.name),!e.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function i8(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var a8=B();a8.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,oD);var aD={};jt(aD,{maxNorm:()=>l8,minMaxNorm:()=>p8,nonNeg:()=>c8,unitNorm:()=>u8});function zS(r,t){return G(()=>Ne(ft(O(r,r),t,!0)))}var Sc=class extends rt.Serializable{getConfig(){return{}}},Ym=class extends Sc{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return G(()=>{let e=zS(t,this.axis),n=Ir(e,0,this.maxValue);return O(t,ct(n,J(ar(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Ym.className="MaxNorm";rt.registerClass(Ym);var Zm=class extends Sc{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return G(()=>ct(t,J(ar(),zS(t,this.axis))))}getConfig(){return{axis:this.axis}}};Zm.className="UnitNorm";rt.registerClass(Zm);var Jm=class extends Sc{apply(t){return Rr(t)}};Jm.className="NonNeg";rt.registerClass(Jm);var Qm=class extends Sc{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return G(()=>{let e=zS(t,this.axis),n=J(O(this.rate,Ir(e,this.minValue,this.maxValue)),O(1-this.rate,e));return O(t,ct(n,J(ar(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Qm.className="MinMaxNorm";rt.registerClass(Qm);var sD={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ge(r){return Pm(r)}function iD(r,t={}){return ji(r,rt.SerializationMap.getMap().classNameMap,t,"constraint")}function We(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in sD?sD[r]:r,config:{}};return iD(e)}else return r instanceof Sc?r:iD(r)}function l8(r){return new Ym(r)}function u8(r){return new Zm(r)}function c8(){return new Jm}function p8(r){return new Qm(r)}var lD={};jt(lD,{constant:()=>d8,glorotNormal:()=>C8,glorotUniform:()=>w8,heNormal:()=>v8,heUniform:()=>I8,identity:()=>y8,leCunNormal:()=>S8,leCunUniform:()=>T8,ones:()=>f8,orthogonal:()=>N8,randomNormal:()=>g8,randomUniform:()=>h8,truncatedNormal:()=>x8,varianceScaling:()=>b8,zeros:()=>m8});function m8(){return new Bm}function f8(){return new yu}function d8(r){return new Vm(r)}function h8(r){return new Gm(r)}function g8(r){return new Wm(r)}function x8(r){return new Um(r)}function y8(r){return new Hm(r)}function b8(r){return new Wr(r)}function w8(r){return new xc(r)}function C8(r){return new yc(r)}function v8(r){return new bc(r)}function I8(r){return new wc(r)}function S8(r){return new Cc(r)}function T8(r){return new vc(r)}function N8(r){return new qm(r)}var BD={};jt(BD,{Layer:()=>Bt,RNN:()=>_n,RNNCell:()=>al,activation:()=>VY,add:()=>YY,alphaDropout:()=>R7,average:()=>ZY,averagePooling1d:()=>QS,averagePooling2d:()=>tT,averagePooling3d:()=>eT,avgPool1d:()=>i7,avgPool2d:()=>l7,avgPool3d:()=>c7,avgPooling1d:()=>a7,avgPooling2d:()=>u7,avgPooling3d:()=>p7,batchNormalization:()=>n7,bidirectional:()=>T7,concatenate:()=>JY,conv1d:()=>DY,conv2d:()=>RY,conv2dTranspose:()=>FY,conv3d:()=>OY,conv3dTranspose:()=>PY,convLstm2d:()=>C7,convLstm2dCell:()=>v7,cropping2D:()=>MY,dense:()=>GY,depthwiseConv2d:()=>BY,dot:()=>r7,dropout:()=>WY,elu:()=>NY,embedding:()=>XY,flatten:()=>HY,gaussianDropout:()=>D7,gaussianNoise:()=>$7,globalAveragePooling1d:()=>m7,globalAveragePooling2d:()=>f7,globalMaxPool1d:()=>k7,globalMaxPool2d:()=>_7,globalMaxPooling1d:()=>PD,globalMaxPooling2d:()=>LD,gru:()=>h7,gruCell:()=>g7,input:()=>KS,inputLayer:()=>TY,layerNormalization:()=>o7,leakyReLU:()=>_Y,lstm:()=>x7,lstmCell:()=>y7,masking:()=>F7,maxPool1d:()=>E7,maxPool2d:()=>A7,maxPooling1d:()=>MD,maxPooling2d:()=>zD,maxPooling3d:()=>d7,maximum:()=>QY,minimum:()=>t7,multiply:()=>e7,permute:()=>jY,prelu:()=>EY,reLU:()=>kY,repeatVector:()=>qY,reshape:()=>KY,rnn:()=>I7,separableConv2d:()=>LY,simpleRNN:()=>b7,simpleRNNCell:()=>w7,softmax:()=>AY,spatialDropout1d:()=>UY,stackedRNNCells:()=>S7,thresholdedReLU:()=>$Y,timeDistributed:()=>N7,upSampling2d:()=>zY,zeroPadding2d:()=>s7});async function Yi(r){if(r==null)return;let t=[],e=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(o),n.push(i)}}if(t.length>0){let o=await Promise.all(t);for(let s=0;s<o.length;++s)r[e[s]]=o[s][0];_t(n)}}function Xy(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var uD;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(uD||(uD={}));var k8=125,ol=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},Yy=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},BS=class extends ol{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=G(()=>J(this.totals[o],O(s,n)));this.totals[o]=a,i!=null&&i.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:G(()=>{let o=O(ct(1,this.seen),this.totals[n]);e[n]=o,this.totals[n].dispose(),Oe(e[n])}))}},Zy=class extends ol{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){let t=[],e=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let u=i[a];t.push(u.data()),e.push(s),n.push(a)}}let o=await Promise.all(t);for(let s=0;s<o.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=o[s][0]}},Jy=class extends ol{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Th,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=k8),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");y.isNumber(this.yieldEvery)&&(this.maybeWait=O$(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){let o=[];this.yield!=null&&(await Yi(n),o.push(this.yield(t,e,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Yi(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let n=[];this.epochEnd!=null&&(await Yi(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Yi(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let n=[];this.batchEnd!=null&&(await Yi(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):y.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await Yi(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Yi(t),await this.trainEnd(t))}};function Qy(r,t){return r==null&&(r={}),r instanceof ol?[r]:Array.isArray(r)&&r[0]instanceof ol?r:be(r).map(n=>new Jy(n,t))}var gn=class{constructor(){}static registerCallbackConstructor(t,e){y.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),gn.checkForDuplicate(e),gn.constructors[t]==null&&(gn.constructors[t]=[]),gn.constructors[t].push(e)}static checkForDuplicate(t){for(let e in gn.constructors)gn.constructors[+e].forEach(o=>{if(o===t)throw new z("Duplicate callback constructor.")})}static clear(){gn.constructors={}}static createCallbacks(t){let e=[];for(let n in gn.constructors){let o=+n;t>=o&&e.push(...gn.constructors[o])}return e.map(n=>new n)}};gn.constructors={};function tb(r,t,e,n,o,s,i,a,u){let l=new Zy,c=[new BS,...gn.createCallbacks(t)];r!=null&&c.push(...r),c.push(l);let p=new Yy(c);return p.setParams({epochs:e,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:u}),{callbackList:p,history:l}}function xn(r,t={},e=!1){return ji(r,rt.SerializationMap.getMap().classNameMap,t,"layer",e)}function Dh(r,t){return G(()=>{r.dtype!=="float32"&&(r=tt(r,"float32"));let e=ft(gc(r),t,!0),n=Vi(e.shape,ar()),o=Ne(Tn(e,n));return ct(r,o)})}function Zi(r,t){return G(()=>ke(gc(ut(t,r)),-1))}function tf(r,t){return G(()=>ke($e(ut(t,r)),-1))}function bu(r,t){return G(()=>{let e=ut(r,t),n=Ir($e(r),ar(),Number.MAX_VALUE),o=$e(ct(e,n));return O(100,ke(o,-1))})}function _8(r,t){return G(()=>{let e=Ir(t,ar(),Number.MAX_VALUE),n=Sr(J(1,e)),o=Ir(r,ar(),Number.MAX_VALUE),s=Sr(J(1,o));return ke(gc(ut(n,s)),-1)})}function E8(r,t){return G(()=>{let e=Tn(0,ut(1,O(r,t)));return ke(gc(e),-1)})}function A8(r,t){return G(()=>{let e=Tn(0,ut(1,O(r,t)));return ke(e,-1)})}function $8(r,t){return G(()=>{let e=ft(O(r,t),-1),n=Mr(O(ut(1,r),t),-1);return Tn(0,J(1,ut(n,e)))})}function D8(r,t){return G(()=>{let e=Math.log(2),n=ut(t,r),o=ut(J(n,Hs(O(-2,n))),e);return ke(o,-1)})}function Tc(r,t,e=!1){return G(()=>{if(e)t=su(t);else{let n=ft(t,t.shape.length-1,!0);t=ct(t,n)}return t=Ir(t,ar(),1-ar()),Yt(ft(O(tt(r,"float32"),Sr(t)),t.shape.length-1))})}function ef(r,t,e=!1){return G(()=>{let n=tt(Gi(q$(r)),"int32");t=Ir(t,ar(),1-ar());let o=t.shape,s=F(Ri(n,o[o.length-1]),o);return Tc(s,t,e)})}function R8(r,t){if(!y.arraysEqual(r.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return G(()=>{let e=Rr(t),n=Yt($e(t));return J(ut(e,O(t,r)),Ql(or(n)))})}function rf(r,t){return G(()=>{let e;return e=Ir(t,ar(),1-ar()),e=Sr(ct(e,ut(1,e))),ke(R8(r,e),-1)})}function F8(r,t){return G(()=>{let e=Ir(r,ar(),1),n=Ir(t,ar(),1);return ft(O(r,Sr(ct(e,n))),-1)})}function O8(r,t){return G(()=>{let e=Sr(J(ar(),t));return ke(ut(t,O(r,e)),-1)})}function Fh(r,t){return G(()=>{let e=Dh(r,-1),n=Dh(t,-1),o=O(e,n);return Yt(ft(o,-1))})}var Rh={meanSquaredError:Zi,meanAbsoluteError:tf,meanAbsolutePercentageError:bu,meanSquaredLogarithmicError:_8,squaredHinge:E8,hinge:A8,categoricalHinge:$8,logcosh:D8,categoricalCrossentropy:Tc,sparseCategoricalCrossentropy:ef,binaryCrossentropy:rf,kullbackLeiblerDivergence:F8,poisson:O8,cosineProximity:Fh};function eb(r){if(typeof r=="string"){if(r in Rh)return Rh[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}else return r}function Oh(r,t){return G(()=>{let e=O(.5,br(t)),n=hc(Xe(t,e),r.dtype);return ke(Ar(r,n),-1)})}function Ph(r,t){return G(()=>hc(Ar(Oi(r,-1),Oi(t,-1)),"float32"))}function pD(r,t){return G(()=>tt(ft(Dr(Ar(r,1),Ar(t,1))),"float32"))}function P8(r,t){return G(()=>tt(ft(Dr(Ar(r,1),Ar(t,0))),"float32"))}function L8(r,t){return G(()=>tt(ft(Dr(Ar(r,0),Ar(t,1))),"float32"))}function VS(r,t){return G(()=>{let e=pD(r,t),n=L8(r,t),o=J(e,n);return tt(De(Xe(o,0),ct(e,o),0),"float32")})}function mD(r,t){return G(()=>{let e=pD(r,t),n=P8(r,t),o=J(e,n);return tt(De(Xe(o,0),ct(e,o),0),"float32")})}function nb(r,t){return rf(r,t)}function ob(r,t){return r.rank===t.rank&&(r=Mn(r,[r.rank-1])),t=Oi(t,-1),t.dtype!==r.dtype&&(t=tt(t,r.dtype)),tt(Ar(r,t),"float32")}var M8=Zi,z8=Zi,B8=tf,V8=tf,G8=bu,W8=bu,Lh=Tc,U8=Fh,GS=ef,rb={binaryAccuracy:Oh,categoricalAccuracy:Ph,precision:VS,categoricalCrossentropy:Lh,sparseCategoricalCrossentropy:GS,mse:M8,MSE:z8,mae:B8,MAE:V8,mape:G8,MAPE:W8,cosine:U8};function fD(r){if(typeof r=="string"&&r in rb)return rb[r];if(typeof r!="string"&&r!=null)return r;throw new z(`Unknown metric ${r}`)}function Mh(r){if(to(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Rh))if(Rh[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(rb))if(rb[e]===r){t=e;break}return t!==void 0?t:r.name}}function hD(r){let t={Adagrad:()=>fc.adagrad(.01),Adadelta:()=>fc.adadelta(1,.95,ar()),Adam:()=>fc.adam(.001,.9,.999,ar()),Adamax:()=>fc.adamax(.002,.9,.999,ar(),0),RMSProp:()=>fc.rmsprop(.001,.9,0,ar()),SGD:()=>fc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new z(`Unknown Optimizer ${r}`)}function US(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!WS(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function WS(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!WS(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!WS(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function gD(r,t,e,n=console.log){let o=K8(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in r.nodesByDepth)i.push(...r.nodesByDepth[c])}n("_".repeat(t)),sb(s,e,n),n("=".repeat(t));let a=r.layers;for(let c=0;c<a.length;++c)o?j8(a[c],e,n):X8(a[c],e,i,n),n((c===a.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=q8(r),l=jm(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(t))}function q8(r){let t;return r.collectedTrainableWeights!=null?t=jm(r.collectedTrainableWeights):t=jm(r.trainableWeights),t}function K8(r){let t=!0,e=[],n=[];for(let o in r.nodesByDepth)e.push(r.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of r.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function sb(r,t,e=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);e(n)}function j8(r,t,e){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch(u){o="multiple"}try{n=JSON.stringify(r.outputShape)}catch(u){n="multiple"}let s=r.name,i=r.getClassName(),a=[`${s} (${i})`,o,n,r.countParams().toString()];sb(a,t,e)}function X8(r,t,e,n){let o,s;try{s=r.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{o=JSON.stringify(r.outputShape)}catch(p){o="multiple"}let i=[];for(let p of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){let f=p.inboundLayers[m].name,d=p.nodeIndices[m],h=p.tensorIndices[m];i.push(`${f}[${d}][${h}]`)}let a=r.name,u=r.getClassName(),l=i.length===0?"":i[0],c=[`${a} (${u})`,s,o,r.countParams().toString(),l];sb(c,t,n);for(let p=1;p<i.length;++p)sb(["","","","",i[p]],t,n)}function xD(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function Nc(r,t){if(r===null)return null;if(typeof r=="string")return tl(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];xD(t,o,s)?e.push(s):e.push(Nc(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")e[n]=o;else{let s=tl(n);e[s]=Nc(o,s)}}return e}}function ib(r,t){if(r==null)return null;if(typeof r=="string")return vo(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];xD(t,o,s)?e.push(s):e.push(ib(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n],s=vo(n);(n==="name"||n==="className")&&typeof o=="string"?e[s]=o:e[s]=ib(o,n)}return e}}var nf="3.20.0";var zn=class extends Bt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=gu(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Io(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Io(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let w=b.sourceLayer,C=b.nodeIndex,T=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(T)}for(let b of this.inputs){let w=b.sourceLayer,C=b.nodeIndex,T=b.tensorIndex;to(C===0,"input layer has >1 nodes"),to(T===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(T)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let w=this.inputLayers[b];if(!(w instanceof Js))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let e={},n={},o={},s={},i={},a=[],u=(b,w,C,T,E,$)=>{(T==null||E==null||$==null)&&(T=b.sourceLayer,E=b.nodeIndex,$=b.tensorIndex);let D=T.inboundNodes[E];if(C.indexOf(D)!==-1)throw new Gr(`The tensor ${b.name} at layer "${T.name}" is part of a cycle.`);if(w.indexOf(D)!==-1)return;this.containerNodes.add(zn.nodeKey(T,E)),T.id in i||(i[T.id]=Object.keys(i).length),C.indexOf(D)===-1&&C.push(D);let P=D.inboundLayers.length;for(let M=0;M<P;M++){let W=D.inputTensors[M],H=D.inboundLayers[M],q=D.nodeIndices[M],X=D.tensorIndices[M];u(W,w,C,H,q,X)}for(w.push(D);C.indexOf(D)>=0;)C.splice(C.indexOf(D),1);a.push(D)},l=[],c=[];for(let b of this.outputs)u(b,l,c);let p=a.slice().reverse();for(let b of p){n[b.id]=b,b.id in e||(e[b.id]=0);let w=e[b.id],C=o[b.outboundLayer.id]==null?0:o[b.outboundLayer.id];w=Math.max(w,C),o[b.outboundLayer.id]=w,s[b.outboundLayer.id]=b.outboundLayer,e[b.id]=w;for(let T=0;T<b.inboundLayers.length;T++){let E=b.inboundLayers[T],$=b.nodeIndices[T],D=E.inboundNodes[$],P=e[D.id]==null?0:e[D.id];e[D.id]=Math.max(w+1,P),n[D.id]=D}}let m={};for(let b in e){let w=e[b];w in m||(m[w]=[]),m[w].push(n[b])}let f={};for(let b in o){let w=o[b];w in f||(f[w]=[]),f[w].push(s[b])}let d=Object.keys(f).map(b=>parseInt(b,10)).sort(kh);this.layers=[];for(let b of d){let w=f[b];w.sort((C,T)=>{let E=i[C.id],$=i[T.id];return E<$?-1:E>$?1:0});for(let C of w)C instanceof zn&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=f,d=Object.keys(m).map(b=>parseInt(b,10)).sort(kh);let h=this.inputs.slice(),g=[];for(let b of d)for(let w of m[b]){let C=w.outboundLayer;if(C!=null){for(let T of w.inputTensors)if(h.indexOf(T)===-1)throw new Gr(`Graph disconnected: cannot obtain value for tensor ${T} at layer "${C.name}". The following previous layers were accessed without issue: ${g}`);for(let T of w.outputTensors)h.push(T);g.push(C.name)}}this.nodesByDepth=m;let x=this.layers.map(b=>b.name);for(let b of x){let w=x.filter(C=>C===b).length;if(w!==1)throw new Gr(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new nl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let n={},o=0;for(let i of this.layers)for(let a of i.weights){if(n[a.originalName]!=null)throw new z(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,o++}let s=[];for(let i in t){let a=i;if(n[i]==null){let u=i.split("/");a=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],t[i]]);else if(e)throw new z(`Provided weight data has no target variable: ${i}`);delete n[a]}if(e){let i=[];for(let a in n)i.push(a);if(i.length>0)throw new z(`${i.length} of ${o} weights are not set: ${i}`)}Xm(s)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${nf}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let n=ib(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return G(()=>{t=be(t);let n=new No;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],t[o]);return Ic(this.outputs,n,e)})}computeMask(t,e){return G(()=>{t=be(t);let n;return e==null?n=Co(null,t.length):n=be(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let e=Km(t);if(e.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<e.length;a++){let u=this.inputLayers[a],l=e[a],c=u.name+"_0_0";n[c]=l}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(kh);if(o.length>1)for(let a of o){let u=this.nodesByDepth[a];for(let l of u){let c=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(c.id)!==-1)continue;let p=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],x=l.nodeIndices[h],b=l.tensorIndices[h],w=`${g.name}_${x}_${b}`,C=n[w];p.push(C)}let m=c.computeOutputShape(Nr(p)),f=Km(m),d=c.inboundNodes.indexOf(l);for(let h=0;h<f.length;h++){let g=`${c.name}_${d}_${h}`;n[g]=f[h]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${u.name}_${l}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let u=i[a];to(u in n),s.push(n[u])}return Nr(s)}runInternalGraph(t,e){e==null&&(e=Co(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],c=t[u],p=e[u];n[l.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(kh);for(let u of o){let l=this.nodesByDepth[u];for(let c of l){let p=c.outboundLayer,m=c.inputTensors,f=c.outputTensors,d=new Array;for(let h of m)h.id in n&&d.push(n[h.id]);if(d.length===m.length){let h={},g,x,b,w;if(c.callArgs!=null&&(h=c.callArgs),d.length===1){let[C,T]=d[0];h.mask==null&&(h.mask=T),b=be(p.call(C,h)),w=be(p.computeMask(C,T)),g=[C],x=[T]}else g=d.map(C=>C[0]),x=d.map(C=>C[1]),h.mask==null&&(h.mask=x),b=be(p.call(g,h)),w=be(p.computeMask(g,x));if(p.activityRegularizer)throw new Nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<f.length;++C){let T=f[C],E=b[C],$=w[C];n[T.id]=[E,$]}}}}let s=[],i=[],a=[];for(let u of this.outputs){to(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,c]=n[u.id];a.push(l.shape),s.push(l),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},n;for(let o of this.layers){n=o instanceof zn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=zn.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new z("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===t)return n;throw new z(`No such layer: ${t}`)}calculateLosses(){return G(()=>{let t=[];for(let e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){let o=zn.nodeKey(e,n);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),u=i.getConfig(),l=[];for(let p=0;p<i.inboundNodes.length;p++){let m=i.inboundNodes[p],f=zn.nodeKey(i,p),d={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),d=m.callArgs}catch(h){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let x=m.inboundLayers[g],b=m.nodeIndices[g],w=m.tensorIndices[g],C=zn.nodeKey(x,b),T=e[C];T==null&&(T=0),h.push([x.name,T,w,d])}l.push(h)}}}let c={};c.name=i.name,c.className=a,c.config=u,c.inboundNodes=l,n.push(c)}t.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=zn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=zn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,n={},o=!1){let s={},i={};function a(g,x){g.name in i?i[g.name].push(x):i[g.name]=[x]}function u(g,x){let b=[],w;for(let C of x){let T=C[0],E=C[1],$=C[2];if(w=C[3]==null?{}:C[3],!(T in s)){a(g,x);return}let D=s[T];if(D.inboundNodes.length<=E){a(g,x);return}let P=D.inboundNodes[E];b.push(P.outputTensors[$])}b.length>0&&g.apply(Nr(b),w)}function l(g){let x=g.name,b=xn(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(o),s[x]=b,g.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${C}`);a(b,C)})}let c=e.name,p=e.layers;for(let g of p)l(g);for(;!R$(i);)for(let g of p){let x=s[g.name];if(x.name in i){let b=i[x.name];delete i[x.name];for(let w of b)u(x,w)}}let m=[],f=[],d=e.inputLayers;for(let g of d){let x=g[0],b=g[1],w=g[2];to(x in s);let T=s[x].inboundNodes[b].outputTensors;m.push(T[w])}let h=e.outputLayers;for(let g of h){let x=g[0],b=g[1],w=g[2];to(x in s);let T=s[x].inboundNodes[b].outputTensors;f.push(T[w])}return new t({inputs:m,outputs:f,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){G(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function Y8(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return t.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function ab(r,t){return Y8(r,t,"classWeight")}async function lb(r,t,e,n){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=G(()=>{if(r.shape.length===1)return an(r);if(r.shape.length===2){if(r.shape[1]>1)return Oi(r,1);if(r.shape[1]===1)return F(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());_t(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Ve(i,"float32")}else return null}function yD(r,t){return O(r,t)}var Z8=32;function CD(r,t){let e,n,o=t;e=o.xs,n=o.ys,y.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=bD("input",r.inputNames,e),i=bD("output",r.outputNames,n),a=s[0].shape[0];y.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),y.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)y.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let u=0;u<i.length;u++)y.assert(i[u].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function bD(r,t,e){if(e instanceof Lt)return[e];if(Array.isArray(e))return y.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let o of t){if(e[o]==null)throw new z(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(e[o])}return n}}function J8(r){if(r.length===3)throw new Nt("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function vD(r,t,e){let n=e.batchesPerEpoch!=null;if(y.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),y.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),y.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),y.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),y.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(wD(e.validationData))y.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=J8(e.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let c=Qy(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:f}=tb(c,p,e.epochs,null,null,Q8(t,e),null,o,l);m.setModel(r),r.history=f,await m.onTrainBegin(),r.stopTraining_=!1;let d=e.initialEpoch==null?0:e.initialEpoch,h=await t.iterator();for(;d<e.epochs;){let g={};await m.onEpochBegin(d);let x=0,b=0;for(n||(h=await t.iterator());!n||x<e.batchesPerEpoch;){let w=await h.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:C,ys:T}=CD(r,w.value),E={};E.batch=b,E.size=C[0].shape[0],await m.onBatchBegin(b,E);let $=[];if(e.classWeight!=null){let M=ab(e.classWeight,r.outputNames);for(let W=0;W<M.length;++W)$.push(await lb(T[W],null,M[W]))}let D=C.concat(T).concat($),P=a(D);_t(D);for(let M=0;M<u.length;++M){let W=u[M],H=P[M];E[W]=H,Oe(H)}await m.onBatchEnd(b,E),Xy(E),b++,x++}if(n?x>=e.batchesPerEpoch:w.done){if(o){let C;wD(e.validationData)?C=be(await r.evaluateDataset(e.validationData,{batches:e.validationBatches})):C=be(r.evaluate(s,i,{batchSize:e.validationBatchSize==null?Z8:e.validationBatchSize,verbose:0}));for(let T=0;T<r.metricsNames.length;++T)g[`val_${r.metricsNames[T]}`]=C[T]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(d,g),d++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function Q8(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function wD(r){return typeof r.iterator=="function"}function tY(r){return typeof r.next=="function"}async function ID(r,t,e){e=e||{};let n=e.batches!=null,o=r.testFunction,s=[];if(e.verbose>0)throw new Nt("Verbose mode is not implemented yet.");y.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=tY(t)?t:await t.iterator(),a=0,u=0;for(;!n||u<e.batches;){let l=await i.next();if(s=G(()=>{if(l.value){let{xs:c,ys:p}=CD(r,l.value),m=c.concat(p),f=G(()=>o(m));if(_t(m),u===0)for(let h=0;h<f.length;++h)s.push(mt(0));let d=m[0].shape[0];for(let h=0;h<f.length;++h){let g=f[h],x=s[h];s[h]=G(()=>J(s[h],O(d,g))),u>0&&_t(x)}_t(f),a+=d,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let c=s[l];s[l]=ct(s[l],a),_t(c)}return Nr(s)}function ub(r){y.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function of(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>el(n,t,e-t)):el(r,t,e-t)}function cb(r,t){return G(()=>r==null?null:Array.isArray(r)?r.map(e=>cb(e,t)):Wy(r,t.dtype==="int32"?t:tt(t,"int32")))}function pb(r,t){let e=[],n=0,o=null;for(;n<r;)o=n+t,o>=r&&(o=r),e.push([n,o]),n=o;return e}async function eY(r,t,e,n,o,s,i,a,u,l,c,p,m,f,d){o==null&&(o=32),s==null&&(s=1),c==null&&(c=!0),m==null&&(m=0);let h=!1;if(u!=null&&l!=null&&(h=!0),d!=null&&(h=!0,f==null))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(e,o,f,"steps_per_epoch"),x;g!=null&&(x=jr(0,g)),i==null&&(i=1);let{callbackList:b,history:w}=tb(a,i,s,m,g,f,o,h,p);b.setModel(r),r.history=w,await b.onTrainBegin(),r.stopTraining_=!1;for(let C=m;C<s;++C){await b.onEpochBegin(C);let T={};if(f!=null)throw new Nt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Nt("batch shuffling is not implemneted yet");c&&y.shuffle(x);let E=Ve(x),$=pb(g,o);for(let D=0;D<$.length;++D){let P={};if(await b.onBatchBegin(D,P),G(()=>{let M=$[D][0],W=$[D][1],H=el(E,M,W-M);P.batch=D,P.size=W-M;let q=cb(e,H),X=t(q);for(let j=0;j<n.length;++j){let Z=n[j],et=X[j];P[Z]=et,Oe(et)}if(D===$.length-1&&h){let j=r.testLoop(u,l,o);for(let Z=0;Z<n.length;++Z){let et=n[Z],K=j[Z];Oe(K),T["val_"+et]=K}}}),await b.onBatchEnd(D,P),Xy(P),r.stopTraining_)break}E.dispose()}if(await b.onEpochEnd(C,T),r.stopTraining_)break}return await b.onTrainEnd(),await r.history.syncData(),r.history}async function SD(r,t,e,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,i,a,u,l,c,p,m;try{let f=n.batchSize==null?32:n.batchSize;ub(f);let d=!1,h=await r.standardizeUserData(t,e,n.sampleWeight,n.classWeight,d,f);o=h[0],s=h[1],m=h[2];let g=!1,x;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Nt("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let P=!0,M=await r.standardizeUserData(u,l,null,null,P,f);c=M[0],p=M[1],x=c.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let P=Math.floor(o[0].shape[0]*(1-n.validationSplit)),M=o[0].shape[0];c=of(o,P,M),i=o,o=of(o,0,P),p=of(s,P,M),a=s,s=of(s,0,P),x=c.concat(p)}else n.validationSteps!=null&&(g=!0);let b=o.concat(s).concat(m);r.checkTrainableWeightsConsistency();let w=r.makeTrainFunction(),C=r.getDedupedMetricsNames(),T,E;g?(r.makeTestFunction(),T=r.testFunction,E=C.slice().concat(C.map(P=>"val_"+P))):(T=null,x=[],E=C.slice());let $=Qy(n.callbacks,n.yieldEvery);return await eY(r,w,b,C,f,n.epochs,n.verbose,$,T,x,n.shuffle,E,n.initialEpoch,null,null)}finally{r.isTraining=!1,ko(o,t),ko(s,e),ko(i,t),ko(a,e),ko(c,u),ko(p,l),m!=null&&_t(m)}}function HS(r){let t=[];r instanceof Lt&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(rl(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function ko(r,t){if(r==null)return;let e=[];if(t instanceof Lt)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let n=[];if(r instanceof Lt)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{e.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];e.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function rY(r){return r instanceof Lt}function qS(r){return Array.isArray(r)}function TD(r){return!rY(r)&&!qS(r)}function ND(r,t,e,n=!0,o=""){if(t==null||t.length===0){if(r!=null){let i=!1;if(qS(r)&&r.length>0)i=!0;else if(TD(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(i=>null);let s;if(TD(r)){r=r,s=[];for(let i of t){if(r[i]==null)throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(r[i])}}else if(qS(r)){if(r=r,r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new z(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=HS(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c>=0&&l!==c)throw new z(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function nY(r,t,e){let n=Io(r.map(s=>s.shape[0]));n.sort();let o=Io(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!y.arraysEqual(n,o))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function oY(r,t,e){let n=[Zi,rf,Tc];for(let o=0;o<r.length;++o){let s=r[o],i=t[o],a=e[o];if(i!=null){if(i===Tc&&s.shape[s.shape.length-1]===1)throw new z(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){let p=u[c],m=l[c];if(m!=null&&p!==m)throw new z(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function kD(r,t,e,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new z(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c!==l)throw new z(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function sY(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var iY="layers-model",Bn=class extends zn{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");gD(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=hD(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Br))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new z(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),e.push(eb(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>eb(a))}else{let i=eb(t.loss);this.outputs.forEach(a=>{e.push(i)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ys("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let o=sY(t.metrics,this.outputNames),s=(i,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,i])};Ys("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=o[i];(l=>{let c="",p,m,f;for(let d of l){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===rf?["accuracy","acc"].indexOf(d)!==-1?m=Oh:["crossentropy","ce"].indexOf(d)!==-1&&(m=nb):this.lossFunctions[i]===ef?["accuracy","acc"].indexOf(d)!==-1?m=ob:["crossentropy","ce"].indexOf(d)!==-1&&(m=GS):["accuracy","acc"].indexOf(d)!==-1?m=Ph:["crossentropy","ce"].indexOf(d)!==-1&&(m=Lh);let x;["accuracy","acc"].indexOf(d)!==-1?x="acc":["crossentropy","ce"].indexOf(d)!==-1&&(x="ce"),f=m,p=c+x}else f=fD(d),p=c+Mh(d);let h;Ys(p,()=>{h=f}),s(i,p,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){let o=n.batchSize==null?32:n.batchSize;ub(o);let s=!0,i=this.standardizeUserDataXY(t,e,s,o);try{let a=i[0].concat(i[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,a,o,n.verbose,n.steps);return Nr(l)}finally{ko(i[0],t),ko(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),ID(this,t,e)}checkNumSamples(t,e,n,o="steps"){let s;if(n!=null){if(s=null,e!=null)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new z("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(e),o=n?e:[e],s=this.retrieveSymbolicTensors(o),i=new No;if(t instanceof Lt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new z(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],t[u])}else for(let u of this.inputs){let l=t[u.name];if(l==null)throw new z(`No value is provided for the model's input ${u.name}`);i.add(u,l)}let a=Ic(s,i);return n?a:a[0]}retrieveSymbolicTensors(t){let e=Co(null,t.length),n=t.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],i=s.map(a=>a.name);for(let a=0;a<t.length;++a){let u=i.indexOf(t[a]);if(u!==-1&&(e[a]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw e.forEach((s,i)=>{s==null&&o.push(t[i])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return e}predictLoop(t,e=32,n=!1){return G(()=>{let o=this.checkNumSamples(t);if(n)throw new Nt("Verbose predictLoop() is not implemented yet.");let s=pb(o,e),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)G(()=>{let l=s[a][0],c=s[a][1],p=of(t,l,c),m=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)m.push({key:this.inputs[d],value:p[d]});else m.push({key:this.inputs[0],value:p});let f=new No(m);return Ic(this.outputs,f)}).forEach((l,c)=>i[c].push(l));return Nr(i.map(a=>se(a,0)))})}predict(t,e={}){let n=HS(t);kD(n,this.inputNames,this.feedInputShapes,!1);try{let o=e.batchSize==null?32:e.batchSize;return ub(o),this.predictLoop(n,o)}finally{ko(n,t)}}predictOnBatch(t){kD(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,o){if(this.optimizer_==null)throw new Gr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===ef?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(t=ND(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=ND(e,this.feedOutputNames,s,!1,"target"),nY(t,e,null),oY(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&t[0].shape[0]%o!==0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,o,s=!0,i){let[a,u]=this.standardizeUserDataXY(t,e,s,i);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let c=ab(o,this.outputNames);l=[];for(let p=0;p<c.length;++p)l.push(await lb(u[p],null,c[p]))}return[a,u,l]}testLoop(t,e,n,o=0,s){return G(()=>{let i=this.checkNumSamples(e,n,s,"steps"),a=[];if(o>0)throw new Nt("Verbose mode is not implemented yet.");if(s!=null)throw new Nt("steps mode in testLoop() is not implemented yet");{let u=pb(i,n),l=Ve(jr(0,i));for(let c=0;c<u.length;++c){let p=u[c][0],m=u[c][1],f=el(l,p,m-p),d=cb(e,f),h=t(d);if(c===0)for(let g=0;g<h.length;++g)a.push(mt(0));for(let g=0;g<h.length;++g){let x=h[g];a[g]=J(a[g],O(m-p,x))}}for(let c=0;c<a.length;++c)a[c]=ct(a[c],i)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){let o=t[n],s=o;DS(t,o)>1&&(s+=`_${DS(t.slice(0,n),o)}`),e.push(s)}return e}makeTrainFunction(){return t=>{let e=[],n=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let p=[];for(let h=0;h<this.inputs.length;++h)p.push({key:this.inputs[h],value:n[h]});let m=new No(p),f=Ic(this.outputs,m,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let g=this.lossFunctions[h],x=g(o[h],f[h]);s[h]!=null&&(x=yD(x,s[h]));let b=ke(x);e.push(b),h===0?d=x:d=J(d,x)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=e[h];else{let x=this.metricsTensors[h][0],b=this.metricsTensors[h][1];g=ke(x(o[b],f[b]))}Oe(g),i.push(g)}return d=ke(d),this.calculateLosses().forEach(h=>{d=J(d,h)}),d},u=this.collectedTrainableWeights.map(p=>p.read()),l=!0;return[this.optimizer_.minimize(a,l,u)].concat(i)}}makeTestFunction(){this.testFunction=t=>G(()=>{let e=[],n,o=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:o[l]});let a=new No(i),u=Ic(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],p=ke(c(s[l],u[l]));l===0?n=p:n=J(n,p),e.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],p=this.metricsTensors[l][1],m=ke(c(s[p],u[p]));e.push(m)}return e})}async fit(t,e,n={}){return SD(this,t,e,n)}async fitDataset(t,e){return vD(this,t,e)}async trainOnBatch(t,e){let n=await this.standardizeUserData(t,e),o=n[0],s=n[1],a=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of a){let c=await l.data();u.push(c[0])}return _t(a),ko(n[0],t),ko(n[1],e),Nr(u)}getNamedWeights(t){let e=[],n=t!=null&&t.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<o.length;++i)n&&!o[i].trainable||e.push({name:o[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=xh().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-xh().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=vo(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>vo(e))}else{let e=Object.keys(this.loss);t={};let n=this.loss;for(let o of e)if(typeof n[o]=="string")t[o]=vo(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[vo(Mh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>vo(Mh(t)));{let t={};for(let e in this.metrics)t[e]=vo(Mh(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Nc(t.optimizer_config),n=xn(e),o;if(typeof t.loss=="string")o=tl(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(i=>tl(i));else if(t.loss!=null){o={};for(let i in t.loss)o[i]=tl(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>tl(i));else if(t.metrics!=null){s={};for(let i in t.metrics)s[i]=tl(t.metrics[i])}this.compile({loss:o,metrics:s,optimizer:n})}async save(t,e){if(typeof t=="string"){let l=vn.getSaveHandlers(t);if(l.length===0)throw new z(`Cannot find any save handlers for URL '${t}'`);if(l.length>1)throw new z(`Found more than one (${l.length}) save handlers for URL '${t}'`);t=l[0]}if(t.save==null)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await vn.encodeWeights(this.getNamedWeights(e)),o=!1,s=null,a={modelTopology:this.toJSON(s,o),format:iY,generatedBy:`TensorFlow.js tfjs-layers v${nf}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:c,specs:p}=await vn.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...p),n.data=vn.concatenateArrayBuffers([n.data,c])}return this.userDefinedMetadata!=null&&(US(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,t.save(a)}setUserDefinedMetadata(t){US(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};Bn.className="Model";rt.registerClass(Bn);var mb=class extends Bn{};mb.className="Functional";rt.registerClass(mb);async function _D(r,t){"modelTopology"in r||(r={modelTopology:r}),r=r;let e=r.modelTopology;e.model_config!=null&&(e=e.model_config);let n=Nc(e),o=xn(n,t);if(r.weightsManifest!=null){let s=await vn.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(a=>a.originalName)),i={};for(let a of o.weights)i[a.originalName]=s[a.originalName];o.loadWeights(i),_t(s)}return o}async function ED(r,t){if(t==null&&(t={}),typeof r=="string"){let e=vn.getLoadHandlers(r,t);if(e.length===0)e.push(vn.browserHTTPRequest(r,t));else if(e.length>1)throw new z(`Found more than one (${e.length}) load handlers for URL '${r}'`);r=e[0]}return aY(r,void 0,t)}async function aY(r,t,e){if(e==null&&(e={}),r.load==null)throw new z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=e.strict==null?!0:e.strict,i=n.weightData!=null&&n.weightSpecs!=null&&s,a=xn(Nc(o),t,i),u=n.trainingConfig;if(u!=null&&a.loadTrainingConfig(u),n.userDefinedMetadata!=null&&a.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:c}=lY(n.weightData,n.weightSpecs);a.loadWeights(l,s),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),_t(l),_t(c.map(p=>p.tensor))}return a}function lY(r,t){let e=vn.decodeWeights(r,t),n={},o=[];return t.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:e[s.name]}):n[s.name]=e[s.name]}),{modelWeights:n,optimizerWeights:o}}var Ji=class extends Bn{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:gu("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new z(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Ji||t instanceof Bn,n;if(e){if(n=t,n.outputs.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=qy({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=MS(this.outputs[0])}this.inboundNodes=[],new nl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Co(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(te(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Bn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},o=!1){let s,i={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new z("Legacy serialization format not supported yet.");s=e}else y.assert(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,i=e;let a=new t(i);if(!(a instanceof Ji))throw new Nt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let u of s){let c=xn(u,void 0,o);o&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}};Ji.className="Sequential";rt.registerClass(Ji);function uY(r){return new Bn(r)}function cY(r){return new Ji(r)}function pY(r,t){return t==null&&(t={}),ED(r,t)}function KS(r){return qy(r)}function mY(r,t){gn.registerCallbackConstructor(r,t)}var Yr=class extends rt.Serializable{getConfig(){return{}}},fb=class extends Yr{apply(t,e=1){return j$(t,e)}};fb.className="elu";rt.registerClass(fb);var db=class extends Yr{apply(t){return Sm(t)}};db.className="selu";rt.registerClass(db);var hb=class extends Yr{apply(t){return Rr(t)}};hb.className="relu";rt.registerClass(hb);var gb=class extends Yr{apply(t){return G(()=>Ui(6,Rr(t)))}};gb.className="relu6";rt.registerClass(gb);var xb=class extends Yr{apply(t){return t}};xb.className="linear";rt.registerClass(xb);var yb=class extends Yr{apply(t){return Kr(t)}};yb.className="sigmoid";rt.registerClass(yb);var bb=class extends Yr{apply(t){return Y$(t)}};bb.className="hardSigmoid";rt.registerClass(bb);var wb=class extends Yr{apply(t){return Hs(t)}};wb.className="softplus";rt.registerClass(wb);var Cb=class extends Yr{apply(t){return X$(t)}};Cb.className="softsign";rt.registerClass(Cb);var vb=class extends Yr{apply(t){return Pi(t)}};vb.className="tanh";rt.registerClass(vb);var sf=class extends Yr{apply(t,e=-1){return su(t,e)}};sf.className="softmax";rt.registerClass(sf);var Ib=class extends Yr{apply(t,e=-1){return ym(t,e)}};Ib.className="logSoftmax";rt.registerClass(Ib);var Sb=class extends Yr{apply(t,e=1){return G(()=>O(Kr(O(t,e)),t))}};Sb.className="swish";rt.registerClass(Sb);var Tb=class extends Yr{apply(t){return G(()=>O(t,Pi(Hs(t))))}};Tb.className="mish";rt.registerClass(Tb);function Qs(r){return r.getClassName()}function jS(r,t={}){return ji(r,rt.SerializationMap.getMap().classNameMap,t,"activation")}function ti(r){if(r==null){let t={};return t.className="linear",t.config={},jS(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},jS(t)}else return r instanceof Yr?r:jS(r)}function XS(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var Nb=class extends rt.Serializable{},wu=class extends Nb{constructor(t){super(),XS(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return G(()=>{let e=_e([1]);return this.hasL1&&(e=J(e,ft(O(this.l1,$e(t))))),this.hasL2&&(e=J(e,ft(O(this.l2,gc(t))))),F(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};wu.className="L1L2";rt.registerClass(wu);function DD(r){return XS(r),new wu({l1:r!=null?r.l1:null,l2:0})}function RD(r){return XS(r),new wu({l2:r!=null?r.l2:null,l1:0})}var AD={l1l2:"L1L2"};function de(r){return Pm(r)}function $D(r,t={}){return ji(r,rt.SerializationMap.getMap().classNameMap,t,"regularizer")}function Ce(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in AD?AD[r]:r,config:{}};return $D(e)}else return r instanceof Nb?r:$D(r)}var af=class extends Bt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Pt(t);let n=Rr(t);return this.maxValue!=null&&(n=Ir(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};af.className="ReLU";rt.registerClass(af);var lf=class extends Bt{constructor(t){super(t==null?{}:t),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Pt(t);return Jl(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};lf.className="LeakyReLU";rt.registerClass(lf);var uf=class extends Bt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=ge(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ce(t.alphaRegularizer),this.alphaConstraint=We(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=te(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)e[o-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<t.length;++o)n[o]=t[o];this.inputSpec=[new we({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=Pt(t),nu(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Ee(this.alphaInitializer),alphaRegularizer:de(this.alphaRegularizer),alphaConstraint:Ge(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};uf.className="PReLU";rt.registerClass(uf);var cf=class extends Bt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Nt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Pt(t);return Bi(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};cf.className="ELU";rt.registerClass(cf);var pf=class extends Bt{constructor(t){super(t==null?{}:t),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let n=Pt(t);return O(n,tt(Xe(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};pf.className="ThresholdedReLU";rt.registerClass(pf);var mf=class extends Bt{constructor(t){super(t==null?{}:t),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new sf().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let n=Pt(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};mf.className="Softmax";rt.registerClass(mf);function Cu(r,t,e){if(typeof r=="number")return Co(r,t);if(r.length!==t)throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let o=r[n];if(!U$(o))throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function kn(r,t,e,n,o=1){if(r==null)return r;let s=t+(t-1)*(o-1),i;return e==="same"?i=r:i=r-s+1,Math.floor((i+n-1)/n)}function ei(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+Zs([e-t,0]);else if(n==="same")r=r*t;else throw new z(`Unsupport padding mode: ${n}.`);return r}function zh(r,t){return G(()=>(Pe(t),t==="channelsFirst"?Mt(r,[0,2,3,1]):r))}function YS(r,t){return G(()=>(Pe(t),t==="channelsFirst"?Mt(r,[0,2,3,4,1]):r))}function dY(r,t,e,n=1,o="valid",s,i=1){return G(()=>{if(s==null&&(s=mn()),Pe(s),r.shape.length!==3)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(r=Mt(r,[0,2,1])),o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=mm(r,t,n,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=fn(a,e)),a})}function FD(r,t,e,n=[1,1],o="valid",s,i,a=null){return G(()=>{if(s==null&&(s=mn()),Pe(s),r.rank!==3&&r.rank!==4)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=zh(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=lu.conv2d({x:u,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(u=Mt(u,[0,3,1,2])),u})}function hY(r,t,e,n=[1,1,1],o="valid",s,i){return G(()=>{if(s==null&&(s=mn()),Pe(s),r.rank!==4&&r.rank!==5)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=YS(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Bx(a,t,n,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=fn(a,e)),s==="channelsFirst"&&(a=Mt(a,[0,4,1,2,3])),a})}var kc=class extends Bt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",kc.verifyArgs(e),this.rank=t,Je(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Cu(e.kernelSize,t,"kernelSize"),this.strides=Cu(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,pn(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pe(this.dataFormat),this.activation=ti(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=ge(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=We(e.biasConstraint),this.biasRegularizer=Ce(e.biasRegularizer),this.activityRegularizer=Ce(e.activityRegularizer),this.dilationRate=Cu(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(to("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Oy(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Qs(this.activation),useBias:this.useBias,biasInitializer:Ee(this.biasInitializer),biasRegularizer:de(this.biasRegularizer),activityRegularizer:de(this.activityRegularizer),biasConstraint:Ge(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},vu=class extends kc{constructor(t,e){super(t,e),this.kernel=null,vu.verifyArgs(e),this.filters=e.filters,Je(this.filters,"filters"),this.kernelInitializer=ge(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=We(e.kernelConstraint),this.kernelRegularizer=Ce(e.kernelRegularizer)}build(t){t=te(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[e]}`);let n=t[e],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return G(()=>{t=Pt(t);let n,o=this.bias==null?null:this.bias.read(),s=Py(this.activation.getClassName());if(s!=null&&this.rank===2)n=FD(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=dY(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=FD(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=hY(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Nt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=te(t);let e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=kn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let t={filters:this.filters,kernelInitializer:Ee(this.kernelInitializer),kernelRegularizer:de(this.kernelRegularizer),kernelConstraint:Ge(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},sl=class extends vu{constructor(t){super(2,t),sl.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Oy(t.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};sl.className="Conv2D";rt.registerClass(sl);var il=class extends vu{constructor(t){super(3,t),il.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};il.className="Conv3D";rt.registerClass(il);var ff=class extends sl{constructor(t){if(super(t),this.inputSpec=[new we({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=te(t),t.length!==4)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new we({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return G(()=>{let n=Pt(t);if(n.shape.length!==4)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let u=o[i],l=o[a],c=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],f=this.strides[1],d=ei(u,m,c,this.padding),h=ei(l,f,p,this.padding),g=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Mt(n,[0,2,3,1]));let x=dm(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=Mt(x,[0,3,1,2])),this.bias!=null&&(x=fn(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(t){t=te(t);let e=t.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[o]=ei(e[o],u,i,this.padding),e[s]=ei(e[s],l,a,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};ff.className="Conv2DTranspose";rt.registerClass(ff);var df=class extends il{constructor(t){if(super(t),this.inputSpec=[new we({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=te(t),t.length!==5)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new we({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return G(()=>{let n=Pt(t);if(n.shape.length!==5)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a,u;this.dataFormat==="channelsFirst"?(u=2,i=3,a=4):(u=1,i=2,a=3);let l=o[u],c=o[i],p=o[a],m=this.kernelSize[0],f=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],g=this.strides[1],x=this.strides[2],b=ei(l,h,m,this.padding),w=ei(c,g,f,this.padding),C=ei(p,x,d,this.padding),T=[s,b,w,C,this.filters];this.dataFormat!=="channelsLast"&&(n=Mt(n,[0,2,3,4,1]));let E=Gx(n,this.kernel.read(),T,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Mt(E,[0,4,1,2,3])),this.bias!==null&&(E=fn(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(t){t=te(t);let e=t.slice(),n,o,s,i;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,i=4):(n=4,o=1,s=2,i=3);let a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],p=this.strides[1],m=this.strides[2];return e[n]=this.filters,e[o]=ei(e[o],c,a,this.padding),e[s]=ei(e[s],p,u,this.padding),e[i]=ei(e[i],m,l,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};df.className="Conv3DTranspose";rt.registerClass(df);var kb=class extends vu{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ge(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ce(e.depthwiseRegularizer),this.depthwiseConstraint=We(e.depthwiseConstraint),this.pointwiseInitializer=ge(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ce(e.pointwiseRegularizer),this.pointwiseConstraint=We(e.pointwiseConstraint)}build(t){if(t=te(t),t.length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let n=t[e],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new we({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return G(()=>{t=Pt(t);let n;if(this.rank===1)throw new Nt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Mt(t,[0,2,3,1])),n=Tm(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=fn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Mt(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ee(this.depthwiseInitializer),t.pointwiseInitializer=Ee(this.pointwiseInitializer),t.depthwiseRegularizer=de(this.depthwiseRegularizer),t.pointwiseRegularizer=de(this.pointwiseRegularizer),t.depthwiseConstraint=Ge(this.depthwiseConstraint),t.pointwiseConstraint=Ge(this.pointwiseConstraint),t}};kb.className="SeparableConv";var hf=class extends kb{constructor(t){super(2,t)}};hf.className="SeparableConv2D";rt.registerClass(hf);var Iu=class extends vu{constructor(t){super(1,t),Iu.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Oy(t.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};Iu.className="Conv1D";rt.registerClass(Iu);var gf=class extends Bt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return G(()=>{if(t=Pt(t),this.dataFormat==="channelsLast"){let n=Eh(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Eh(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Eh(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Eh(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};gf.className="Cropping2D";rt.registerClass(gf);var xf=class extends Bt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Pe(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,G$(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{let e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return G(()=>{let n=Pt(t),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Mt(n,[0,2,3,1]);let s=this.size[0]*o[2],i=this.size[1]*o[3],a=this.interpolation==="nearest"?uu.resizeNearestNeighbor(n,[s,i]):uu.resizeBilinear(n,[s,i]);return Mt(a,[0,3,1,2])}else{let s=this.size[0]*o[1],i=this.size[1]*o[2];return this.interpolation==="nearest"?uu.resizeNearestNeighbor(n,[s,i]):uu.resizeBilinear(n,[s,i])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}};xf.className="UpSampling2D";rt.registerClass(xf);function gY(r,t,e=[1,1],n="valid",o,s){return G(()=>{o==null&&(o=mn()),Pe(o);let i=zh(r,o);if(r.rank!==4)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=zi(i,t,e,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Mt(i,[0,3,1,2])),i})}var yf=class extends kc{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ge(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=We(t.depthwiseConstraint),this.depthwiseRegularizer=Ce(t.depthwiseRegularizer)}build(t){if(t=te(t),t.length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let n=t[e],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return G(()=>{t=Pt(t);let n=gY(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=fn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=te(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=kn(e,this.kernelSize[0],this.padding,this.strides[0]),i=kn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],o,s,i]:[t[0],s,i,o]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ee(this.depthwiseInitializer),t.depthwiseRegularizer=de(this.depthwiseRegularizer),t.depthwiseConstraint=Ge(this.depthwiseRegularizer),t}};yf.className="DepthwiseConv2D";rt.registerClass(yf);function ZS(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new z("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:r,initialState:t,constants:e}}function JS(r,t,e,n=!1,o,s,i=!1,a=!1){return G(()=>{let u=t.shape.length;if(u<3)throw new z(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(jr(2,u));if(t=Mt(t,l),s!=null)throw new Nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=tt(tt(o,"bool"),"float32"),o.rank===u-1&&(o=yr(o,-1)),o=Mt(o,l)),n&&(t=pr(t,0),o!=null&&(o=pr(o,0)));let c=[],p,m=e,f=t.shape[0],d=Tr(t),h;o!=null&&(h=Tr(o));for(let x=0;x<f;++x){let b=d[x],w=G(()=>r(b,m));if(o==null)p=w[0],m=w[1];else{let C=G(()=>{let T=h[x],E=ut(br(T),T),$=J(O(w[0],T),O(m[0],E)),D=m.map((P,M)=>J(O(w[1][M],T),O(P,E)));return{output:$,newStates:D}});p=C.output,m=C.newStates}a&&c.push(p)}let g;return a&&(g=sr(c,1)),[p,g,m]})}var _n=class extends Bt{constructor(t){super(t);let e;if(t.cell==null)throw new z("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Ac({cells:t.cell}):e=t.cell,e.stateSize==null)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new we({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return jr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Hy(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let n=e[0],o;if(this.returnSequences?o=[t[0],t[1],n]:o=[t[0],n],this.returnState){let s=[];for(let i of e)s.push([t[0],i]);return[o].concat(s)}else return o}computeMask(t,e){return G(()=>{Array.isArray(e)&&(e=e[0]);let n=this.returnSequences?e:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Nt("Constants support is not implemented in RNN yet.");Hy(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new we({shape:[n,null,...o]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!y.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new we({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){G(()=>{if(!this.stateful)throw new Nn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>_e([n,o])):this.states_=[_e([n,this.cell.stateSize])];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>_e([n,o])):this.states_[0]=_e([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let o=0;o<this.states_.length;++o){let s=t[o],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,a=[n,i];if(!y.arraysEqual(s.shape,a))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Oe(o.clone()))})}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=ZS(t,n,o,this.numConstants);t=s.inputs,n=s.initialState,o=s.constants;let i=[],a=[];if(n!=null){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new we({shape:l.shape}));a=a.concat(this.stateSpec)}if(o!=null&&(e.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof Xr){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return G(()=>{let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;t=Pt(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new z(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:o},l=JS((d,h)=>{let g=this.cell.call([d].concat(h),a);return[g[0],g.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=l[0],p=l[1],m=l[2];this.stateful&&this.resetStates(m,o);let f=this.returnSequences?p:c;return this.returnState?[f].concat(m):f})}getInitialState(t){return G(()=>{let e=_e(t.shape);return e=ft(e,[1,2]),e=rl(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Gy(e,[1,n]):e):this.cell.stateSize>1?[Gy(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===_n.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){let o=e.cell,s=xn(o,n);return new t(Object.assign(e,{cell:s}))}};_n.className="RNN";rt.registerClass(_n);var al=class extends Bt{},_c=class extends al{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Je(this.units,"units"),this.activation=ti(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ge(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ge(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ge(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=We(t.kernelConstraint),this.recurrentConstraint=We(t.recurrentConstraint),this.biasConstraint=We(t.biasConstraint),this.dropout=dc([1,Zs([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dc([1,Zs([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=te(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return G(()=>{if(t=t,t.length!==2)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let o=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ul({ones:()=>br(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ul({ones:()=>br(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=To(O(t,i),this.kernel.read()):s=To(t,this.kernel.read()),this.bias!=null&&(s=fn(s,this.bias.read())),a!=null&&(n=O(n,a));let u=J(s,To(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Qs(this.activation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:de(this.kernelRegularizer),recurrentRegularizer:de(this.recurrentRegularizer),biasRegularizer:de(this.biasRegularizer),activityRegularizer:de(this.activityRegularizer),kernelConstraint:Ge(this.kernelConstraint),recurrentConstraint:Ge(this.recurrentConstraint),biasConstraint:Ge(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}};_c.className="SimpleRNNCell";rt.registerClass(_c);var bf=class extends _n{constructor(t){t.cell=new _c(t),super(t)}call(t,e){return G(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return new t(e)}};bf.className="SimpleRNN";rt.registerClass(bf);var Ec=class extends al{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Je(this.units,"units"),this.activation=ti(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ti(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ge(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ge(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ge(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=We(t.kernelConstraint),this.recurrentConstraint=We(t.recurrentConstraint),this.biasConstraint=We(t.biasConstraint),this.dropout=dc([1,Zs([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dc([1,Zs([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=te(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return G(()=>{if(t=t,t.length!==2)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training==null?!1:e.training,o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ul({ones:()=>br(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ul({ones:()=>br(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,u,l;0<this.dropout&&this.dropout<1&&(t=O(t,s[0]));let c=To(t,this.kernel.read());this.useBias&&(c=fn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=O(o,i[0]));let p=this.recurrentKernel.read(),[m,f]=mr(p,[2*this.units,this.units],p.rank-1),d=To(o,m),[h,g,x]=mr(c,3,c.rank-1),[b,w]=mr(d,2,d.rank-1);a=this.recurrentActivation.apply(J(h,b)),u=this.recurrentActivation.apply(J(g,w));let C=To(O(u,o),f);l=this.activation.apply(J(x,C));let T=J(O(a,o),O(J(1,Yt(a)),l));return[T,T]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Qs(this.activation),recurrentActivation:Qs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:de(this.kernelRegularizer),recurrentRegularizer:de(this.recurrentRegularizer),biasRegularizer:de(this.biasRegularizer),activityRegularizer:de(this.activityRegularizer),kernelConstraint:Ge(this.kernelConstraint),recurrentConstraint:Ge(this.recurrentConstraint),biasConstraint:Ge(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}};Ec.className="GRUCell";rt.registerClass(Ec);var wf=class extends _n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Ec(t),super(t)}call(t,e){return G(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};wf.className="GRU";rt.registerClass(wf);var ll=class extends al{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Je(this.units,"units"),this.activation=ti(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ti(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ge(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ge(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ge(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=We(t.kernelConstraint),this.recurrentConstraint=We(t.recurrentConstraint),this.biasConstraint=We(t.biasConstraint),this.dropout=dc([1,Zs([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dc([1,Zs([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=te(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;o=new(e=class extends hn{apply(u,l){let c=s.apply([i]),p=new yu().apply([i]),m=s.apply([i*2]);return LS(LS(c,p),m)}},e.className="CustomInit",e)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return G(()=>{let n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1],s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ul({ones:()=>br(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ul({ones:()=>br(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,u,l,c,p;0<this.dropout&&this.dropout<1&&(t=O(t,i[0]));let m=To(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=O(o,a[0])),m=J(m,To(o,this.recurrentKernel.read())),this.useBias&&(m=fn(m,this.bias.read()));let[f,d,h,g]=mr(m,4,m.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(d),c=J(O(l,s),O(u,this.activation.apply(h))),p=this.recurrentActivation.apply(g);let x=O(p,this.activation.apply(c));return[x,x,c]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Qs(this.activation),recurrentActivation:Qs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:de(this.kernelRegularizer),recurrentRegularizer:de(this.recurrentRegularizer),biasRegularizer:de(this.biasRegularizer),activityRegularizer:de(this.activityRegularizer),kernelConstraint:Ge(this.kernelConstraint),recurrentConstraint:Ge(this.recurrentConstraint),biasConstraint:Ge(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}};ll.className="LSTMCell";rt.registerClass(ll);var Cf=class extends _n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new ll(t),super(t)}call(t,e){return G(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};Cf.className="LSTM";rt.registerClass(Cf);var Ac=class extends al{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return G(()=>{t=t;let n=t.slice(1),o=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?o.push(n.splice(0,a.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let u=this.cells[a];n=o[a],a===0?i=[t[0]].concat(n):i=[i[0]].concat(n),i=u.call(i,e),s.push(i.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[i[0]].concat(n)})}build(t){Hy(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,o)=>{Ys(`RNNCell_${o}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(e)};return Object.assign({},t,o)}static fromConfig(t,e,n={}){let o=[];for(let s of e.cells)o.push(xn(s,n));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return $h(t)}setWeights(t){let e=[];for(let n of this.cells){let o=n.weights.length,s=t.splice(o);for(let i=0;i<n.weights.length;++i)e.push([n.weights[i],s[i]])}Xm(e)}};Ac.className="StackedRNNCells";rt.registerClass(Ac);function ul(r){let{ones:t,rate:e,training:n=!1,count:o=1,dropoutFunc:s}=r,i=()=>s!=null?s(t(),e):Uy(t(),e),a=()=>xu(i,t,n);return!o||o<=1?Oe(a().clone()):Array(o).fill(void 0).map(a).map(l=>Oe(l.clone()))}var xY=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e};var _b=class extends _n{constructor(t){if(t.unroll)throw new Nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Nt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new we({ndim:5})]}call(t,e){return G(()=>{if(this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new z("ConvRNN2D cell does not support constants");let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return G(()=>{let{stateSize:e}=this.cell,n=t.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],i=_e(s);return Array.isArray(e)?Array(e.length).fill(i):[i]})}resetStates(t,e=!1){G(()=>{if(!this.stateful)throw new Nn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_e(s)):this.states_=[_e(s)];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_e(s)):this.states_[0]=_e(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let a=0;a<this.states_.length;++a){let u=t[a],l=s;if(!y.arraysEqual(u.shape,l))throw new z(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Oe(a.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:n,kernelSize:o,padding:s,strides:i,dilationRate:a}=this.cell,u=e==="channelsFirst",l=t[u?3:2],c=t[u?4:3],p=kn(l,o[0],s,i[0],a[0]),m=kn(c,o[1],s,i[1],a[1]);return[...t.slice(0,2),...u?[n,p,m]:[p,m,n]]}};_b.className="ConvRNN2D";var $c=class extends ll{constructor(t){let{filters:e,kernelSize:n,strides:o,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,Je(this.filters,"filters"),this.kernelSize=Cu(n,2,"kernelSize"),this.kernelSize.forEach(u=>Je(u,"kernelSize")),this.strides=Cu(o||1,2,"strides"),this.strides.forEach(u=>Je(u,"strides")),this.padding=s||"valid",pn(this.padding),this.dataFormat=i||"channelsLast",Pe(this.dataFormat),this.dilationRate=Cu(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>Je(u,"dilationRate"))}build(t){var e;t=te(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[n]}`);let o=t[n],s=4,i=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;u=new(e=class extends hn{apply(m,f){let d=l.apply([c]),h=cr([c]),g=l.apply([c*2]);return Mm([d,h,g])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return G(()=>{if(t.length!==3)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training||!1,o=t[0],s=t[1],i=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ul({ones:()=>br(o),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(st,it,pt)=>!it||!it[pt]?st:O(it[pt],st),c=l(o,u,0),p=l(o,u,1),m=l(o,u,2),f=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ul({ones:()=>br(s),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,h=l(s,d,0),g=l(s,d,1),x=l(s,d,2),b=l(s,d,3),w=3,[C,T,E,$]=mr(this.kernel.read(),a,w),[D,P,M,W]=this.useBias?mr(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,C,D,this.padding),p=this.inputConv(p,T,P,this.padding),m=this.inputConv(m,E,M,this.padding),f=this.inputConv(f,$,W,this.padding);let[H,q,X,j]=mr(this.recurrentKernel.read(),a,w);h=this.recurrentConv(h,H),g=this.recurrentConv(g,q),x=this.recurrentConv(x,X),b=this.recurrentConv(b,j);let Z=this.recurrentActivation.apply(J(c,h)),et=this.recurrentActivation.apply(J(p,g)),K=J(O(et,i),O(Z,this.activation.apply(J(m,x)))),ot=O(this.recurrentActivation.apply(J(f,b)),this.activation.apply(K));return[ot,ot,K]})}getConfig(){let t=super.getConfig(),{units:e}=t,n=xY(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,o)}inputConv(t,e,n,o){let s=Sn(t,e,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?fn(s,n,this.dataFormat):s}recurrentConv(t,e){return Sn(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};$c.className="ConvLSTM2DCell";rt.registerClass($c);var vf=class extends _b{constructor(t){let e=new $c(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}};vf.className="ConvLSTM2D";rt.registerClass(vf);var Dc=class extends Bt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?e[o]:this.noiseShape[o]);return n}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t);if(0<this.rate&&this.rate<1){let o=e.training==null?!1:e.training,s=this.getNoiseShape(n);return xu(()=>Uy(n,this.rate,s,this.seed),()=>n,o)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};Dc.className="Dropout";rt.registerClass(Dc);var If=class extends Dc{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};If.className="SpatialDropout1D";rt.registerClass(If);var Sf=class extends Bt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Je(this.units,"units"),this.activation=ti(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=ge(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ge(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=We(t.kernelConstraint),this.biasConstraint=We(t.biasConstraint),this.kernelRegularizer=Ce(t.kernelRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.activityRegularizer=Ce(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=te(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=te(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=Py(this.activation.getClassName()),s;return o!=null?s=To(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=To(n,this.kernel.read()),this.bias!=null&&(s=fn(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let t={units:this.units,activation:Qs(this.activation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:de(this.kernelRegularizer),biasRegularizer:de(this.biasRegularizer),activityRegularizer:de(this.activityRegularizer),kernelConstraint:Ge(this.kernelConstraint),biasConstraint:Ge(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};Sf.className="Dense";rt.registerClass(Sf);var Tf=class extends Bt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=te(t);for(let e of t.slice(1))if(e==null)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],So(t,1)]}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Mt(n,o)}return K$(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};Tf.className="Flatten";rt.registerClass(Tf);var Nf=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.activation=ti(t.activation)}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t);return this.activation.apply(n)})}getConfig(){let t={activation:Qs(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};Nf.className="Activation";rt.registerClass(Nf);var kf=class extends Bt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return G(()=>(t=Pt(t),H$(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};kf.className="RepeatVector";rt.registerClass(kf);var _f=class extends Bt{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let n="Total size of new array must be unchanged.",o=e.slice(),s=1,i=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(i===null)i=u;else throw new z("Can only specifiy one unknown dimension.");else s*=l}let a=So(t);if(i!==null){if(s===0||a%s!==0)throw new z(n);o[i]=a/s}else if(a!==s)throw new z(n);return o}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return F(n,s)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};_f.className="Reshape";rt.registerClass(_f);var Ef=class extends Bt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=jr(1,t.dims.length+1);if(!y.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new we({ndim:this.dims.length+1})]}computeOutputShape(t){t=te(t);let e=t.slice();return this.dims.forEach((n,o)=>{e[o+1]=t[n]}),e}call(t,e){return Mt(Pt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};Ef.className="Permute";rt.registerClass(Ef);var Af=class extends Bt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let n=Pt(t),o=-1;return Ju(qs(n,this.maskValue),o)}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=-1,s=!0,i=Ju(qs(n,this.maskValue),o,s);return O(n,tt(i,n.dtype))})}};Af.className="Masking";rt.registerClass(Af);var $f=class extends Bt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(be(t.inputLength))}this.inputDim=t.inputDim,Je(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Je(this.outputDim,"outputDim"),this.embeddingsInitializer=ge(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ce(t.embeddingsRegularizer),this.activityRegularizer=Ce(t.activityRegularizer),this.embeddingsConstraint=We(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return G(()=>this.maskZero?(t=Pt(t),qs(t,St(t))):null)}computeOutputShape(t){if(t=te(t),this.inputLength==null)return[...t,this.outputDim];let e=be(this.inputLength);if(e.length!==t.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let o=0;o<e.length;++o){let s=e[o],i=t[o+1];if(s!=null&&i!=null&&s!==i)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t);n.dtype!=="int32"&&(n=hc(n,"int32"));let o=Wy(this.embeddings.read(),F(n,[n.size]));return F(o,te(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ee(this.embeddingsInitializer),embeddingsRegularizer:de(this.embeddingsRegularizer),activityRegularizer:de(this.activityRegularizer),embeddingsConstraint:Ge(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};$f.className="Embedding";rt.registerClass($f);var cl=class extends Bt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Nt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){let s=t[t.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[te(t)]),t=t,t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=Io(e),e.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&Io(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return G(()=>{if(t=t,this.reshapeRequired){let n=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=Zs(o);for(let i of t){let a=i.rank;for(let u=0;u<s-a;++u)i=rl(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let u of t){let l=u.rank;if(l==null){let c=u.shape,p=c[0],m=c.slice(1).concat([p]),f=F(u,[p].concat(So(c.slice(1))));f=Mt(f,[1,0]),f=F(f,m),n.push(f),s=!0}else if(l>1){let c=jr(1,l).concat([0]);n.push(Mt(u,c)),s=!0}else n.push(u)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let u=i.shape,l=u.length,c=u[l-1],p=[c].concat(u.slice(0,u.length-1));i=F(Mt(F(i,[-1,c]),[1,0]),p)}else if(a>1){let u=[a-1].concat(jr(0,a-1));i=Mt(i,u)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);return n=Io(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return G(()=>{if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(e.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:yr(o,0));let n=e[0];for(let o=1;o<e.length-1;++o)n=Dr(n,e[o]);return n})}},Df=class extends cl{constructor(t){super(t)}mergeFunction(t){return G(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return e})}};Df.className="Add";rt.registerClass(Df);var Rf=class extends cl{constructor(t){super(t)}mergeFunction(t){return G(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=O(e,t[n]);return e})}};Rf.className="Multiply";rt.registerClass(Rf);var Ff=class extends cl{constructor(t){super(t)}mergeFunction(t){return G(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return O(1/t.length,e)})}};Ff.className="Average";rt.registerClass(Ff);var Of=class extends cl{constructor(t){super(t)}mergeFunction(t){return G(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Tn(e,t[n]);return e})}};Of.className="Maximum";rt.registerClass(Of);var Pf=class extends cl{constructor(t){super(t)}mergeFunction(t){return G(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Ui(e,t[n]);return e})}};Pf.className="Minimum";rt.registerClass(Pf);var Lf=class extends cl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let o of t)if(o!=null){e=!1;break}if(e)return;let n=[];for(let o=0;o<t.length;++o){let s=t[o].slice();s.splice(this.axis,1);let i=!1;for(let a of n)if(y.arraysEqual(a,s)){i=!0;break}i||n.push(s)}if(n.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return G(()=>Mm(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new z("A `Concatenate` layer should be called on a list of inputs.");let e=t,n=e[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of e.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new z("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new z(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return G(()=>{let n=!0;if(e.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let o=[];for(let i=0;i<t.length;++i)e[i]==null?o.push(tt(br(t[i]),"bool")):e[i].rank<t[i].rank?o.push(yr(e[i],-1)):o.push(e[i]);let s=se(o,this.axis);return cm(s,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};Lf.className="Concatenate";rt.registerClass(Lf);function Bh(r,t){for(;r<0;)r+=t;return r}function yY(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new Nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(y.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),y.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new Nt("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=t.shape.length;e==null&&(e=[n-1,o-2]);let s=e;return G(()=>{let i;if(n>o){i=n-o;let u=[];for(let l=0;l<i;++l)u.push(1);t=F(t,t.shape.concat(u))}else if(o>n){i=o-n;let u=[];for(let l=0;l<i;++l)u.push(1);r=F(r,r.shape.concat(u))}else i=0;let a;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=ft(O(r,t),s[0]):a=ft(O(Mt(r,[1,0]),t),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===t.shape.length-1;a=Gt(r,t,u,l)}if(i>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let c=u;c<u+i;++c)l.push(c);a=Mn(a,l)}return a.shape.length===1&&(a=yr(a,1)),a})}var Mf=class extends cl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){y.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],n=t[1];if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);if(e[o[0]]!==n[o[1]])throw new z(`Dimension incompatibility: ${e[o[0]]} !== ${n[o[1]]}`)}mergeFunction(t){if(t.length!==2)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,i)=>Bh(s,t[i].shape.length)):o=[Bh(this.axes,e.shape.length),Bh(this.axes,n.shape.length)],this.normalize&&(e=Dh(e,o[0]),n=Dh(n,o[1])),yY(e,n,o)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[Bh(this.axes,t.length),Bh(this.axes,e.length)],n}computeOutputShape(t){y.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);e.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=e.concat(n);return s.length===1&&s.push(1),s}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};Mf.className="Dot";rt.registerClass(Mf);var zf=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t);return xu(()=>J(zm(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}};zf.className="GaussianNoise";rt.registerClass(zf);var Bf=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return G(()=>{this.invokeCallHook(t,e);let n=Pt(t);return this.rate>0&&this.rate<1?xu(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return O(n,zm(n.shape,1,s))},()=>n,e.training||!1):n})}};Bf.className="GaussianDropout";rt.registerClass(Bf);var Vf=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Pt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return G(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return xu(()=>{let s=Pt(t),i=1.6732632423543772,a=1.0507009873554805,u=-i*a,l=Pn(Hi(n),this.rate);l=hc(l,"float32");let c=((1-this.rate)*(1+this.rate*u**2))**-.5,p=-c*u*this.rate,m=J(O(s,l),O(J(l,-1),u));return J(O(m,c),p)},()=>Pt(t),e.training||!1)}return t})}};Vf.className="AlphaDropout";rt.registerClass(Vf);function Vh(r,t,e,n,o,s=.001){let i;if(r.rank===2)i=$x(r,t,e,n,o,s);else if(r.rank===3)i=Dx(r,t,e,n,o,s);else if(r.rank===4)i=Rx(r,t,e,n,o,s);else throw new Nt(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function bY(r,t,e,n,o=.001){return G(()=>{let s=oc(r,n),i=s.mean,a=s.variance;return[Vh(r,i,a,e,t,o),i,a]})}function wY(r,t,e,n,o=.001){return G(()=>{let s=oc(r,n),i=s.mean,a=s.variance,u=[];for(let d of jr(0,r.rank))n.indexOf(d)!==-1?u.push(1):u.push(r.shape[d]);let l=F(i,u),c=F(a,u),p=t==null?null:F(t,u),m=e==null?null:F(e,u);return[Vh(r,l,c,m,p,o),i,a]})}function CY(r,t,e,n,o=.001){return y.arraysEqual(n.slice().sort(),jr(0,r.rank-1))?bY(r,t,e,n,o):wY(r,t,e,n,o)}var Gf=class extends Bt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=ge(t.betaInitializer||"zeros"),this.gammaInitializer=ge(t.gammaInitializer||"ones"),this.movingMeanInitializer=ge(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ge(t.movingVarianceInitializer||"ones"),this.betaConstraint=We(t.betaConstraint),this.gammaConstraint=We(t.gammaConstraint),this.betaRegularizer=Ce(t.betaRegularizer),this.gammaRegularizer=Ce(t.gammaRegularizer)}build(t){t=te(t);let e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new z(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new we({ndim:t.length,axes:{[e]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return G(()=>{let n=e.training==null?!1:e.training,o=Pt(t),s=o.shape,i=s.length,a=jr(0,i),u=this.axis>=0?this.axis:this.axis+i;a.splice(u,1);let l=Co(1,i);l[u]=s[u];let c=a.slice();c.sort();let p=!y.arraysEqual(c,jr(0,i).slice(0,i-1)),m=()=>{if(p){let b=F(this.movingMean.read(),l),w=F(this.movingVariance.read(),l),C=this.center?F(this.beta.read(),l):null,T=this.scale?F(this.gamma.read(),l):null;return Vh(o,b,w,C,T,this.epsilon)}else return Vh(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[f,d,h]=CY(o,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,w,C)=>{G(()=>{let T=1-C,E=b.read(),$=O(ut(E,w),T);b.write(ut(E,$))})};return(()=>{g(this.movingMean,d,this.momentum),g(this.movingVariance,h,this.momentum)})(),f})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ee(this.betaInitializer),gammaInitializer:Ee(this.gammaInitializer),movingMeanInitializer:Ee(this.movingMeanInitializer),movingVarianceInitializer:Ee(this.movingVarianceInitializer),betaRegularizer:de(this.betaRegularizer),gammaRegularizer:de(this.gammaRegularizer),betaConstraint:Ge(this.betaConstraint),gammaConstraint:Ge(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};Gf.className="BatchNormalization";rt.registerClass(Gf);var Wf=class extends Bt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=ge(t.betaInitializer||"zeros"),this.gammaInitializer=ge(t.gammaInitializer||"ones"),this.betaRegularizer=Ce(t.betaRegularizer),this.gammaRegularizer=Ce(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=te(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(let s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Io(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>t[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(t,e){let n=Pt(t),o=n.shape,s=o.length;return G(()=>{let{mean:a,variance:u}=oc(n,this.axis,!0),l=Co(1,s);for(let h of this.axis)l[h]=o[h];let c=h=>h!=null&&h.shape.length!==s?F(h,l):h,p=this.scale?c(this.gamma.read()):null,m=this.center?c(this.beta.read()):null,f=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(f.push(o[h]),d.push(1)):(f.push(1),d.push(o[h]));return a=$r(a,f),u=$r(u,f),p!=null&&(p=$r(p,d)),m!=null&&(m=$r(m,d)),Vh(n,a,u,m,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ee(this.betaInitializer),gammaInitializer:Ee(this.gammaInitializer),betaRegularizer:de(this.betaRegularizer),gammaRegularizer:de(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};Wf.className="LayerNormalization";rt.registerClass(Wf);function vY(r,t,e){return G(()=>{if(r.rank!==4)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=mn()),e!=="channelsLast"&&e!=="channelsFirst")throw new z(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],cn(r,n)})}var Uf=class extends Bt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?mn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new we({ndim:4})]}computeOutputShape(t){t=te(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return G(()=>vY(Pt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};Uf.className="ZeroPadding2D";rt.registerClass(Uf);function Fb(r,t,e,n,o,s){return G(()=>{Pe(o),RS(s),pn(n),e==null&&(e=[1,1]),n==null&&(n="valid"),o==null&&(o=mn()),s==null&&(s="max"),r=zh(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=eu(r,t,e,a):i=Xl(r,t,e,a),o==="channelsFirst"&&(i=Mt(i,[0,3,1,2])),i})}function OD(r,t,e,n,o,s){return G(()=>{Pe(o),RS(s),pn(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),o==null&&(o=mn()),s==null&&(s="max"),r=YS(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=sy(r,t,e,a):i=Ax(r,t,e,a),o==="channelsFirst"&&(i=Mt(i,[0,4,1,2,3])),i})}var Eb=class extends Bt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Je(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Je(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,pn(this.padding),this.inputSpec=[new we({ndim:3})]}computeOutputShape(t){t=te(t);let e=kn(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return G(()=>{this.invokeCallHook(t,e),t=rl(Pt(t),2);let n=this.poolingFunction(Pt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Mn(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},Hf=class extends Eb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Pe(s),pn(o),Fb(t,e,n,o,s,"max")}};Hf.className="MaxPooling1D";rt.registerClass(Hf);var qf=class extends Eb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Pe(s),pn(o),Fb(t,e,n,o,s,"avg")}};qf.className="AveragePooling1D";rt.registerClass(qf);var Ab=class extends Bt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Je(this.poolSize,"poolSize"),Je(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Pe(this.dataFormat),pn(this.padding),this.inputSpec=[new we({ndim:4})]}computeOutputShape(t){t=te(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=kn(e,this.poolSize[0],this.padding,this.strides[0]),n=kn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return G(()=>(this.invokeCallHook(t,e),this.poolingFunction(Pt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Kf=class extends Ab{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Pe(s),pn(o),Fb(t,e,n,o,s,"max")}};Kf.className="MaxPooling2D";rt.registerClass(Kf);var jf=class extends Ab{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Pe(s),pn(o),Fb(t,e,n,o,s,"avg")}};jf.className="AveragePooling2D";rt.registerClass(jf);var $b=class extends Bt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Je(this.poolSize,"poolSize"),Je(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Pe(this.dataFormat),pn(this.padding),this.inputSpec=[new we({ndim:5})]}computeOutputShape(t){t=te(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=kn(e,this.poolSize[0],this.padding,this.strides[0]),n=kn(n,this.poolSize[1],this.padding,this.strides[1]),o=kn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,o]:[t[0],e,n,o,t[4]]}call(t,e){return G(()=>(this.invokeCallHook(t,e),this.poolingFunction(Pt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Xf=class extends $b{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Pe(s),pn(o),OD(t,e,n,o,s,"max")}};Xf.className="MaxPooling3D";rt.registerClass(Xf);var Yf=class extends $b{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Pe(s),pn(o),OD(t,e,n,o,s,"avg")}};Yf.className="AveragePooling3D";rt.registerClass(Yf);var Db=class extends Bt{constructor(t){super(t),this.inputSpec=[new we({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Nt}},Zf=class extends Db{constructor(t){super(t||{})}call(t,e){return G(()=>{let n=Pt(t);return ke(n,1)})}};Zf.className="GlobalAveragePooling1D";rt.registerClass(Zf);var Jf=class extends Db{constructor(t){super(t||{})}call(t,e){return G(()=>{let n=Pt(t);return Mr(n,1)})}};Jf.className="GlobalMaxPooling1D";rt.registerClass(Jf);var Rb=class extends Bt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Pe(this.dataFormat),this.inputSpec=[new we({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Nt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Qf=class extends Rb{call(t,e){return G(()=>{let n=Pt(t);return this.dataFormat==="channelsLast"?ke(n,[1,2]):ke(n,[2,3])})}};Qf.className="GlobalAveragePooling2D";rt.registerClass(Qf);var td=class extends Rb{call(t,e){return G(()=>{let n=Pt(t);return this.dataFormat==="channelsLast"?Mr(n,[1,2]):Mr(n,[2,3])})}};td.className="GlobalMaxPooling2D";rt.registerClass(td);var Ob=class extends Bt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let o=e.layer,s=xn(o,n);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},ed=class extends Ob{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=te(t),t.length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=te(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),o=t[1];return[n[0],o].concat(n.slice(1))}call(t,e){return G(()=>(t=Pt(t),JS((i,a)=>[Pt(this.layer.call(i,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};ed.className="TimeDistributed";rt.registerClass(ed);function IY(r){Xi(B$,"BidirectionalMergeMode",r)}var SY="concat",rd=class extends Ob{constructor(t){super(t);let e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=xn(n),e.goBackwards=e.goBackwards!==!0;let o={};if(o.className=t.layer.getClassName(),o.config=e,this.backwardLayer=xn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?SY:t.mergeMode,IY(this.mergeMode),t.weights)throw new Nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,o,s;return this.returnState&&(s=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Nr(o)}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=ZS(t,n,o,this.numConstants);if(t=s.inputs,n=s.initialState,o=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&o==null)return super.apply(t,e);let i=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);let c=n.map(p=>new we({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),a.push(...c)}if(o!=null)throw new Nt("Support for constants in Bidirectional layers is not implemented yet.");let u=i[0]instanceof Xr;for(let l of i)if(l instanceof Xr!==u)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return G(()=>{let n=e.initialState,o,s;if(n==null)o=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let i;this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=pr(s,1));let a;return this.mergeMode==="concat"?a=Mm([o,s]):this.mergeMode==="sum"?a=J(o,s):this.mergeMode==="ave"?a=O(.5,J(o,s)):this.mergeMode==="mul"?a=O(o,s):this.mergeMode==null&&(a=[o,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Ys(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Ys(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let n=xn(e.layer);if(delete e.layer,e.numConstants!=null)throw new Nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=e;return o.layer=n,new t(o)}};rd.className="Bidirectional";rt.registerClass(rd);function TY(r){return new Js(r)}function NY(r){return new cf(r)}function kY(r){return new af(r)}function _Y(r){return new lf(r)}function EY(r){return new uf(r)}function AY(r){return new mf(r)}function $Y(r){return new pf(r)}function DY(r){return new Iu(r)}function RY(r){return new sl(r)}function FY(r){return new ff(r)}function OY(r){return new il(r)}function PY(r){return new df(r)}function LY(r){return new hf(r)}function MY(r){return new gf(r)}function zY(r){return new xf(r)}function BY(r){return new yf(r)}function VY(r){return new Nf(r)}function GY(r){return new Sf(r)}function WY(r){return new Dc(r)}function UY(r){return new If(r)}function HY(r){return new Tf(r)}function qY(r){return new kf(r)}function KY(r){return new _f(r)}function jY(r){return new Ef(r)}function XY(r){return new $f(r)}function YY(r){return new Df(r)}function ZY(r){return new Ff(r)}function JY(r){return new Lf(r)}function QY(r){return new Of(r)}function t7(r){return new Pf(r)}function e7(r){return new Rf(r)}function r7(r){return new Mf(r)}function n7(r){return new Gf(r)}function o7(r){return new Wf(r)}function s7(r){return new Uf(r)}function QS(r){return new qf(r)}function i7(r){return QS(r)}function a7(r){return QS(r)}function tT(r){return new jf(r)}function l7(r){return tT(r)}function u7(r){return tT(r)}function eT(r){return new Yf(r)}function c7(r){return eT(r)}function p7(r){return eT(r)}function m7(r){return new Zf(r)}function f7(r){return new Qf(r)}function PD(r){return new Jf(r)}function LD(r){return new td(r)}function MD(r){return new Hf(r)}function zD(r){return new Kf(r)}function d7(r){return new Xf(r)}function h7(r){return new wf(r)}function g7(r){return new Ec(r)}function x7(r){return new Cf(r)}function y7(r){return new ll(r)}function b7(r){return new bf(r)}function w7(r){return new _c(r)}function C7(r){return new vf(r)}function v7(r){return new $c(r)}function I7(r){return new _n(r)}function S7(r){return new Ac(r)}function T7(r){return new rd(r)}function N7(r){return new ed(r)}var k7=PD,_7=LD,E7=MD,A7=zD;function $7(r){return new zf(r)}function D7(r){return new Bf(r)}function R7(r){return new Vf(r)}function F7(r){return new Af(r)}var VD={};jt(VD,{MAPE:()=>H7,MSE:()=>j7,binaryAccuracy:()=>O7,binaryCrossentropy:()=>P7,categoricalAccuracy:()=>M7,categoricalCrossentropy:()=>z7,cosineProximity:()=>G7,mape:()=>q7,meanAbsoluteError:()=>W7,meanAbsolutePercentageError:()=>U7,meanSquaredError:()=>K7,mse:()=>X7,precision:()=>B7,recall:()=>V7,sparseCategoricalAccuracy:()=>L7});function O7(r,t){return Oh(r,t)}function P7(r,t){return nb(r,t)}function L7(r,t){return ob(r,t)}function M7(r,t){return Ph(r,t)}function z7(r,t){return Lh(r,t)}function B7(r,t){return VS(r,t)}function V7(r,t){return mD(r,t)}function G7(r,t){return Fh(r,t)}function W7(r,t){return tf(r,t)}function U7(r,t){return bu(r,t)}function H7(r,t){return bu(r,t)}function q7(r,t){return bu(r,t)}function K7(r,t){return Zi(r,t)}function j7(r,t){return Zi(r,t)}function X7(r,t){return Zi(r,t)}var GD={};jt(GD,{modelFromJSON:()=>_D});var WD={};jt(WD,{l1:()=>Z7,l1l2:()=>Y7,l2:()=>J7});function Y7(r){return new wu(r)}function Z7(r){return DD(r)}function J7(r){return RD(r)}var Lb=class extends ol{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof Bn))throw new Error("model must be a LayersModel, not some other Container");this.model=t}};function Pb(r,t){return r<t}function UD(r,t){return r>t}var Mb=class extends Lb{constructor(t){if(super(),t==null&&(t={}),t.restoreBestWeights)throw new Nt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Pb:this.mode==="max"?this.monitorFunc=UD:this.monitor.indexOf("acc")!==-1?this.monitorFunc=UD:this.monitorFunc=Pb,this.monitorFunc===Pb&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Pb?1/0:-1/0}async onEpochEnd(t,e){await Yi(e);let n=this.getMonitorValue(e);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}};function Q7(r){return new Mb(r)}var tZ={earlyStopping:Q7};var eZ=B();eZ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var eo;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(eo||(eo={}));var HD;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(HD||(HD={}));var rT={};function nZ(r,t){let e={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t};rT[r]=e}function zb(r){return rT[r]}function oZ(r){delete rT[r]}function I(r,t,e,n,o){let s=t.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return wr(t.inputNames[s.inputIndexStart],e,n,o);if(s.type==="tensors")return t.inputNames.slice(a,u).map(m=>wr(m,e,n,o));let l=wr(t.inputNames.slice(a)[0],e,n,o),c=l.dataSync();return s.type==="number"?c[0]:y.toNestedArray(l.shape,c)}let i=t.attrParams[r];return i&&i.value}function wr(r,t,e,n){let[o,s]=yn(r);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!t[Bb(o,a)]);return i!==void 0?t[Bb(o,i)][s]:void 0}function qD(r,t,e){return t[Bb(r,e.currentContextId)]}function _o(r,t){let[e,n,o]=yn(r);return[Bb(e,t&&t.currentContextId),n,o]}function Bb(r,t){return t?`${r}-${t}`:r}function yn(r){let t=r.split(":");if(t.length===1)return[r,0,void 0];let e=t[0],n=t.length===3?t[1]:void 0,o=Number(t[t.length-1]);return[e,o,n]}function Gh(r,t,e){let n=I("pad",r,t,e);if(n==="explicit"){n=I("explicitPaddings",r,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function ri(r){return r.kept?r:an(r)}var nT={};jt(nT,{json:()=>sZ});var sZ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var oT={};jt(oT,{json:()=>iZ});var iZ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var sT={};jt(sT,{json:()=>aZ});var aZ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var iT={};jt(iT,{json:()=>lZ});var lZ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var aT={};jt(aT,{json:()=>uZ});var uZ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var lT={};jt(lT,{json:()=>cZ});var cZ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var uT={};jt(uT,{json:()=>pZ});var pZ=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var cT={};jt(cT,{json:()=>mZ});var mZ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var pT={};jt(pT,{json:()=>fZ});var fZ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var mT={};jt(mT,{json:()=>dZ});var dZ=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var fT={};jt(fT,{json:()=>hZ});var hZ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var dT={};jt(dT,{json:()=>gZ});var gZ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var hT={};jt(hT,{json:()=>xZ});var xZ=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var gT={};jt(gT,{json:()=>yZ});var yZ=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var xT={};jt(xT,{json:()=>bZ});var bZ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var yT={};jt(yT,{json:()=>wZ});var wZ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var bT={};jt(bT,{json:()=>CZ});var CZ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var wT={};jt(wT,{json:()=>vZ});var vZ=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var CT={};jt(CT,{json:()=>IZ});var IZ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Wh=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[nT,oT,sT,iT,aT,lT,uT,cT,pT,mT,fT,dT,hT,gT,xT,yT,bT,wT,CT],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(t,e={}){let n=t.node,o=[],s=[],i=[],a=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),u=[],l=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let m=Object.keys(a);m.forEach(h=>{let g=a[h];g.inputNames.forEach((x,b)=>{let[w,,C]=_o(x),T=a[w];if(T.outputs!=null){let E=T.outputs.indexOf(C);if(E!==-1){let $=`${w}:${E}`;g.inputNames[b]=$}}g.inputs.push(T),T.children.push(g)})}),Object.keys(p).length===0?m.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=_o(h),x=a[g];x!=null&&(x.signatureKey=p[h],l.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=_o(h),x=a[g];x&&(x.signatureKey=c[h],u.push(x))}):u=o;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:e,functions:f};return i.length>0&&(d.initNodes=i),d}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=zb(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=Vb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Vb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=jb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=jb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=Wb(t.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=Wb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=Kb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Kb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=Gb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Gb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=Yb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Yb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=qb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=qb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Xb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Xb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=Ub(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Ub(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=Hb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Hb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=KD(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=KD(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(t){let e=t.nodeDef,n=[],o=[],s={};e!=null&&(s=e.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&o.push(p[m.name]),p),{}));let i=[],a=[];t.signature.inputArg.forEach(p=>{let[m]=_o(p.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:vT(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[m]=f}),Object.keys(s).forEach(p=>{let m=s[p];m.inputNames.forEach((f,d)=>{let[h,,g]=_o(f),x=s[h];if(x.outputs!=null){let b=x.outputs.indexOf(g);if(b!==-1){let w=`${h}:${b}`;m.inputNames[d]=w}}m.inputs.push(x),x.children.push(m)})});let l=t.ret;t.signature.outputArg.forEach(p=>{let[m,f]=_o(l[p.name]),d=s[m];d!=null&&(d.defaultOutput=f,a.push(d))});let c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function SZ(r){let t=B().global;if(typeof t.atob!="undefined")return t.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function jD(r,t){let e=Array.isArray(r)?String.fromCharCode.apply(null,r):SZ(r);return t?e:e.toLowerCase()}function Vb(r,t,e,n=!1){let o=r[t];return o!=null?jD(o.s,n):e}function Gb(r,t,e){let n=r[t];return n?n.b:e}function Wb(r,t,e){let n=r[t]||{},o=n.i!=null?n.i:n.f!=null?n.f:e;return typeof o=="number"?o:parseInt(o,10)}function vT(r){switch(typeof r=="string"&&(r=eo[r]),r){case eo.DT_FLOAT:case eo.DT_HALF:return"float32";case eo.DT_INT32:case eo.DT_INT64:case eo.DT_INT8:case eo.DT_UINT8:return"int32";case eo.DT_BOOL:return"bool";case eo.DT_DOUBLE:return"float32";case eo.DT_STRING:return"string";default:return null}}function KD(r,t,e){let n=r[t];return n&&n.func?n.func.name:e}function Ub(r,t,e){let n=r[t];return n&&n.type?vT(n.type):e}function Hb(r,t,e){let n=r[t];return n&&n.list&&n.list.type?n.list.type.map(o=>vT(o)):e}function XD(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function qb(r,t,e){let n=r[t];return n&&n.shape?XD(n.shape):e}function Kb(r,t,e){let n=r[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function jb(r,t,e,n=!1){let o=r[t];return o&&o.list&&o.list.s?o.list.s.map(s=>jD(s,n)):e}function Xb(r,t,e){let n=r[t];return n&&n.list&&n.list.shape?n.list.shape.map(o=>XD(o)):e}function Yb(r,t,e){let n=r[t];return n&&n.list&&n.list.b?n.list.b:e}var Zb=class{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return wr(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return wr(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Wb(this.node.rawAttrs,t,e);if(n.s!=null)return Vb(this.node.rawAttrs,t,e);if(n.b!=null)return Gb(this.node.rawAttrs,t,e);if(n.shape!=null)return qb(this.node.rawAttrs,t,e);if(n.type!=null)return Ub(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Kb(this.node.rawAttrs,t,e);if(n.list.s!=null)return jb(this.node.rawAttrs,t,e);if(n.list.shape!=null)return Xb(this.node.rawAttrs,t,e);if(n.list.b!=null)return Yb(this.node.rawAttrs,t,e);if(n.list.type!=null)return Hb(this.node.rawAttrs,t,e)}return e}};var ue={};jt(ue,{OP_SCOPE_SUFFIX:()=>z0,abs:()=>$e,acos:()=>Cx,acosh:()=>vx,add:()=>J,addN:()=>J_,all:()=>cm,any:()=>Ju,argMax:()=>Oi,argMin:()=>Ix,asin:()=>Sx,asinh:()=>Tx,atan:()=>Nx,atan2:()=>kx,atanh:()=>_x,avgPool:()=>Xl,avgPool3d:()=>Ax,basicLSTMCell:()=>eE,batchNorm:()=>Li,batchNorm2d:()=>$x,batchNorm3d:()=>Dx,batchNorm4d:()=>Rx,batchToSpaceND:()=>Yl,bincount:()=>Fx,booleanMaskAsync:()=>w6,broadcastArgs:()=>nE,broadcastTo:()=>Mi,buffer:()=>vt,cast:()=>tt,ceil:()=>Ox,clipByValue:()=>Ir,clone:()=>an,complex:()=>Cn,concat:()=>se,concat1d:()=>Px,concat2d:()=>Lx,concat3d:()=>Mx,concat4d:()=>zx,conv1d:()=>mm,conv2d:()=>Sn,conv2dTranspose:()=>dm,conv3d:()=>Bx,conv3dTranspose:()=>Gx,cos:()=>Zl,cosh:()=>hm,cosineWindow:()=>Sh,cumprod:()=>ec,cumsum:()=>gm,denseBincount:()=>oE,depthToSpace:()=>Wx,depthwiseConv2d:()=>zi,diag:()=>sE,dilation2d:()=>Ux,div:()=>ct,divNoNan:()=>Hx,dot:()=>qx,dropout:()=>bS,einsum:()=>iE,elu:()=>Bi,enclosingPowerOfTwo:()=>wS,equal:()=>Ar,erf:()=>Kx,euclideanNorm:()=>jx,exp:()=>or,expandDims:()=>yr,expm1:()=>Xx,eye:()=>nc,fft:()=>iu,fill:()=>Vi,floor:()=>Gi,floorDiv:()=>um,fused:()=>lu,gather:()=>Wi,gatherND:()=>E6,greater:()=>Xe,greaterEqual:()=>Pn,ifft:()=>Qa,imag:()=>jl,image:()=>uu,inTopKAsync:()=>D6,irfft:()=>Am,isFinite:()=>Yx,isInf:()=>Zx,isNaN:()=>Jx,leakyRelu:()=>Jl,less:()=>xm,lessEqual:()=>Ln,linalg:()=>vS,linspace:()=>uE,localResponseNormalization:()=>Qx,log:()=>Sr,log1p:()=>Ql,logSigmoid:()=>ry,logSoftmax:()=>ym,logSumExp:()=>bm,logicalAnd:()=>Dr,logicalNot:()=>tu,logicalOr:()=>wm,logicalXor:()=>ny,losses:()=>D5,lowerBound:()=>cE,matMul:()=>Gt,max:()=>Mr,maxPool:()=>eu,maxPool3d:()=>sy,maxPoolWithArgmax:()=>pE,maximum:()=>Tn,mean:()=>ke,meshgrid:()=>mE,min:()=>rc,minimum:()=>Ui,mirrorPad:()=>iy,mod:()=>ay,moments:()=>oc,movingAverage:()=>v6,mul:()=>O,multiRNNCell:()=>fE,multinomial:()=>dE,neg:()=>Yt,norm:()=>Ja,notEqual:()=>qs,oneHot:()=>Ri,ones:()=>cr,onesLike:()=>br,op:()=>N,outerProduct:()=>hE,pad:()=>cn,pad1d:()=>gE,pad2d:()=>xE,pad3d:()=>yE,pad4d:()=>bE,pool:()=>ly,pow:()=>ln,prelu:()=>nu,print:()=>mx,prod:()=>uy,raggedTensorToTensor:()=>wE,rand:()=>CE,randomGamma:()=>ME,randomNormal:()=>ac,randomStandardNormal:()=>zE,randomUniform:()=>Hi,range:()=>ou,real:()=>Za,reciprocal:()=>dy,relu:()=>Rr,relu6:()=>Cm,reshape:()=>F,reverse:()=>pr,reverse1d:()=>BE,reverse2d:()=>VE,reverse3d:()=>GE,reverse4d:()=>WE,rfft:()=>au,round:()=>vm,rsqrt:()=>Im,scalar:()=>mt,scatterND:()=>S6,searchSorted:()=>Ch,selu:()=>Sm,separableConv2d:()=>Tm,setdiff1dAsync:()=>UE,sigmoid:()=>Kr,sign:()=>hy,signal:()=>$5,sin:()=>Nm,sinh:()=>km,slice:()=>Ot,slice1d:()=>_m,slice2d:()=>Ih,slice3d:()=>Em,slice4d:()=>lc,softmax:()=>su,softplus:()=>Hs,spaceToBatchND:()=>ru,sparse:()=>R5,sparseToDense:()=>k6,spectral:()=>A5,split:()=>mr,sqrt:()=>Ne,square:()=>Ht,squaredDifference:()=>$m,squeeze:()=>Mn,stack:()=>sr,step:()=>yo,stridedSlice:()=>gy,string:()=>F5,sub:()=>ut,sum:()=>ft,tan:()=>xy,tanh:()=>Pi,tensor:()=>vr,tensor1d:()=>Ve,tensor2d:()=>Ks,tensor3d:()=>gx,tensor4d:()=>HE,tensor5d:()=>qE,tensor6d:()=>KE,tile:()=>$r,topk:()=>yy,transpose:()=>Mt,truncatedNormal:()=>Dm,unique:()=>by,unsortedSegmentSum:()=>Rm,unstack:()=>Tr,upperBound:()=>jE,variable:()=>wy,where:()=>De,whereAsync:()=>vy,zeros:()=>_e,zerosLike:()=>St});var YD=(r,t,e,n=ue)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(I("a",r,t,e),I("b",r,t,e))];case"AddN":return[n.addN(I("tensors",r,t,e))];case"FloorMod":case"Mod":return[n.mod(I("a",r,t,e),I("b",r,t,e))];case"Mul":return[n.mul(I("a",r,t,e),I("b",r,t,e))];case"RealDiv":case"Div":return[n.div(I("a",r,t,e),I("b",r,t,e))];case"DivNoNan":return[n.divNoNan(I("a",r,t,e),I("b",r,t,e))];case"FloorDiv":return[n.floorDiv(I("a",r,t,e),I("b",r,t,e))];case"Sub":return[n.sub(I("a",r,t,e),I("b",r,t,e))];case"Minimum":return[n.minimum(I("a",r,t,e),I("b",r,t,e))];case"Maximum":return[n.maximum(I("a",r,t,e),I("b",r,t,e))];case"Pow":return[n.pow(I("a",r,t,e),I("b",r,t,e))];case"SquaredDifference":return[n.squaredDifference(I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ZD=(r,t,e,n=ue)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(I("x",r,t,e))];case"Acos":return[n.acos(I("x",r,t,e))];case"Acosh":return[n.acosh(I("x",r,t,e))];case"Asin":return[n.asin(I("x",r,t,e))];case"Asinh":return[n.asinh(I("x",r,t,e))];case"Atan":return[n.atan(I("x",r,t,e))];case"Atan2":return[n.atan2(I("x",r,t,e),I("y",r,t,e))];case"Atanh":return[n.atanh(I("x",r,t,e))];case"Ceil":return[n.ceil(I("x",r,t,e))];case"Complex":return[n.complex(I("real",r,t,e),I("imag",r,t,e))];case"Cos":return[n.cos(I("x",r,t,e))];case"Cosh":return[n.cosh(I("x",r,t,e))];case"Elu":return[n.elu(I("x",r,t,e))];case"Erf":return[n.erf(I("x",r,t,e))];case"Exp":return[n.exp(I("x",r,t,e))];case"Expm1":return[n.expm1(I("x",r,t,e))];case"Floor":return[n.floor(I("x",r,t,e))];case"Log":return[n.log(I("x",r,t,e))];case"Log1p":return[n.log1p(I("x",r,t,e))];case"Imag":return[n.imag(I("x",r,t,e))];case"Neg":return[n.neg(I("x",r,t,e))];case"Reciprocal":return[n.reciprocal(I("x",r,t,e))];case"Real":return[n.real(I("x",r,t,e))];case"Relu":return[n.relu(I("x",r,t,e))];case"Round":return[n.round(I("x",r,t,e))];case"Selu":return[n.selu(I("x",r,t,e))];case"Sigmoid":return[n.sigmoid(I("x",r,t,e))];case"Sin":return[n.sin(I("x",r,t,e))];case"Sign":return[n.sign(I("x",r,t,e))];case"Sinh":return[n.sinh(I("x",r,t,e))];case"Softplus":return[n.softplus(I("x",r,t,e))];case"Sqrt":return[n.sqrt(I("x",r,t,e))];case"Square":return[n.square(I("x",r,t,e))];case"Tanh":return[n.tanh(I("x",r,t,e))];case"Tan":return[n.tan(I("x",r,t,e))];case"ClipByValue":return[n.clipByValue(I("x",r,t,e),I("clipValueMin",r,t,e),I("clipValueMax",r,t,e))];case"Relu6":return[n.relu6(I("x",r,t,e))];case"Rsqrt":return[n.rsqrt(wr(r.inputNames[0],t,e))];case"Prod":return[n.prod(I("x",r,t,e),I("axes",r,t,e))];case"LeakyRelu":return[n.leakyRelu(I("x",r,t,e),I("alpha",r,t,e))];case"Prelu":return[n.prelu(I("x",r,t,e),I("alpha",r,t,e))];case"IsNan":return[n.isNaN(wr(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Vn(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){y.assert(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=t[n];y.assert(o<0||s<0||o===s,()=>e+` Shapes ${r} and ${t} must match`)}}}function JD(r){return!(typeof r=="number"||r.some(t=>t<0))}function nd(r,t,e){let n=Jb(r,e),o=!JD(n);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&t.forEach(s=>{n=Jb(s.shape,n)}),!JD(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function Jb(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let e=[];for(let n=0;n<r.length;++n){let o=r[n],s=t[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[n]=o>=0?o:s}return e}var Qb=class{constructor(t,e,n,o,s,i,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=mt(0),Oe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Vn(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Oe(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,o)=>this.write(n,e[o]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return vr([],[0].concat(this.elementShape));let n=this.readMany(t);return Vn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),sr(n,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return vr([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let n=this.readMany(e);return Vn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),se(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,Tr(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,o=t.map(u=>(n+=u,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:e.size/n,i=[];G(()=>{e=F(e,[1,n,s]);for(let u=0;u<t.length;++u){let l=u===0?0:o[u-1],c=[0,l,0],p=[1,t[u],s];i[u]=F(Ot(e,c,p),this.elementShape)}return i});let a=[];for(let u=0;u<t.length;u++)a[u]=u;this.writeMany(a,i)}};var pl=class{constructor(t,e,n,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,t!=null&&t.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Vn(e,s.shape,"TensorList shape mismatch: "),Oe(s)}),this.idTensor=mt(0),this.maxNumElements=o,Oe(this.idTensor)}get id(){return this.idTensor.id}copy(){return new pl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Vn(t,this.elementShape,"TensorList shape mismatch: ");let o=nd(this.elementShape,this.tensors,t);return G(()=>{let s=this.tensors.map(i=>F(i,o));return sr(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=nd(this.elementShape,this.tensors,t),o=this.tensors.pop();return o.kept=!1,Vn(o.shape,t,"TensorList shape mismatch: "),F(o,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Vn(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Oe(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let e=new pl([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Vn(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=nd(this.elementShape,this.tensors,e);return F(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Vn(this.elementShape,e.shape,"TensorList shape mismatch: "),Oe(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Vn(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=nd(this.elementShape,this.tensors,n);return t.length===0?vr([],[0].concat(o)):G(()=>{let s=t.map(i=>F(this.tensors[i],o));return sr(s,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Vn(this.elementShape,e,"TensorList shape mismatch: ");let n=nd(this.elementShape,this.tensors,e);return this.size()===0?vr([],[0].concat(n)):G(()=>{let o=this.tensors.map(s=>F(s,n));return se(o,0)})}};function QD(r,t,e){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);let o=r.shape.slice(1);Vn(o,t,"TensorList shape mismatch: ");let s=Tr(r);return new pl(s,t,n)}function tR(r,t,e,n){return new pl([],r,t,n)}function eR(r,t,e,n){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let o=Math.max(...t);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new pl([],e,r.dtype,n),i=Tr(r,0);return t.forEach((a,u)=>{s.setItem(a,i[u])}),s}function rR(r,t,e){let n=0,o=t.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=Jb(s,e),a=n===0?0:r.size/n,u=G(()=>{let c=[];r=F(r,[1,n,a]);for(let p=0;p<t.length;++p){let m=p===0?0:o[p-1],f=[0,m,0],d=[1,t[p],a];c[p]=F(Ot(r,f,d),i)}return r.dispose(),c}),l=new pl([],e,r.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var nR=async(r,t,e)=>{switch(r.op){case"If":case"StatelessIf":{let n=I("thenBranch",r,t,e),o=I("elseBranch",r,t,e),s=I("cond",r,t,e),i=I("args",r,t,e);return(await s.data())[0]?e.functionMap[n].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let n=I("body",r,t,e),o=I("cond",r,t,e),s=I("args",r,t,e),i=await e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=s;for(;u[0];){let c=l;l=await e.functionMap[n].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);let p=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let m=await e.functionMap[o].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=I("pred",r,t,e);return[ri(n)]}case"Switch":{let n=I("pred",r,t,e),o=I("data",r,t,e);return o.kept||(o=ri(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>wr(o,t,e)!==void 0);if(n){let o=wr(n,t,e);return[ri(o)]}return}case"Enter":{let n=I("frameName",r,t,e),o=I("tensor",r,t,e);return e.enterFrame(n),[ri(o)]}case"Exit":{let n=I("tensor",r,t,e);return e.exitFrame(),[ri(n)]}case"NextIteration":{let n=I("tensor",r,t,e);return e.nextIteration(),[ri(n)]}case"TensorArrayV3":{let n=I("size",r,t,e),o=I("dtype",r,t,e),s=I("elementShape",r,t,e),i=I("dynamicSize",r,t,e),a=I("clearAfterRead",r,t,e),u=I("identicalElementShapes",r,t,e),l=I("name",r,t,e),c=new Qb(l,o,n,s,u,i,a);return e.addTensorArray(c),[c.idTensor,mt(1)]}case"TensorArrayWriteV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e);return[e.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("dtype",r,t,e);return[e.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id),s=I("dtype",r,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let n=I("tensorArrayId",r,t,e),o=I("tensor",r,t,e),s=I("lengths",r,t,e),i=e.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return[mt(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=I("indices",r,t,e),o=I("tensor",r,t,e),s=I("elementShape",r,t,e),i=I("numElements",r,t,e),a=eR(o,n,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=I("elementShape",r,t,e),o=I("elementDType",r,t,e),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=I(s,r,t,e),a=r.op==="TensorListReserve"?-1:i,u=tR(n,o,i,a);return e.addTensorList(u),[u.idTensor]}case"TensorListGather":{let n=I("tensorListId",r,t,e),o=I("indices",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=I("numElements",r,t,e);return[e.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=QD(n,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id),s=I("dtype",r,t,e),i=I("elementShape",r,t,e);return[o.concat(s,i)]}case"TensorListPushBack":{let n=I("tensorListId",r,t,e),o=I("tensor",r,t,e),s=e.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e);return[e.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("lengths",r,t,e),i=rR(n,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id);return[mt(o.size(),"int32")]}case"TensorListResize":{let n=I("tensorListId",r,t,e),o=I("size",r,t,e),i=e.getTensorList(n.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function oR(r,t,e){let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=I("numArgs",r,t,e);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=I("strides",r,t,e),p=Gh(r,t,e),m=I("dataFormat",r,t,e).toUpperCase(),f=I("dilations",r,t,e),[d,h]=I("args",r,t,e);i&&(h=d,d=void 0);let g=I("leakyreluAlpha",r,t,e);return{stride:c,pad:p,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var sR=(r,t,e,n=ue)=>{switch(r.op){case"Conv1D":{let o=I("stride",r,t,e),s=I("pad",r,t,e),i=I("dataFormat",r,t,e).toUpperCase(),a=I("dilation",r,t,e);return[n.conv1d(I("x",r,t,e),I("filter",r,t,e),o,s,i,a)]}case"Conv2D":{let o=I("strides",r,t,e),s=Gh(r,t,e),i=I("dataFormat",r,t,e).toUpperCase(),a=I("dilations",r,t,e);return[n.conv2d(I("x",r,t,e),I("filter",r,t,e),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=oR(r,t,e);return[n.fused.conv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=oR(r,t,e);return[n.fused.depthwiseConv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=I("outputShape",r,t,e),s=I("strides",r,t,e),i=Gh(r,t,e);return[n.conv2dTranspose(I("x",r,t,e),I("filter",r,t,e),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=I("strides",r,t,e),s=Gh(r,t,e),i=I("dilations",r,t,e),a=I("dataFormat",r,t,e).toUpperCase();return[n.depthwiseConv2d(I("input",r,t,e),I("filter",r,t,e),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("dataFormat",r,t,e).toUpperCase(),a=I("dilations",r,t,e);return[n.conv3d(I("x",r,t,e),I("filter",r,t,e),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("kernelSize",r,t,e);return[n.avgPool(I("x",r,t,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("kernelSize",r,t,e);return[n.maxPool(I("x",r,t,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("kernelSize",r,t,e),a=I("includeBatchInIndex",r,t,e),{result:u,indexes:l}=n.maxPoolWithArgmax(I("x",r,t,e),[i[1],i[2]],[o[1],o[2]],s,a);return[u,l]}case"AvgPool3D":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("kernelSize",r,t,e);return[n.avgPool3d(I("x",r,t,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("kernelSize",r,t,e);return[n.maxPool3d(I("x",r,t,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=I("strides",r,t,e),s=I("pad",r,t,e),i=I("dilations",r,t,e),a=o[1],u=o[2],l=i[1],c=i[2];return[n.dilation2d(I("x",r,t,e),I("filter",r,t,e),[a,u],s,[l,c],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var iR=(r,t,e,n=ue)=>{switch(r.op){case"Fill":{let o=I("shape",r,t,e),s=I("dtype",r,t,e),i=I("value",r,t,e);return[n.fill(o,i,s)]}case"LinSpace":{let o=I("start",r,t,e),s=I("stop",r,t,e),i=I("num",r,t,e);return[n.linspace(o,s,i)]}case"Multinomial":{let o=I("logits",r,t,e),s=I("numSamples",r,t,e),i=I("seed",r,t,e);return[n.multinomial(o,s,i)]}case"OneHot":{let o=I("indices",r,t,e),s=I("depth",r,t,e),i=I("onValue",r,t,e),a=I("offValue",r,t,e),u=I("dtype",r,t,e);return[n.oneHot(o,s,i,a,u)]}case"Ones":return[n.ones(I("shape",r,t,e),I("dtype",r,t,e))];case"OnesLike":return[n.onesLike(I("x",r,t,e))];case"RandomStandardNormal":return[n.randomStandardNormal(I("shape",r,t,e),I("dtype",r,t,e),I("seed",r,t,e))];case"RandomUniform":return[n.randomUniform(I("shape",r,t,e),I("minval",r,t,e),I("maxval",r,t,e),I("dtype",r,t,e))];case"Range":{let o=I("start",r,t,e),s=I("stop",r,t,e),i=I("step",r,t,e);return[n.range(o,s,i,I("dtype",r,t,e))]}case"TruncatedNormal":{let o=I("shape",r,t,e),s=I("mean",r,t,e),i=I("stdDev",r,t,e),a=I("seed",r,t,e);return[n.truncatedNormal(o,s,i,I("dtype",r,t,e),a)]}case"Zeros":return[n.zeros(I("shape",r,t,e),I("dtype",r,t,e))];case"ZerosLike":return[n.zerosLike(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function IT(r,t,e){let n=I("boxes",r,t,e),o=I("scores",r,t,e),s=I("maxOutputSize",r,t,e),i=I("iouThreshold",r,t,e),a=I("scoreThreshold",r,t,e),u=I("softNmsSigma",r,t,e);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var aR=async(r,t,e,n,o=ue)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=IT(r,t,e),p=await o.image.nonMaxSuppressionWithScoreAsync(s,i,a,u,l,c);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=IT(r,t,e),c=I("padToMaxOutputSize",r,t,e),p=await o.image.nonMaxSuppressionPaddedAsync(s,i,a,u,l,c);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=IT(r,t,e);return[await o.image.nonMaxSuppressionAsync(s,i,a,u,l)]}case"Where":{let s=o.cast(I("condition",r,t,e),"bool"),i=[await o.whereAsync(s)];return s.dispose(),i}case"ListDiff":return o.setdiff1dAsync(I("x",r,t,e),I("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var lR=(r,t,e,n=ue)=>{switch(r.op){case"LowerBound":{let o=I("sortedSequence",r,t,e),s=I("values",r,t,e);return[n.lowerBound(o,s)]}case"TopKV2":{let o=I("x",r,t,e),s=I("k",r,t,e),i=I("sorted",r,t,e),a=n.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=I("sortedSequence",r,t,e),s=I("values",r,t,e);return[n.upperBound(o,s)]}case"Unique":{let o=I("x",r,t,e),s=n.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=I("x",r,t,e),s=I("axis",r,t,e),i=n.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var uR=(r,t,e,n=ue)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let o=I("default",r,t,e);return[wr(r.name,t,e)||o];case"Placeholder":return[wr(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=I("x",r,t,e);return[ri(c)]}case"IdentityN":return I("x",r,t,e).map(c=>ri(c));case"Snapshot":let s=I("x",r,t,e);return[ri(s)];case"Shape":return[n.tensor1d(I("x",r,t,e).shape,"int32")];case"ShapeN":return I("x",r,t,e).map(c=>n.tensor1d(c.shape));case"Size":return[n.scalar(I("x",r,t,e).size,"int32")];case"Rank":return[n.scalar(I("x",r,t,e).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let i=I("x",r,t,e),a=I("data",r,t,e),u=I("message",r,t,e),l=I("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var tw=class{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=mt(0),this.tensorMap=new Map,Oe(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),G(()=>{let o=Tr(e),s=n.length,i=o.length;y.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];Oe(l),this.tensorMap.set(u,l)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return G(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,e);o.push(a)}return sr(o)})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n!=null?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var cR=async(r,t,e,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=I("keyDType",r,t,e),s=I("valueDType",r,t,e),i=new tw(o,s);return n.addHashTable(r.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("values",r,t,e);return[await n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("defaultValue",r,t,e);return[await n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=I("tableHandle",r,t,e,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var pR=(r,t,e,n=ue)=>{switch(r.op){case"ResizeBilinear":{let o=I("images",r,t,e),s=I("size",r,t,e),i=I("alignCorners",r,t,e),a=I("halfPixelCenters",r,t,e);return[n.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=I("images",r,t,e),s=I("size",r,t,e),i=I("alignCorners",r,t,e),a=I("halfPixelCenters",r,t,e);return[n.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=I("image",r,t,e),s=I("boxes",r,t,e),i=I("boxInd",r,t,e),a=I("cropSize",r,t,e),u=I("method",r,t,e),l=I("extrapolationValue",r,t,e);return[n.image.cropAndResize(o,s,i,a,u,l)]}case"ImageProjectiveTransformV3":{let o=I("images",r,t,e),s=I("transforms",r,t,e),i=I("outputShape",r,t,e),a=I("fillValue",r,t,e),u=I("interpolation",r,t,e),l=I("fillMode",r,t,e);return[n.image.transform(o,s,u.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var mR=(r,t,e,n=ue)=>{switch(r.op){case"Equal":return[n.equal(I("a",r,t,e),I("b",r,t,e))];case"NotEqual":return[n.notEqual(I("a",r,t,e),I("b",r,t,e))];case"Greater":return[n.greater(I("a",r,t,e),I("b",r,t,e))];case"GreaterEqual":return[n.greaterEqual(I("a",r,t,e),I("b",r,t,e))];case"Less":return[n.less(I("a",r,t,e),I("b",r,t,e))];case"LessEqual":return[n.lessEqual(I("a",r,t,e),I("b",r,t,e))];case"LogicalAnd":return[n.logicalAnd(I("a",r,t,e),I("b",r,t,e))];case"LogicalNot":return[n.logicalNot(I("a",r,t,e))];case"LogicalOr":return[n.logicalOr(I("a",r,t,e),I("b",r,t,e))];case"Select":case"SelectV2":return[n.where(I("condition",r,t,e),I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var fR=(r,t,e,n=ue)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(I("a",r,t,e),I("b",r,t,e),I("transposeA",r,t,e),I("transposeB",r,t,e))];case"Einsum":return[n.einsum(I("equation",r,t,e),...I("tensors",r,t,e))];case"Transpose":return[n.transpose(I("x",r,t,e),I("perm",r,t,e))];case"_FusedMatMul":let[o,s]=I("fusedOps",r,t,e),i=o==="biasadd",a=s==="prelu",u=I("numArgs",r,t,e),l=I("leakyreluAlpha",r,t,e);if(i){if(a&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,p]=I("args",r,t,e);return[n.fused.matMul({a:I("a",r,t,e),b:I("b",r,t,e),transposeA:I("transposeA",r,t,e),transposeB:I("transposeB",r,t,e),bias:c,activation:s,preluActivationWeights:p,leakyreluAlpha:l})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var dR=(r,t,e,n=ue)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(I("x",r,t,e),I("axis",r,t,e),I("keepDims",r,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"FusedBatchNormV3":return[n.batchNorm(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"LRN":return[n.localResponseNormalization(I("x",r,t,e),I("radius",r,t,e),I("bias",r,t,e),I("alpha",r,t,e),I("beta",r,t,e))];case"Softmax":return[n.softmax(I("x",r,t,e))];case"LogSoftmax":return[n.logSoftmax(I("x",r,t,e))];case"SparseToDense":return[n.sparseToDense(I("sparseIndices",r,t,e),I("outputShape",r,t,e),I("sparseValues",r,t,e),I("defaultValue",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var hR=(r,t,e,n=ue)=>{switch(r.op){case"Max":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.max(I("x",r,t,e),a,u)]}case"Mean":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.mean(I("x",r,t,e),a,u)]}case"Min":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.min(I("x",r,t,e),a,u)]}case"Sum":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.sum(I("x",r,t,e),a,u)]}case"All":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.all(I("x",r,t,e),a,u)]}case"Any":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.any(I("x",r,t,e),a,u)]}case"ArgMax":{let a=I("axis",r,t,e);return[n.argMax(I("x",r,t,e),a)]}case"ArgMin":{let a=I("axis",r,t,e);return[n.argMin(I("x",r,t,e),a)]}case"Prod":{let a=I("axis",r,t,e),u=I("keepDims",r,t,e);return[n.prod(I("x",r,t,e),a,u)]}case"Cumprod":{let a=I("axis",r,t,e),u=I("exclusive",r,t,e),l=I("reverse",r,t,e);return[n.cumprod(I("x",r,t,e),a,u,l)]}case"Cumsum":{let a=I("axis",r,t,e),u=I("exclusive",r,t,e),l=I("reverse",r,t,e);return[n.cumsum(I("x",r,t,e),a,u,l)]}case"Bincount":let o=I("x",r,t,e),s=I("weights",r,t,e),i=I("size",r,t,e);return[n.bincount(o,s,i)];case"DenseBincount":{let a=I("x",r,t,e),u=I("weights",r,t,e),l=I("size",r,t,e),c=I("binaryOutput",r,t,e);return[n.denseBincount(a,u,l,c)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var gR=(r,t,e,n=ue)=>{switch(r.op){case"ConcatV2":case"Concat":{let o=I("n",r,t,e),s=I("axis",r,t,e),i=I("tensors",r,t,e);return i=i.slice(0,o),[n.concat(i,s)]}case"Gather":{let o=I("x",r,t,e),s=I("indices",r,t,e);return[n.gather(o,n.cast(s,"int32"),0)]}case"GatherV2":{let o=I("axis",r,t,e),s=I("batchDims",r,t,e),i=I("x",r,t,e),a=I("indices",r,t,e);return[n.gather(i,n.cast(a,"int32"),o,s)]}case"Reverse":{let o=I("dims",r,t,e),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=I("x",r,t,e);return[n.reverse(i,s)]}case"ReverseV2":{let o=I("axis",r,t,e),s=I("x",r,t,e);return[n.reverse(s,o)]}case"Slice":{let o=I("begin",r,t,e),s=I("size",r,t,e);return[n.slice(I("x",r,t,e),o,s)]}case"StridedSlice":{let o=I("begin",r,t,e),s=I("end",r,t,e),i=I("strides",r,t,e),a=I("beginMask",r,t,e),u=I("endMask",r,t,e),l=I("ellipsisMask",r,t,e),c=I("newAxisMask",r,t,e),p=I("shrinkAxisMask",r,t,e),m=I("x",r,t,e);return[n.stridedSlice(m,o,s,i,a,u,l,c,p)]}case"Pack":return G(()=>{let o=I("axis",r,t,e),s=I("tensors",r,t,e),i=s[0].shape,a=n.squeeze(s[0]).shape,u=s.map(l=>{let c=y.arraysEqual(l.shape,i);if(!c&&!y.arraysEqual(n.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return c?l:n.reshape(l,i)});return[n.stack(u,o)]});case"Unpack":{let o=I("axis",r,t,e),s=I("tensor",r,t,e);return n.unstack(s,o)}case"Tile":{let o=I("reps",r,t,e);return[n.tile(I("x",r,t,e),o)]}case"Split":case"SplitV":{let o=I("axis",r,t,e),s=I("numOrSizeSplits",r,t,e),i=I("x",r,t,e);return n.split(i,s,o)}case"ScatterNd":{let o=I("indices",r,t,e),s=I("values",r,t,e),i=I("shape",r,t,e);return[n.scatterND(o,s,i)]}case"GatherNd":{let o=I("x",r,t,e),s=I("indices",r,t,e);return[n.gatherND(o,s)]}case"SparseToDense":{let o=I("sparseIndices",r,t,e),s=I("outputShape",r,t,e),i=I("sparseValues",r,t,e),a=I("defaultValue",r,t,e);return[n.sparseToDense(o,i,s,i.dtype===a.dtype?a:n.cast(a,i.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var xR=(r,t,e,n=ue)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=n.sparse.sparseFillEmptyRows(I("indices",r,t,e),I("values",r,t,e),I("denseShape",r,t,e),I("defaultValue",r,t,e));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=n.sparse.sparseReshape(I("inputIndices",r,t,e),I("inputShape",r,t,e),I("newShape",r,t,e));return[o,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var yR=(r,t,e,n=ue)=>{switch(r.op){case"FFT":return[n.fft(I("x",r,t,e))];case"IFFT":return[n.ifft(I("x",r,t,e))];case"RFFT":return[n.rfft(I("x",r,t,e))];case"IRFFT":return[n.irfft(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var bR=(r,t,e,n=ue)=>{switch(r.op){case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=n.string.stringNGrams(I("data",r,t,e),I("dataSplits",r,t,e),I("separator",r,t,e),I("nGramWidths",r,t,e),I("leftPad",r,t,e),I("rightPad",r,t,e),I("padWidth",r,t,e),I("preserveShortSequences",r,t,e));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=n.string.stringSplit(I("input",r,t,e),I("delimiter",r,t,e),I("skipEmpty",r,t,e));return[o,s,i]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(I("input",r,t,e),I("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var wR=(r,t,e,n=ue)=>{switch(r.op){case"Cast":return[n.cast(I("x",r,t,e),I("dtype",r,t,e))];case"ExpandDims":{let o=I("axis",r,t,e);return[n.expandDims(I("x",r,t,e),o)]}case"Squeeze":{let o=I("axis",r,t,e);return[n.squeeze(I("x",r,t,e),o)]}case"Reshape":return[n.reshape(I("x",r,t,e),I("shape",r,t,e))];case"MirrorPad":return[n.mirrorPad(I("x",r,t,e),I("padding",r,t,e),I("mode",r,t,e))];case"PadV2":case"Pad":return[n.pad(I("x",r,t,e),I("padding",r,t,e),I("constantValue",r,t,e))];case"SpaceToBatchND":{let o=I("blockShape",r,t,e),s=I("paddings",r,t,e);return[n.spaceToBatchND(I("x",r,t,e),o,s)]}case"BatchToSpaceND":{let o=I("blockShape",r,t,e),s=I("crops",r,t,e);return[n.batchToSpaceND(I("x",r,t,e),o,s)]}case"DepthToSpace":{let o=I("blockSize",r,t,e),s=I("dataFormat",r,t,e).toUpperCase();return[n.depthToSpace(I("x",r,t,e),o,s)]}case"BroadcastTo":return[n.broadcastTo(I("x",r,t,e),I("shape",r,t,e))];case"BroadcastArgs":return[n.broadcastArgs(I("s0",r,t,e),I("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function ST(r,t,e,n,o=G){let s=((i,a,u)=>{switch(i.category){case"arithmetic":return o(()=>YD(i,a,u));case"basic_math":return o(()=>ZD(i,a,u));case"control":return nR(i,a,u);case"convolution":return o(()=>sR(i,a,u));case"creation":return o(()=>iR(i,a,u));case"dynamic":return aR(i,a,u);case"evaluation":return o(()=>lR(i,a,u));case"image":return o(()=>pR(i,a,u));case"graph":return o(()=>uR(i,a,u));case"logical":return o(()=>mR(i,a,u));case"matrices":return o(()=>fR(i,a,u));case"normalization":return o(()=>dR(i,a,u));case"reduction":return o(()=>hR(i,a,u));case"slice_join":return o(()=>gR(i,a,u));case"sparse":return o(()=>xR(i,a,u));case"spectral":return o(()=>yR(i,a,u));case"string":return o(()=>bR(i,a,u));case"transformation":return o(()=>wR(i,a,u));case"hash_table":return cR(i,a,u,n);case"custom":let l=zb(i.op);if(l&&l.customExecutor)return l.customExecutor(new Zb(i,a,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return y.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var Uh=class{constructor(t={},e={},n={},o={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function TT(r,t,e,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=Object.keys(r).map(m=>yn(m)[0]),c=[];n!=null&&(c=n.map(m=>yn(m.name)[0]));let p=[...t];for(;p.length>0;){let m=p.pop();if((NT(m)||KZ(m)||jZ(m))&&i==null&&(i=m,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),e[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:r,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function CR(r,t,e){let{usedNodes:n,inputs:o}=e,s=[],i=Object.keys(o).map(c=>yn(c)[0]).map(c=>r.nodes[c]),a=r.initNodes;i.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{n.has(c.name)&&s.push(c)});let u=new Set,l=[];for(;s.length>0;){let c=s.pop();u.add(c.name),t[c.name]||l.push(c),c.children.forEach(p=>{!u.has(p.name)&&n.has(p.name)&&p.inputs.every(m=>u.has(m.name))&&s.push(p)})}return l}var UZ=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],HZ=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],qZ=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function NT(r){return UZ.indexOf(r.op)>=0}function KZ(r){return HZ.indexOf(r.op)>=0}function jZ(r){return qZ.indexOf(r.op)>=0}var Rc=class{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new Rc(t.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(n=>t[n].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let n=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(t,e){let n=TT(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let a=e.map(l=>l.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return CR(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=n.map(p=>this.graph.nodes[yn(p)[0]]),s=e.map(p=>yn(p)[0]),i=s.map(p=>this.graph.nodes[p]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);let a=this.getCompilationKey(o,i),u=this.compiledMap.get(a);u==null&&(u=this.compile(t,i),this.compiledMap.set(a,u));let l={},c={};return G(()=>{let p=new Uh(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(t).forEach(h=>{let[g,x]=yn(h),b=[];b[x]=t[h],m[g]=b});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let x=ST(g,m,p,this._resourceManager);if(y.isPromise(x))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=x,this.checkTensorForDisposal(g.name,g,m,p,f,s,d)}}return this.parent==null&&p.dispose(f),e.map(h=>wr(h,m,p))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,n,o,s,i,a){e.category==="control"||i.indexOf(t)!==-1||(n[t].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+e.children.length)}),e.inputs.forEach(u=>{if(u.category!=="control"){let l=qD(u.name,n,o);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let p=a[c.id];if(p===1){if(!this.keepTensorForDebug)c.dispose();else{let[m,f]=_o(e.name,o);this.intermediateTensors[m]?this.intermediateTensors[m][f]=c:(this.intermediateTensors[m]=[],this.intermediateTensors[m][f]=c)}delete a[c.id]}else p!=null&&a[c.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let t in this.intermediateTensors)this.intermediateTensors[t].forEach(e=>e.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,e,n=!1,o={},s={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepTensorForDebug=B().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();let i=new Uh(this.weightMap,o,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,i,e,n);let a=e.map(c=>wr(c,this.tensorsMap,i)),u=a.map(c=>c.id),l=Object.keys(t).map(c=>t[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(t,e,n){let o=t.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,o){let s=Object.keys(t),i=s.map(w=>this.graph.nodes[yn(w)[0]]),a=n.map(w=>yn(w)[0]),u=a.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:c,dynamicNode:p,syncInputs:m}=TT(t,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:e.currentContext})),d=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[C,T]=yn(w),E=[];E[T]=t[w],d[C]=E});let h={},g=this.getFrozenTensorIds(d),x={};for(;f.length>0;){let w=this.processStack(i,f,e,d,x,g,a,h,l);await Promise.all(w)}p==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=u.filter(w=>!NT(w)&&!wr(w.name,d,e)).map(w=>w.name);if(b.length>0){let w="";throw p!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${w}`)}return d}processStack(t,e,n,o,s,i,a,u,l){let c=[];for(;e.length>0;){let p=e.pop();n.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&I("isConstant",p.node,o,n)&&([m]=_o(p.node.name,n)),o[p.node.name]==null){let f=ST(p.node,o,n,this._resourceManager);m||([m]=_o(p.node.name,n));let d=n.currentContext;y.isPromise(f)?c.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l),h))):(o[m]=f,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l))}else this.processChildNodes(p.node,e,n,o,s,l)}return c}processChildNodes(t,e,n,o,s,i){t.children.forEach(a=>{let[u]=_o(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!wr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!wr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let n=t[e],[o]=yn(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);y.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){let e={};for(let n in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];e[o.name]=t[n]}else e[n]=t[n];return e}checkInputs(t){let e=Object.keys(t).filter(n=>{let[o]=yn(n);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{let[n]=yn(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}};var ew=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var XZ="?tfjs-format=file",YZ="model.json",Hh=class{constructor(t,e={},n=vn){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=n,e==null&&(this.loadOptions={}),this.resourceManager=new ew}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{let e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=this.handler.load();return y.isPromise(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let o=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Rc(Wh.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=Wh.Instance.transformGraph(t.modelInitializer);this.initializer=new Rc(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let n=this.io.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){let n=this.execute(t,this.outputNodes);if(this.structuredOutputKeys){let o=n instanceof Lt?[n]:n,s={};return o.forEach((i,a)=>s[this.structuredOutputKeys[a]]=i),s}return n}normalizeInputs(t){if(!(t instanceof Lt)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,o)=>(e[n]=t[o],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function ZZ(r,t={},e=vn){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof r=="string"&&(r=QZ(r));let n=new Hh(r,t,e);return await n.load(),n}function JZ(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!r.load)throw new Error(`modelUrl IO Handler ${r} has no load function`);let t=new Hh(r);return t.load(),t}function QZ(r){return r.endsWith("/")||(r=r+"/"),`${r}${YZ}${XZ}`}var vR="3.20.0";var GR={};jt(GR,{CSVDataset:()=>id,Dataset:()=>ni,FileDataSource:()=>pd,TextLineDataset:()=>sd,URLDataSource:()=>md,array:()=>DR,csv:()=>LR,func:()=>MR,generator:()=>zR,microphone:()=>VR,version_data:()=>KT,webcam:()=>BR,zip:()=>RR});var $R=Tl(vh());var _R=Tl(vh());function IR(r,t){return rw(r,t)}function rw(r,t,e=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(Su(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let a=r[i],u=rw(a,t,e,n);s[i]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,o.value),o.value}function SR(r,t=_T){return TR(r,t)}function TR(r,t,e=new Set){let n=r[0];if(e.has(n))throw new Error("Circular references are not supported.");let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(Su(n)){let s=Array.isArray(n)?[]:{};e.add(n);for(let i in n){let a=r.map(l=>l[i]),u=TR(a,t,e);s[i]=u}return e.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function _T(r){return r===null?null:Su(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function nw(r,t){let e=new Map;rw(r,t,e);for(let o of Array.from(e.keys())){let s=e.get(o);if(y.isPromise(s)){let i=await s;e.set(o,i)}}return rw(r,t,e)}function Su(r){let t=!1;if(B().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:e}=kT();t=r instanceof e}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Lt)&&!(r instanceof Promise)&&!t)}function NR(r){return r==null||tJ(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Lt||y.isTypedArray(r)}function tJ(r){return r===null||typeof r!="object"&&typeof r!="function"}function kR(r){return IR(r,eJ)}function eJ(r){return r instanceof Lt?{value:r.clone(),recurse:!1}:Su(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var od=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}};var Fc=class extends od{constructor(){super(Fc.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),n=this.length();for(let o=0;o<n;o++)e[o]=this.get(this.wrap(this.begin+o));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};Fc.INITIAL_CAPACITY=32;function VT(r){return new ET(r)}function qh(r){return new AT(r)}function ER(r,t){return new sw(r,t)}function AR(r,t=ml.FAIL){return new zT(r,t)}var Qe=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new LT(this,t)}filter(t){return new OT(this,t)}map(t){return new PT(this,t)}mapAsync(t){return new ow(this,t)}serialMapAsync(t){return new ow(this,t).serial()}flatmap(t){return new MT(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new FT(this,t,e)}columnMajorBatch(t,e=!0,n=_T){return this.rowMajorBatch(t,e).map(s=>SR(s,n))}concatenate(t,e){return new sw(VT([this,t]),e)}take(t){return t<0||t==null?this:new RT(this,t)}skip(t){return t<0||t==null?this:new DT(this,t)}prefetch(t){return new iw(this,t)}shuffle(t,e){return new BT(this,t,e)}serial(){return new $T(this)}},ET=class extends Qe{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:kR(t),done:!1}}},AT=class extends Qe{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},$T=class extends Qe{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},DT=class extends Qe{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;_t(t.value)}return this.upstream.next()}},RT=class extends Qe{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},FT=class extends Qe{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}},OT=class extends Qe{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;_t(t.value)}}},PT=class extends Qe{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=ho.getTensorsInContainer(t.value),n=this.transform(t.value),o=ho.getTensorsInContainer(n);for(let s of e)ho.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},LT=class extends Qe{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},ow=class extends Qe{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=ho.getTensorsInContainer(t.value),n=await this.transform(t.value),o=ho.getTensorsInContainer(n);for(let s of e)ho.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},Oc=class extends Qe{constructor(){super(),this.outputQueue=new Fc,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},MT=class extends Oc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=ho.getTensorsInContainer(t.value),n=this.transform(t.value),o=ho.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of e)ho.isTensorInList(s,o)||s.dispose();return!0}},sw=class extends Qe{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}},ml;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(ml||(ml={}));var zT=class extends Qe{constructor(t,e=ml.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,n=0;function o(i){return i instanceof Qe?{value:i.next().then(u=>(e++,u.done&&n++,u.value)),recurse:!1}:{value:null,recurse:!0}}let s=await nw(this.iterators,o);if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case ml.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ml.SHORTEST:return{value:null,done:!0};case ml.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},iw=class extends Qe{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new od(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},BT=class extends iw{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=_R.alea(n||y.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}};var ni=class{constructor(){this.size=null}batch(t,e=!0){let n=this;y.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let o;return this.size===1/0||this.size==null?o=this.size:e?o=Math.ceil(this.size/t):o=Math.floor(this.size/t),En(async()=>(await n.iterator()).columnMajorBatch(t,e,rJ),o)}concatenate(t){let e=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,En(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===1/0?n=1/0:n=null,En(async()=>(await e.iterator()).filter(o=>G(()=>t(o))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return En(async()=>(await e.iterator()).map(n=>G(()=>t(n))),this.size)}mapAsync(t){let e=this;return En(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return En(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,En(async()=>{let o=qh(async()=>({value:await e.iterator(),done:!1}));return ER(o.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,En(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=$R.alea(e||y.now().toString());return En(async()=>{let i=s.int32();return n&&(i+=s.int32()),(await o.iterator()).shuffle(t,i.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,En(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};ni.MAX_BUFFER_SIZE=1e4;function En(r,t=null){return new class extends ni{constructor(){super(...arguments),this.size=t}async iterator(){return r()}}}function DR(r){return En(async()=>VT(r),r.length)}function RR(r){if(!Su(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let e=0;e<r.length;e++)t=t==null?r[e].size:Math.min(t,r[e].size);else if(r instanceof Object)for(let e in r)t=t==null?r[e].size:Math.min(t,r[e].size);return En(async()=>{let e=await nw(r,n=>{if(n instanceof ni)return{value:n.iterator(),recurse:!1};if(Su(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return AR(e,ml.SHORTEST)},t)}function rJ(r){if(r===null)return null;let t=r[0];return NR(t)?{value:nJ(r),recurse:!1}:{value:null,recurse:!0}}function nJ(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Lt?sr(r):vr(r)}var sd=class extends ni{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var aw='"',Kh=Symbol("out"),FR=Symbol("field"),lw=Symbol("quote"),GT=Symbol("quoteafterquote"),OR=Symbol("quoteinquote"),id=class extends ni{constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new sd(t),e||(e={}),this.hasHeader=e.hasHeader!==!1,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(y.assert(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&y.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(e).filter(o=>e[o]>1);if(y.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let n=e.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let i=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!a)){let u=e[s],l=null;if(u==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${i} is empty in this line: ${t}`);l=void 0}else{let c=Number(u);if(isNaN(c))a&&a.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!a||!a.dtype)l=c;else switch(a.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(u);break;default:l=c}}a&&a.isLabel?o[i]=l:n[i]=l}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let n=[],o=0,s=t.length,i=Kh;for(let a=0;a<s;a++)switch(i){case Kh:switch(t.charAt(a)){case aw:o=a+1,i=lw;break;case this.delimiter:if(o=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),i=Kh;break;default:i=FR,o=a;break}break;case FR:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a)),i=Kh,o=a+1;break;default:}break;case lw:switch(t.charAt(a)){case aw:i=GT;break;default:}break;case GT:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a-1)),i=Kh,o=a+1;break;case aw:i=lw;break;default:i=OR;break}break;case OR:switch(t.charAt(a)){case aw:i=lw;break;default:}break;default:}if(i===GT?n.push(t.substring(o,s-1)):n.push(t.substring(o)),e&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var ad=class extends Qe{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!B().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let e=new ad(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],e=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((o,s)=>n.set(o,s*e)),n}getTensorFromAudioDataArray(t,e){let n=new Float32Array(y.sizeFromShape(e));return n.set(t,n.length-t.length),vr(n,e)}};var ld=class extends Qe{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ve([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,i=(1-o)/2,a=s+n,u=o+i;this.cropBox=Ks([i,s,u,a],[1,4])}else this.cropBox=Ks([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(!B().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}let n=new ld(t,e);return await n.start(),n}async start(){this.webcamConfig.facingMode&&y.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=xx.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return G(()=>{let e=yr(tt(t,"float32"),0),n;n=uu.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return F(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var ud=class{};var jh=class extends Qe{split(t){return new WT(this,t)}},WT=class extends jh{constructor(t,e){super(),this.upstream=t,this.impl=new UT(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},UT=class extends Oc{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let n of e.slice(0,-1))this.outputQueue.push(n);return this.carryover=e[e.length-1],!0}};var uw=class extends Qe{decodeUTF8(){return new HT(this)}},HT=class extends jh{constructor(t){super(),this.upstream=t,this.impl=new qT(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},qT=class extends Oc{constructor(t){if(super(),this.upstream=t,B().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=kT();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let n;return B().get("IS_BROWSER")?n=this.decoder.decode(e,{stream:!0}):n=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(n),!0}};var cd=class extends uw{constructor(t,e={}){super(),this.file=t,this.options=e,y.assert(t instanceof Uint8Array||(B().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=a=>{let u=s.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));e(u)},s.onabort=a=>n(new Error("Aborted")),s.onerror=a=>n(new Error(a.type));let i=this.file.slice(this.offset,o);s.readAsArrayBuffer(i)}this.offset=o}),done:!1}}};async function PR(r,t={},e){let n,o;typeof r=="string"?n=r:(n=r.url,o=oJ(r));let s=await(e||y.fetch)(n,o);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new cd(i,t)}else throw new Error(s.statusText)}var oJ=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function cw(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var pd=class extends ud{constructor(t,e={}){super(),this.input=t,this.options=e}async iterator(){if(cw(this.input)&&B().get("IS_NODE")){let t=pw();this.input=t.readFileSync(this.input.slice(7))}return new cd(this.input,this.options)}};var md=class extends ud{constructor(t,e={}){super(),this.url=t,this.fileOptions=e}async iterator(){return cw(this.url)?new pd(this.url,this.fileOptions).iterator():PR(this.url,this.fileOptions)}};function LR(r,t={}){return new id(new md(r),t)}function MR(r){let t=qh(r);return En(async()=>t)}function zR(r){return En(async()=>{let t=await r();return qh(()=>t.next())})}async function BR(r,t){return ld.create(r,t)}async function VR(r){return ad.create(r)}var KT="3.20.0";function nt(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&y.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var sJ=Vr.whereImpl,Tu=class extends Ho{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ra(this,go())}nextDataId(){return Tu.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,B().get("IS_NODE")&&S.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:n,refCount:1}),o}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(i=>y.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return{dataId:o,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,n,o,s){this.data.set(t,{values:e,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:n}=this.data.get(t);if(e==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return S.mergeRealAndImagArrays(o,s)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId);if(t.dtype==="string")try{let n=e.map(o=>y.decodeString(o));return vt(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(t.shape,t.dtype,e)}makeOutput(t,e,n){return go().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let e=y.now();return t(),{kernelMs:y.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){nt([t],"where");let e=this.readSync(t.dataId);return sJ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Tu.nextDataId=0;var Sw={};jt(Sw,{addImpl:()=>YT,bincountImpl:()=>hd,bincountReduceImpl:()=>mw,castImpl:()=>XT,ceilImpl:()=>ZT,concatImpl:()=>Pc,equalImpl:()=>JT,expImpl:()=>tN,expm1Impl:()=>rN,floorImpl:()=>nN,gatherNdImpl:()=>fw,gatherV2Impl:()=>dw,greaterEqualImpl:()=>sN,greaterImpl:()=>oN,lessEqualImpl:()=>aN,lessImpl:()=>iN,linSpaceImpl:()=>hw,logImpl:()=>lN,maxImpl:()=>gw,maximumImpl:()=>uN,minimumImpl:()=>cN,multiplyImpl:()=>Xh,negImpl:()=>pN,notEqualImpl:()=>mN,prodImpl:()=>fN,raggedTensorToTensorImpl:()=>xw,rangeImpl:()=>Mc,rsqrtImpl:()=>dN,scatterImpl:()=>fl,sigmoidImpl:()=>hF,simpleAbsImpl:()=>jT,sliceImpl:()=>zc,sparseFillEmptyRowsImpl:()=>yw,sparseReshapeImpl:()=>bw,sparseSegmentReductionImpl:()=>yd,sqrtImpl:()=>yF,squaredDifferenceImpl:()=>gN,stridedSliceImpl:()=>ww,stringNGramsImpl:()=>Bc,stringSplitImpl:()=>Vc,stringToHashBucketFastImpl:()=>Gc,subImpl:()=>yN,tileImpl:()=>Cw,topKImpl:()=>vw,transposeImpl:()=>gd,uniqueImpl:()=>Iw});function jT(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var iJ=r=>{let{x:t}=r.inputs,e=r.backend;nt(t,"abs");let n=new Float32Array(y.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return n=jT(o),e.makeOutput(n,t.shape,t.dtype)},WR={kernelName:pi,backendName:"cpu",kernelFunc:iJ};function re(r){return(t,e,n,o,s)=>{let i=S.assertAndGetBroadcastShape(t,e),a=i.length,u=y.computeStrides(i),l=y.sizeFromShape(i),c=y.getTypedArrayFromDType(s,l),p=t.length,m=e.length,f=y.computeStrides(t),d=y.computeStrides(e),h=S.getBroadcastDims(t,i),g=S.getBroadcastDims(e,i);if(h.length+g.length===0)for(let x=0;x<c.length;++x)c[x]=r(n[x%n.length],o[x%o.length]);else for(let x=0;x<c.length;++x){let b=y.indexToLoc(x,a,u),w=b.slice(-p);h.forEach($=>w[$]=0);let C=y.locToIndex(w,p,f),T=b.slice(-m);g.forEach($=>T[$]=0);let E=y.locToIndex(T,m,d);c[x]=r(n[C],o[E])}return[c,i]}}function Cr(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(a.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var UR={kernelName:Np,backendName:"cpu",kernelFunc:Cr};function fd(r,t,e="float32"){if(e==="complex64"){let o=fd(r,t,"float32"),s=fd(r,t,"float32");return Cr({inputs:{real:o,imag:s},backend:r})}let n=y.makeZerosTypedArray(y.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function Ur(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var HR={kernelName:uo,backendName:"cpu",kernelFunc:Ur};function Eo(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var qR={kernelName:qp,backendName:"cpu",kernelFunc:Eo};function XT(r,t,e,n){if(n==="int32"){let o=Int32Array.from(r);return[t,"int32",o]}if(n==="bool"){let o=y.toTypedArray([0],e),[s,i]=re((a,u)=>a!==u?1:0)(t,[],r,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${n}`)}function Ao(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Ur({inputs:{x:o},backend:e});let c=fd(e,o.shape,o.dtype),p=Ao({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),m=Cr({inputs:{real:p,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),m}if(o.dtype==="complex64"){let c=Eo({inputs:{input:o},backend:e}),p=Ao({inputs:{x:c},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(c),p}if(!y.hasEncodingLoss(o.dtype,s)){let c=Ur({inputs:{x:o},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=e.data.get(o.dataId).values,[a,u,l]=XT(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,u,l)}var KR={kernelName:ao,backendName:"cpu",kernelFunc:Ao};function ie(r,t,e,n){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;nt([i,a],r);let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(l):l,m=i.dtype==="string"?S.fromUint8ToStringArray(c):c,f=n||i.dtype,[d,h]=t(i.shape,a.shape,p,m,f);return u.makeTensorInfo(h,f,d)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=Ao({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=u.data.get(p.dataId).values,d=u.data.get(m.dataId).values,h=Ao({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),x=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,w=u.data.get(x.dataId).values,C=u.data.get(b.dataId).values,[T,E,$]=e(i.shape,a.shape,f,d,w,C),D=u.makeTensorInfo($,"float32",T),P=u.makeTensorInfo($,"float32",E),M=Cr({inputs:{real:D,imag:P},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(D),u.disposeIntermediateTensorInfo(P),M}else{let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=n||i.dtype,[m,f]=t(i.shape,a.shape,l,c,p);return u.makeTensorInfo(f,p,m)}}}function dd(r){return(t,e,n,o,s,i)=>{let a=S.assertAndGetBroadcastShape(t,e),u=y.sizeFromShape(a),l=a.length,c=y.computeStrides(a),p=y.getTypedArrayFromDType("float32",u),m=y.getTypedArrayFromDType("float32",u),f=S.getBroadcastDims(t,a),d=S.getBroadcastDims(e,a),h=S.mergeRealAndImagArrays(n,o),g=S.mergeRealAndImagArrays(s,i),x=t.length,b=y.computeStrides(t),w=e.length,C=y.computeStrides(e);if(f.length+d.length===0)for(let T=0;T<p.length;T++){let E=T%h.length,$=T%g.length,D=r(h[E*2],h[E*2+1],g[$*2],g[$*2+1]);p[T]=D.real,m[T]=D.imag}else for(let T=0;T<p.length;T++){let E=y.indexToLoc(T,l,c),$=E.slice(-x);f.forEach(H=>$[H]=0);let D=y.locToIndex($,x,b),P=E.slice(-w);d.forEach(H=>P[H]=0);let M=y.locToIndex(P,w,C),W=r(h[D*2],h[D*2+1],g[M*2],g[M*2+1]);p[T]=W.real,m[T]=W.imag}return[p,m,a]}}var YT=re((r,t)=>r+t),aJ=dd((r,t,e,n)=>({real:r+e,imag:t+n})),Qi=ie(jn,YT,aJ),jR={kernelName:jn,backendName:"cpu",kernelFunc:Qi};function hd(r,t,e,n,o){let s=y.sizeFromShape(n),i=y.makeZerosTypedArray(o,e);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=t[a]:i[u]+=1)}return i}function mw(r,t,e,n=!1){let o=r.shape[0],s=r.shape[1],i=vt([o,e],t.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(n?i.set(1,a,l):t.size>0?i.set(i.get(a,l)+t.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}function bn(r){return(t,e,n)=>{let o=y.getTypedArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=r(t[s],n);return o}}function Et(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(nt(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=y.sizeFromShape(i.shape),c=e||i.dtype,p=y.getArrayFromDType(c,l);for(let m=0;m<l;++m)p[m]=t(u[m],o);return a.makeTensorInfo(i.shape,c,p)}}function $o(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(nt(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=e||i.dtype,c=t(u,l,o);return a.makeTensorInfo(i.shape,l,c)}}var ZT=bn(r=>Math.ceil(r)),lJ=$o(Jo,ZT),XR={kernelName:Jo,backendName:"cpu",kernelFunc:lJ};function Pc(r,t,e,n){let o=y.getArrayFromDType(e,y.sizeFromShape(t));if(n&&e!=="string"){let s=0;r.forEach(i=>{let a=y.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=e==="string"?S.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let c=l*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[u++]}s+=i.shape[1]})}return o}var JT=re((r,t)=>r===t?1:0),QT=ie(xa,JT,null,"bool"),YR={kernelName:xa,backendName:"cpu",kernelFunc:QT};var tN=bn(r=>Math.exp(r)),eN=$o(as,tN,"float32"),ZR={kernelName:as,backendName:"cpu",kernelFunc:eN};var rN=bn(r=>Math.expm1(r)),uJ=$o(ya,rN),JR={kernelName:ya,backendName:"cpu",kernelFunc:uJ};var nN=bn(r=>Math.floor(r)),cJ=$o(ls,nN),QR={kernelName:ls,backendName:"cpu",kernelFunc:cJ};function fw(r,t,e,n,o,s,i,a,u){let l=vt([n,s],e);for(let c=0;c<n;c++){let p=[],m=0;for(let f=0;f<o;f++){let d=r[c*o+f];m+=d*i[f],p.push(d)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[c*s+f]=t.get(...t.indexToLoc(m*s+f))}return l}function dw(r,t,e){let n=vt(e,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=t.locToIndex([a,u]);i[2]=t.values[l];let c=r.locToIndex(i);0<=c&&c<r.values.length&&(n.values[o]=r.values[c])}return n}var oN=re((r,t)=>r>t?1:0),pJ=ie(Ca,oN,null,"bool"),tF={kernelName:Ca,backendName:"cpu",kernelFunc:pJ};var sN=re((r,t)=>r>=t?1:0),mJ=ie(ps,sN,null,"bool"),eF={kernelName:ps,backendName:"cpu",kernelFunc:mJ};var iN=re((r,t)=>r<t?1:0),fJ=ie(Ta,iN,null,"bool"),rF={kernelName:Ta,backendName:"cpu",kernelFunc:fJ};var aN=re((r,t)=>r<=t?1:0),dJ=ie(Na,aN,null,"bool"),nF={kernelName:Na,backendName:"cpu",kernelFunc:dJ};function hw(r,t,e){let n=(t-r)/(e-1),o=y.makeZerosTypedArray(e,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var lN=bn(r=>Math.log(r)),hJ=$o(fs,lN),oF={kernelName:fs,backendName:"cpu",kernelFunc:hJ};function gw(r,t,e,n){let o=y.getTypedArrayFromDType(n,y.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*t,a=r[i];for(let u=0;u<t;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var uN=re((r,t)=>Math.max(r,t)),gJ=ie(hs,uN),sF={kernelName:hs,backendName:"cpu",kernelFunc:gJ};var cN=re((r,t)=>Math.min(r,t)),xJ=ie(bs,cN),iF={kernelName:bs,backendName:"cpu",kernelFunc:xJ};var Xh=re((r,t)=>r*t),yJ=dd((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),Lc=ie(Cs,Xh,yJ),aF={kernelName:Cs,backendName:"cpu",kernelFunc:Lc};function pN(r,t,e){let n=y.createScalarValue(-1,e);return Xh([],t,n,r,e)}function bJ(r){let{inputs:t,backend:e}=r,{x:n}=t;nt(n,"neg");let o=e.data.get(n.dataId).values,[s,i]=pN(o,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,s)}var lF={kernelName:gi,backendName:"cpu",kernelFunc:bJ};var mN=re((r,t)=>r!==t?1:0),wJ=ie(Da,mN,null,"bool"),uF={kernelName:Da,backendName:"cpu",kernelFunc:wJ};function gd(r,t,e,n,o){let s=t.length,i=y.sizeFromShape(t),a=y.computeStrides(t),u=y.computeStrides(o),l=y.getTypedArrayFromDType(e,y.sizeFromShape(o));for(let c=0;c<i;++c){let p=y.indexToLoc(c,s,a),m=new Array(p.length);for(let d=0;d<m.length;d++)m[d]=p[n[d]];let f=y.locToIndex(m,s,u);l[f]=r[c]}return l}function Ue(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{perm:s}=e;nt(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let u=n.data.get(o.dataId).values,l=gd(u,o.shape,o.dtype,s,a);return{dataId:n.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var cF={kernelName:Yn,backendName:"cpu",kernelFunc:Ue};function fN(r,t,e,n){let[o,s]=S.computeOutAndReduceShapes(r,n),i=ir(t,"int32"),a=y.makeZerosTypedArray(y.sizeFromShape(o),i),u=y.sizeFromShape(s);for(let l=0;l<a.length;++l){let c=l*u,p=1;for(let m=0;m<u;++m)p*=e[c+m];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function CJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"prod");let a=o.shape.length,u=y.parseAxisParam(s,o.shape),l=S.getAxesPermutation(u,a),c=u,p=o,m=[];l!=null&&(p=Ue({inputs:{x:o},backend:e,attrs:{perm:l}}),m.push(p),c=S.getInnerMostAxes(c.length,a));let f=e.data.get(p.dataId).values,{outVals:d,outShape:h,outDtype:g}=fN(p.shape,p.dtype,f,c),x=h;return i&&(x=S.expandShapeToKeepDim(h,u)),m.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(x,g,d)}var pF={kernelName:Ns,backendName:"cpu",kernelFunc:CJ};var Do=S.RowPartitionType,xd=class{constructor(t,e,n,o,s,i,a,u,l,c){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=S.getRowPartitionTypesHelper(c),this.raggedRank=S.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Do.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Do.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Do.VALUE_ROWIDS:return xd.getMaxWidthValueRowID(e);case Do.ROW_SPLITS:return xd.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Do[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let e=t.length;if(e===0||e===1)return 0;let n=0;for(let o=0;o<e-1;++o){let s=t[o+1]-t[o];s>n&&(n=s)}return n}static getMaxWidthValueRowID(t){let e=t.length;if(e===0)return 0;let n=0,o=t[0],s=0;for(let i=1;i<e;++i){let a=t[i];a!==o&&(o=a,s=Math.max(i-n,s),n=i)}return Math.max(e-n,s)}tensorShapeFromTensor(t,e,n=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return fF(t,n)}calculateOutputSize(t){let e=this.valuesShape,n=this.defaultValueShape;S.validateDefaultValueShape(n,e);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=S.combineRaggedTensorToTensorShapes(this.raggedRank,o,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,n){let o=Math.min(t,n),s=[],i=0;for(let a=0;a<o;++a,i+=e)s.push(i);for(let a=o;a<t;++a)s.push(-1);return y.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,n,o){let s=t.length,i=[];for(let a=0;a<s-1;++a){let u=t[a+1]-t[a],l=Math.min(o,u),c=e[a];c===-1&&(l=0);for(let p=0;p<l;++p)i.push(c),c+=n;for(let p=0;p<u-l;++p)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,n,o){let s=t.length,i=[];if(s===0)return[];let a=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let l=e[u];i.push(l);for(let c=1;c<s;++c){let p=t[c];if(p===u)l>=0&&(++a,a<o?l+=n:l=-1);else{if(a=0,u=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);l=e[p]}i.push(l)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,n,o){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Do.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,n,o);case Do.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,n,o);default:throw new Error(`Unsupported partition type: ${Do[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Do.FIRST_DIM_SIZE:return t[0];case Do.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Do.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Do[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let u=o.length-2;u>=0;--u)o[u]=o[u+1]*n[u+1];let s=fF(n,!1),i=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*n[0]>0){let u=this.calculateFirstParentOutputIndex(e,o[0],n[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,o[l],n[l]);this.setOutput(this.raggedRank,u,i,s)}return[s,i]}setOutput(t,e,n,o){if(n.length===0)return;let s=this.values,i=n,a=o.slice();a=a.slice(t+1);let u=y.sizeFromShape(a),l=e.length,c=this.defaultValue;if(c.length!==u&&c.length!==1){let d=this.defaultValueShape;G(()=>{let h=F(c,d);c=Mi(h,a).dataSync()})}let p=0,m=0,f=0;for(let d=0;d<=l;++d){let h=d<l?e[d]:-1;if(h===f){++f;continue}if(m<f){let g=s.subarray(p*u),x=i.subarray(m*u),b=(f-m)*u;mF(x,g,b)}if(d>=l){let g=n.length;h=Math.floor(g/u)}if(h>f)if(this.defaultValue.length===1)i.subarray(f*u,h*u).fill(this.defaultValue[0]),f=h;else for(;h>f;){let g=i.slice(f*u);mF(g,c,u),++f}h<0?(p=d+1,m=f):(p=d,m=f,f=m+1)}}};function mF(r,t,e){for(let n=0;n<e;n++)r[n]=t[n]}function fF(r,t){let e=[];for(let n of r){if(n<0){if(!t)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}e.push(n)}return e}function xw(r,t,e,n,o,s,i,a,u,l){return new xd(r,t,e,n,o,s,i,a,u,l).compute()}function Mc(r,t,e,n){let o=r===t,s=r<t&&e<0,i=t<r&&e>1;if(o||s||i)return y.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((t-r)/e)),u=y.makeZerosTypedArray(a,n);t<r&&e===1&&(e=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+e;return u}var dN=bn(r=>1/Math.sqrt(r)),vJ=$o(Rs,dN),dF={kernelName:Rs,backendName:"cpu",kernelFunc:vJ};function fl(r,t,e,n,o,s,i,a,u,l){let c=[n/o,o],p=r.values,m=t.values;if(n===0)return vt(e,t.dtype);let f=vt(c,t.dtype);typeof u=="string"||typeof u=="number"?f.values.fill(u):typeof u=="boolean"&&f.values.fill(+u);for(let d=0;d<s;d++){let h=[],g=0;for(let x=0;x<i;x++){let b=p[d*i+x];h.push(b),g+=b*a[x]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${e}`);for(let x=0;x<o;x++)l?f.values[g*o+x]+=m[d*o+x]:f.values[g*o+x]=t.rank===0?m[0]:m[d*o+x]}return f}var hF=bn(r=>1/(1+Math.exp(-r))),hN=Et(Os,r=>1/(1+Math.exp(-r))),gF={kernelName:Os,backendName:"cpu",kernelFunc:hN};function zc(r,t,e,n,o){let s=Be.isSliceContinous(n,t,e),i=y.sizeFromShape(e),a=y.computeStrides(n);if(s){let p=Be.computeFlatOffset(t,a);return o==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let u=o==="string"?S.fromUint8ToStringArray(r):r,l=vt(n,o,u),c=vt(e,o);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((d,h)=>d+t[h]);c.set(l.get(...f),...m)}return o==="string"?S.fromStringArrayToUint8(c.values):c.values}function Ro(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n;nt(o,"slice");let[a,u]=Be.parseSliceParams(o,s,i);Be.assertParamsValid(o,a,u);let l=e.data.get(o.dataId).values,c=zc(l,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}var xF={kernelName:Ci,backendName:"cpu",kernelFunc:Ro};function yw(r,t,e,n,o,s,i){let a=t[0],u=s[0],l=new Array(u),c=new Array(a),p=t[1];if(u===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=y.getArrayFromDType(e,0),x=y.getArrayFromDType(o,0);return[g,[0,p],x,l,c]}let m=!0,f=0,d=new Array(u).fill(0);for(let g=0;g<a;++g){let x=r[g*p];if(x<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=u)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,u));++d[x],m=m&&x>=f,f=x}let h=!0;for(let g=0;g<u;++g){let x=d[g]===0;l[g]=x,h=h&&!x,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,x=n;for(let b=0;b<a;++b)c[b]=b;return[g,[a,p],x,l,c]}else{let g=d[u-1],x=y.getArrayFromDType(e,g*p),b=y.getArrayFromDType(o,g),w=new Array(u).fill(0);for(let C=0;C<a;++C){let T=r[C*p],E=w[T],$=(T===0?0:d[T-1])+E;w[T]++;for(let D=0;D<p;++D)x[$*p+D]=r[C*p+D];b[$]=n[C],c[C]=$}for(let C=0;C<u;++C)if(w[C]===0){let E=C===0?0:d[C-1];x[E*p+0]=C;for(let $=1;$<p;++$)x[E*p+$]=0;b[E]=i}return[x,[g,p],b,l,c]}}function bw(r,t,e,n,o){let s=y.sizeFromShape(n),i=t[0],a=o.length,u=[],l=1,c=-1;for(let g=0;g<a;++g){let x=o[g];if(x===-1){if(c!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,u.push(1)}else{if(x<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,x));l*=x,u.push(x)}}if(c!==-1){if(l<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[c]=g}if(y.sizeFromShape(u)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(a>0){d[a-1]=1;for(let g=a-2;g>=0;--g)d[g]=d[g+1]*u[g+1]}let h=y.getArrayFromDType(e,i*a);for(let g=0;g<i;++g){let x=0;for(let b=0;b<m;++b)x+=r[g*m+b]*f[b];for(let b=0;b<a;++b)h[g*a+b]=Math.trunc(x/d[b]),x%=d[b]}return[h,[i,a],u]}function yd(r,t,e,n,o,s=!1,i=0){let a=n.length,u=[t[0],r.length/t[0]],l=u[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=t.slice();m[0]=p;let f=m.reduce((w,C)=>w*C,1),d=y.getArrayFromDType(e,f);if(a===0)return p>0&&d.fill(i),[d,m];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,x=0,b=o[h];for(;;){let w=0;if(g<a){if(w=o[g],b===w){++g;continue}if(b>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>x&&d.fill(i,x*l,b*l);for(let C=h;C<g;++C){let T=n[C];if(T<0||T>=u[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(C,n[C],u[0]));for(let E=0;E<l;E++)d[b*l+E]+=r[T*l+E]}if(s)for(let C=0;C<l;C++)d[b*l+C]/=g-h;if(h=g,++g,x=b+1,b=w,g>a)break}return x<p&&d.fill(i,x*l,p*l),[d,m]}var yF=bn(r=>Math.sqrt(r)),IJ=Et(Ps,r=>Math.sqrt(r)),bF={kernelName:Ps,backendName:"cpu",kernelFunc:IJ};var gN=re((r,t)=>{let e=r-t;return e*e}),SJ=ie(zs,gN),wF={kernelName:zs,backendName:"cpu",kernelFunc:SJ};function ww(r,t,e,n){let o=vt(r,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*e[u]+n[u];o.set(t.get(...a),...i)}return o}var xN=class{constructor(t,e,n,o,s,i){this.separator=y.encodeString(t),this.nGramWidths=e,this.leftPad=y.encodeString(n),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(s-(a+1))),p=i-(l+c),m=e+(l>0?0:a-u),f=0;f+=l*this.leftPad.length;for(let b=0;b<p;++b)f+=t[m+b].length;f+=c*this.rightPad.length,f+=(l+c+p-1)*this.separator.length,n[o+a]=new Uint8Array(f);let h=n[o+a],g=0,x=b=>b.forEach(w=>h[g++]=w);for(let b=0;b<l;++b)x(this.leftPad),x(this.separator);for(let b=0;b<p-1;++b)x(t[m+b]),x(this.separator);if(p>0){x(t[m+p-1]);for(let b=0;b<c;++b)x(this.separator),x(this.rightPad)}else{for(let b=0;b<c-1;++b)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(t,e){let n=t.length,o=e.length;if(o>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let c=e[l]>=u;if(c=c&&e[l]<=n,!c)throw new Error(`Invalid split value ${e[l]}, must be in [${u}, ${n}]`);u=e[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=y.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=e[u]-e[u-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=e[u],c=i[u];if(this.nGramWidths.forEach(p=>{let m=e[u+1]-e[u],f=this.getNumNGrams(m,p);this.createNGrams(t,l,a,c,f,p),c+=f}),this.preserveShort&&c===i[u]){let p=e[u+1]-e[u];if(p===0)continue;let m=p+2*this.padWidth,f=1;this.createNGrams(t,l,a,c,f,m)}}return[a,i]}};function Bc(r,t,e,n,o,s,i,a){return new xN(e,n,o,s,i,a).compute(r,t)}function TJ(r,t,e,n){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!e||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!e||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!e||i.length!==0)&&n.push(i),o=s+1}}function Vc(r,t,e){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let m=0;m<n;++m){let f=o.length;TJ(r[m],t,e,o);let d=o.length-f;a[m]=d,s+=d,i=Math.max(i,d)}let u=y.getArrayFromDType("int32",s*2),l=new Array(s),c=[n,i],p=0;for(let m=0;m<n;++m)for(let f=0;f<a[m];++f)u[p*2]=m,u[p*2+1]=f,l[p]=o[p],++p;return[u,l,c]}function Gc(r,t){let e=y.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)e[n]=y.fingerPrint64(r[n]).modulo(t).getLowBitsUnsigned();return e}var yN=re((r,t)=>r-t),NJ=dd((r,t,e,n)=>({real:r-e,imag:t-n})),Yh=ie(Bs,yN,NJ),CF={kernelName:Bs,backendName:"cpu",kernelFunc:Yh};function Cw(r,t){let e=new Array(r.rank);for(let o=0;o<e.length;o++)e[o]=r.shape[o]*t[o];let n=vt(e,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var Zh=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function vF(r,t,e=0,n=r.length-1){for(;n>e;){if(n-e>600){let a=n-e+1,u=t-e+1,l=Math.log(a),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),m=Math.max(e,Math.floor(t-u*c/a+p)),f=Math.min(n,Math.floor(t+(a-u)*c/a+p));vF(r,t,m,f)}let o=r[t],s=e,i=n;for(y.swap(r,e,t),Zh(r[n],o)>0&&y.swap(r,e,n);s<i;){for(y.swap(r,s,i),s++,i--;Zh(r[s],o)<0;)s=s+1;for(;Zh(r[i],o)>0;)i=i-1}Zh(r[e],o)===0?y.swap(r,e,i):(i=i+1,y.swap(r,i,n)),i<=t&&(e=i+1),t<=i&&(n=i-1)}}function vw(r,t,e,n,o){let s=t[t.length-1],[i,a]=[r.length/s,s],u=y.getTypedArrayFromDType(e,i*n),l=y.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let m=p*a,f=r.subarray(m,m+a),d=new Array(f.length);f.forEach((b,w)=>d[w]={value:b,index:w}),n<d.length&&(vF(d,n),d=d.slice(0,n)),o&&d.sort(Zh);let h=p*n,g=u.subarray(h,h+n),x=l.subarray(h,h+n);for(let b=0;b<n;b++)g[b]=d[b].value,x[b]=d[b].index}let c=t.slice();return c[c.length-1]=n,[vt(c,e,u),vt(c,"int32",l)]}function Iw(r,t,e,n){let o=y.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let d=0;d<o;d++)s[0]*=e[d];s[1]=e[o];for(let d=o+1;d<e.length;d++)s[2]*=e[d];let i={},a=new Int32Array(e[o]),u=new fe(s,n,r),l=[],c=s[0]===1&&s[2]===1;for(let d=0;d<e[o];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let x=0;x<s[0];x++)for(let b=0;b<s[2];b++)g.push(u.get(x,d,b));h=g.join(",")}if(i[h]!==void 0)a[d]=i[h];else{let g=Object.keys(i).length;i[h]=g,a[d]=g,l.push(d)}}let p=s.slice();p[1]=Object.keys(i).length;let m=new fe(p,n);l.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)m.set(u.get(g,d,x),g,h,x)});let f=e.slice();return f[o]=p[1],{outputValues:m.values,outputShape:f,indices:a}}lm("cpu",()=>new Tu,1);var bN=Et(is,r=>r>=0?r:Math.exp(r)-1),IF={kernelName:is,backendName:"cpu",kernelFunc:bN};function wN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n;nt([o],"leakyRelu");let i=y.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,u=y.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?s*a[l]:a[l];return e.makeTensorInfo(o.shape,"float32",u)}var SF={kernelName:ms,backendName:"cpu",kernelFunc:wN};var _J=re((r,t)=>r<0?t*r:r);function CN(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t;nt([n,o],"prelu");let s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[a,u]=_J(n.shape,o.shape,s,i,"float32");return e.makeTensorInfo(u,"float32",a)}var TF={kernelName:Ts,backendName:"cpu",kernelFunc:CN};var vN=Et(ks,r=>Math.max(0,r)),NF={kernelName:ks,backendName:"cpu",kernelFunc:vN};var IN=Et(As,r=>Math.min(Math.max(0,r),6)),kF={kernelName:As,backendName:"cpu",kernelFunc:IN};function Wc(r,t,e,n,o){if(e==="linear")return Ur({inputs:{x:t},backend:r});if(e==="relu")return vN({inputs:{x:t},backend:r});if(e==="elu")return bN({inputs:{x:t},backend:r});if(e==="relu6")return IN({inputs:{x:t},backend:r});if(e==="prelu")return CN({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return wN({inputs:{x:t},backend:r,attrs:{alpha:o}});if(e==="sigmoid")return hN({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Jt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=y.sizeFromShape(o.shape),a=y.inferFromImplicitShape(s,i),u=y.sizeFromShape(a);y.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let l=e.data.get(o.dataId);if(l.complexTensorInfos!=null){let c=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var _F={kernelName:bi,backendName:"cpu",kernelFunc:Jt};function SN(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;nt([o,s],"matMul");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(d),x=y.sizeFromShape(h),w=Lr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);y.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let C=i?[g,c,m]:[g,m,c],T=a?[x,f,p]:[x,p,f],E=Jt({inputs:{x:o},backend:e,attrs:{shape:C}}),$=Jt({inputs:{x:s},backend:e,attrs:{shape:T}}),D=i?E.shape[1]:E.shape[2],P=i?E.shape[2]:E.shape[1],M=a?$.shape[1]:$.shape[2],W=Math.max(g,x),H=e.data.get(E.dataId).values,q=e.data.get($.dataId).values,X=y.computeStrides(E.shape),j=y.computeStrides($.shape),[Z,et,K]=i?[X[0],1,X[1]]:[X[0],X[1],1],[ot,st,it]=a?[1,j[1],j[0]]:[j[1],1,j[0]],pt=P*M,at=vt([W,P,M],E.dtype),gt=at.values,dt=e.blockSize;for(let bt=0;bt<W;bt++)for(let Tt=0;Tt<P;Tt+=dt)for(let At=0;At<M;At+=dt)for(let Rt=0;Rt<D;Rt+=dt){let qt=Math.min(Tt+dt,P),Kt=Math.min(At+dt,M),me=Math.min(Rt+dt,D);for(let Ft=Tt;Ft<qt;Ft++)for(let Ae=At;Ae<Kt;Ae++){let Ie=0;for(let le=Rt;le<me;le++){let qe=Math.min(bt,g-1)*Z,Re=Math.min(bt,x-1)*it,Jr=H[qe+Ft*et+le*K],Me=q[le*ot+Ae*st+Re];Ie+=Jr*Me}gt[bt*pt+(Ft*M+Ae)]+=Ie}}return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo($),e.makeTensorInfo(w,at.dtype,at.values)}var EF={kernelName:Zo,backendName:"cpu",kernelFunc:SN};function EJ(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m,f,d,h=[];m=SN({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:e}),i&&(f=Qi({inputs:{a:m,b:i},backend:e}),h.push(m),m=f),c&&(d=Wc(e,m,c,a,p),h.push(m),m=d);for(let x of h)e.disposeIntermediateTensorInfo(x);return m}var AF={kernelName:Ni,backendName:"cpu",kernelFunc:EJ};var AJ=Et(oa,r=>Math.acos(r)),$F={kernelName:oa,backendName:"cpu",kernelFunc:AJ};var $J=Et(sa,r=>Math.acosh(r)),DF={kernelName:sa,backendName:"cpu",kernelFunc:$J};function DJ(r){let{inputs:t,backend:e}=r,n=t;nt(t,"addN");let o=n.map(a=>e.data.get(a.dataId).values),s=vt(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let u=o[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var RF={kernelName:jo,backendName:"cpu",kernelFunc:DJ};function RJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"all");let a=y.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=Ue({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=y.sizeFromShape(m),d=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let x=0;x<d.length;++x){let b=x*f,w=h[b];for(let C=0;C<f;++C){let T=h[b+C];w=w&&T}d[x]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let x=S.expandShapeToKeepDim(p,a),b=Jt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b}return g}var FF={kernelName:ia,backendName:"cpu",kernelFunc:RJ};function FJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"any");let a=y.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=Ue({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=y.sizeFromShape(m),d=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let x=0;x<d.length;++x){let b=x*f,w=h[b];for(let C=0;C<f;++C){let T=h[b+C];w=w||T}d[x]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let x=S.expandShapeToKeepDim(p,a),b=Jt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b}return g}var OF={kernelName:aa,backendName:"cpu",kernelFunc:FJ};function OJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;nt(o,"argMax");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ue({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=y.sizeFromShape(c),f=y.makeZerosTypedArray(m,"int32"),d=y.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let x=g*d,b=h[x],w=0;for(let C=0;C<d;++C){let T=h[x+C];T>b&&(b=T,w=C)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var PF={kernelName:Xo,backendName:"cpu",kernelFunc:OJ};function PJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;nt(o,"argMin");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ue({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=y.sizeFromShape(c),f=y.makeZerosTypedArray(m,"int32"),d=y.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let x=g*d,b=h[x],w=0;for(let C=0;C<d;++C){let T=h[x+C];T<b&&(b=T,w=C)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var LF={kernelName:Nl,backendName:"cpu",kernelFunc:PJ};var LJ=Et(la,r=>Math.asin(r)),MF={kernelName:la,backendName:"cpu",kernelFunc:LJ};var MJ=Et(ua,r=>Math.asinh(r)),zF={kernelName:ua,backendName:"cpu",kernelFunc:MJ};var zJ=Et(ca,r=>Math.atan(r)),BF={kernelName:ca,backendName:"cpu",kernelFunc:zJ};var BJ=re((r,t)=>Math.atan2(r,t)),VJ=ie(ma,BJ),VF={kernelName:ma,backendName:"cpu",kernelFunc:VJ};var GJ=Et(pa,r=>Math.atanh(r)),GF={kernelName:pa,backendName:"cpu",kernelFunc:GJ};function bd(r,t,e,n,o,s){let i=o.strideHeight,a=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,m=o.padInfo.top,f=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=vt(o.outShape,e),g=h.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],b=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let C=0;C<o.batchSize;++C){let T=C*x,E=C*n[0];for(let $=0;$<o.inChannels;++$)for(let D=0;D<o.outHeight;++D){let P=D*i-m,M=Math.max(0,P),W=Math.min(o.inHeight,c+P),H=T+D*b;for(let q=0;q<o.outWidth;++q){let X=q*a-f,j=Math.max(0,X),Z=Math.min(o.inWidth,p+X),et=d,K=0,ot=0;for(let it=M;it<W;it+=u){let pt=E+it*n[1];for(let at=j;at<Z;at+=l){let gt=pt+at*n[2],dt=r[gt+$];s==="max"&&dt>et?et=dt:s==="avg"&&(K+=dt,ot++)}if(isNaN(et))break}let st=H+q*w+$;g[st]=s==="avg"?K/ot:et}}}return h}function Tw(r,t,e,n,o=!1,s=!1){let i=vt(n.outShape,"int32"),a=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,f=n.padInfo.top,d=n.padInfo.left,h=vt(t,e,r);for(let g=0;g<n.batchSize;++g)for(let x=0;x<n.inChannels;++x)for(let b=0;b<n.outHeight;++b){let w=b*a-f,C=w;for(;C<0;)C+=l;let T=Math.min(n.inHeight,p+w);for(let E=0;E<n.outWidth;++E){let $=E*u-d,D=$;for(;D<0;)D+=c;let P=Math.min(n.inWidth,m+$),M=Number.NEGATIVE_INFINITY,W=-1;for(let H=C;H<T;H+=l){let q=H-w;for(let X=D;X<P;X+=c){let j=X-$,Z=h.get(g,H,X,x);Z>M&&(M=Z,o?W=s?((g*n.inHeight+H)*n.inWidth+X)*n.inChannels+x:(H*n.inWidth+X)*n.inChannels+x:W=q*m+j)}}i.set(W,g,b,E,x)}}return i}function Nw(r,t,e,n,o,s){let i=o.strideDepth,a=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,m=o.effectiveFilterDepth,f=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,x=o.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=vt(o.outShape,e),C=w.values,T=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],E=o.outShape[2]*o.outShape[3]*o.outShape[4],$=o.outShape[3]*o.outShape[4],D=o.outShape[4];for(let P=0;P<o.batchSize;++P){let M=P*T,W=P*n[0];for(let H=0;H<o.inChannels;++H)for(let q=0;q<o.outDepth;++q){let X=q*i-h,j=X;for(;j<0;)j+=l;let Z=Math.min(o.inDepth,m+X),et=M+q*E;for(let K=0;K<o.outHeight;++K){let ot=K*a-g,st=ot;for(;st<0;)st+=c;let it=Math.min(o.inHeight,f+ot),pt=et+K*$;for(let at=0;at<o.outWidth;++at){let gt=at*u-x,dt=gt;for(;dt<0;)dt+=p;let bt=Math.min(o.inWidth,d+gt),Tt=pt+at*D,At=b,Rt=0,qt=0;for(let me=j;me<Z;me+=l){let Ft=W+me*n[1];for(let Ae=st;Ae<it;Ae+=c){let Ie=Ft+Ae*n[2];for(let le=dt;le<bt;le+=p){let qe=Ie+le*n[3],Re=r[qe+H];if(s==="max"&&Re>At?At=Re:s==="avg"&&(Rt+=Re,qt++),isNaN(At))break}if(isNaN(At))break}if(isNaN(At))break}let Kt=Tt+H;C[Kt]=s==="avg"?Rt/qt:At}}}}return w}function WF(r,t){let e=vt(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,f=t.padInfo.top,d=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){let b=x*n-m,w=b;for(;w<0;)w+=i;let C=Math.min(t.inDepth,l+b);for(let T=0;T<t.outHeight;++T){let E=T*o-f,$=E;for(;$<0;)$+=a;let D=Math.min(t.inHeight,c+E);for(let P=0;P<t.outWidth;++P){let M=P*s-d,W=M;for(;W<0;)W+=u;let H=Math.min(t.inWidth,p+M),q=Number.NEGATIVE_INFINITY,X=-1;for(let j=w;j<C;j+=i){let Z=j-b;for(let et=$;et<D;et+=a){let K=et-E;for(let ot=W;ot<H;ot+=u){let st=ot-M,it=r.get(h,j,et,ot,g);it>=q&&(q=it,X=Z*c*p+K*c+st)}}}e.set(X,h,x,T,P,g)}}}return e}function WJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;nt(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))p=Ur({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=y.computeStrides(o.shape),d=bd(m,o.shape,o.dtype,f,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var UF={kernelName:Yo,backendName:"cpu",kernelFunc:WJ};function UJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;nt(o,"avgPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=Nw(p,o.shape,o.dtype,y.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}var HF={kernelName:kl,backendName:"cpu",kernelFunc:UJ};function HJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;nt([o,s],"avgPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=c.strideDepth,m=c.strideHeight,f=c.strideWidth,d=c.filterDepth,h=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,C=c.effectiveFilterDepth,T=c.effectiveFilterHeight,E=c.effectiveFilterWidth,$=C-1-c.padInfo.front,D=E-1-c.padInfo.left,P=T-1-c.padInfo.top,M=vt(s.shape,"float32"),W=1/(d*h*g),H=e.bufferSync(o);for(let q=0;q<c.batchSize;++q)for(let X=0;X<c.inChannels;++X)for(let j=0;j<c.inDepth;++j)for(let Z=0;Z<c.inHeight;++Z)for(let et=0;et<c.inWidth;++et){let K=j-$,ot=Z-P,st=et-D,it=0;for(let pt=0;pt<C;pt+=x){let at=(K+pt)/p;if(!(at<0||at>=c.outDepth||Math.floor(at)!==at))for(let gt=0;gt<T;gt+=b){let dt=(ot+gt)/m;if(!(dt<0||dt>=c.outHeight||Math.floor(dt)!==dt))for(let bt=0;bt<E;bt+=w){let Tt=(st+bt)/f;if(Tt<0||Tt>=c.outWidth||Math.floor(Tt)!==Tt)continue;it+=H.get(q,at,dt,Tt,X)}}}M.set(it*W,q,j,Z,et,X)}return e.makeTensorInfo(M.shape,M.dtype,M.values)}var qF={kernelName:Ip,backendName:"cpu",kernelFunc:HJ};function qJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;nt([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=c.strideHeight,m=c.strideWidth,f=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,C=x-1-c.padInfo.top,T=vt(i.shape,"float32"),E=1/(f*d),$=e.data.get(o.dataId).values,D=vt(o.shape,"float32",$);for(let P=0;P<c.batchSize;++P)for(let M=0;M<c.inChannels;++M)for(let W=0;W<c.inHeight;++W)for(let H=0;H<c.inWidth;++H){let q=W-C,X=H-w,j=0;for(let Z=0;Z<x;Z+=h){let et=(q+Z)/p;if(!(et<0||et>=c.outHeight||Math.floor(et)!==et))for(let K=0;K<b;K+=g){let ot=(X+K)/m;if(ot<0||ot>=c.outWidth||Math.floor(ot)!==ot)continue;j+=D.get(P,et,ot,M)}}T.set(j*E,P,W,H,M)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}var KF={kernelName:vp,backendName:"cpu",kernelFunc:qJ};function KJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,scale:s,offset:i,mean:a,variance:u}=t;y.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),nt([o,a,u,s,i],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,m=e.data.get(u.dataId).values,f=s?e.data.get(s.dataId).values:new Float32Array([1]),d=i?e.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),g=d.length,x=f.length,b=m.length,w=p.length,C=0,T=0,E=0,$=0;for(let D=0;D<c.length;++D)h[D]=d[C++]+(c[D]-p[T++])*f[E++]/Math.sqrt(m[$++]+l),C>=g&&(C=0),T>=w&&(T=0),E>=x&&(E=0),$>=b&&($=0);return e.makeTensorInfo(o.shape,o.dtype,h)}var jF={kernelName:cs,backendName:"cpu",kernelFunc:KJ};function jJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;nt([o],"batchToSpaceND");let a=s.reduce((x,b)=>x*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=Jt({inputs:{x:o},backend:e,attrs:{shape:u}}),d=Ue({inputs:{x:f},backend:e,attrs:{perm:l}}),h=Jt({inputs:{x:d},backend:e,attrs:{shape:c}}),g=Ro({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var XF={kernelName:mi,backendName:"cpu",kernelFunc:jJ};function XJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=hd(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var YF={kernelName:Sp,backendName:"cpu",kernelFunc:XJ};function YJ(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var ZF={kernelName:Tp,backendName:"cpu",kernelFunc:YJ};var ZJ=Et(lo,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),JF={kernelName:lo,backendName:"cpu",kernelFunc:ZJ};var JJ=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(y.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let c=a[l],p=u[l];n[l]=Math.hypot(c,p)}return e.makeOutput(n,t.shape,"float32")},QF={kernelName:_l,backendName:"cpu",kernelFunc:JJ};function ta(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var tO={kernelName:Mp,backendName:"cpu",kernelFunc:ta};function Nu(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(h=>h.shape),s);if(y.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(h=>y.sizeFromShape(h.shape)>0);if(a.length===1)return Ur({inputs:{x:a[0]},backend:e});let u=a.map(h=>h.shape);if(S.assertParamsConsistent(u,s),a[0].dtype==="complex64"){let h=a.map(C=>Eo({inputs:{input:C},backend:e})),g=a.map(C=>ta({inputs:{input:C},backend:e})),x=Nu({inputs:h,backend:e,attrs:{axis:s}}),b=Nu({inputs:g,backend:e,attrs:{axis:s}}),w=Cr({inputs:{real:x,imag:b},backend:e});return h.forEach(C=>e.disposeIntermediateTensorInfo(C)),g.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),w}let l=a.map(h=>{let g=y.sizeFromShape(h.shape.slice(s));return Jt({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}})}),c=l.map(h=>({vals:e.data.get(h.dataId).values,shape:h.shape}));i=S.computeOutShape(l.map(h=>h.shape),1);let p=l[0].shape[0]===1,m=Pc(c,i,t[0].dtype,p),f=S.computeOutShape(a.map(h=>h.shape),s),d=e.makeTensorInfo(f,t[0].dtype,m);return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var eO={kernelName:fi,backendName:"cpu",kernelFunc:Nu};function TN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n;nt([o,s],"conv2d");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,x=m.padInfo.left,b=m.padInfo.top,w=m.dataFormat==="channelsLast",C=new fe(m.outShape,o.dtype),T=y.computeStrides(o.shape),E=y.computeStrides(s.shape),$=T[0],D=w?T[1]:T[2],P=w?T[2]:1,M=w?1:T[1],W=C.strides[0],H=w?C.strides[1]:C.strides[2],q=w?C.strides[2]:1,X=w?1:C.strides[1],j=e.data.get(o.dataId).values,Z=e.data.get(s.dataId).values,et=C.values;for(let K=0;K<m.batchSize;++K){let ot=K*$,st=K*W;for(let it=0;it<m.outHeight;++it){let pt=st+it*H,at=it*m.strideHeight-b;for(let gt=0;gt<f;++gt){let dt=at+gt*h;if(dt<0||dt>=m.inHeight)continue;let bt=gt*E[0],Tt=ot+dt*D;for(let At=0;At<m.outWidth;++At){let Rt=pt+At*q,qt=At*m.strideWidth-x;for(let Kt=0;Kt<d;++Kt){let me=qt+Kt*g;if(me<0||me>=m.inWidth)continue;let Ft=bt+Kt*E[1],Ae=Tt+me*P,Ie=Ft;for(let le=0;le<m.inChannels;++le){let qe=j[Ae+le*M];for(let Re=0;Re<m.outChannels;++Re)et[Rt+Re*X]+=qe*Z[Ie+Re];Ie+=m.outChannels}}}}}}return e.makeTensorInfo(C.shape,C.dtype,et)}var rO={kernelName:Qo,backendName:"cpu",kernelFunc:TN};function QJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n;nt([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,x=m.dataFormat==="channelsLast",b=new fe(m.filterShape,"float32"),w=m.padInfo.left,C=m.padInfo.top,T=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=new fe(o.shape,o.dtype,T),D=new fe(s.shape,s.dtype,E);for(let P=0;P<h;++P){let M=Math.max(0,Math.ceil((C-P)/f)),W=Math.min(m.outHeight,(m.inHeight+C-P)/f);for(let H=0;H<g;++H){let q=Math.max(0,Math.ceil((w-H)/d)),X=Math.min(m.outWidth,(m.inWidth+w-H)/d);for(let j=0;j<m.inChannels;++j)for(let Z=0;Z<m.outChannels;++Z){let et=0;for(let K=0;K<m.batchSize;++K)for(let ot=M;ot<W;++ot){let st=P+ot*f-C;for(let it=q;it<X;++it){let pt=H+it*d-w;x?et+=$.get(K,st,pt,j)*D.get(K,ot,it,Z):et+=$.get(K,j,st,pt)*D.get(K,Z,ot,it)}}b.set(et,P,H,j,Z)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var nO={kernelName:kp,backendName:"cpu",kernelFunc:QJ};function t9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n;nt([o,s],"conv2dBackpropInput");let p=y.computeStrides(s.shape),m=y.computeStrides(o.shape),f=S.convertConv2DDataFormat(l),d=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,f),h=new fe(d.inShape,"float32"),g=h.values,x=e.data.get(o.dataId).values,b=e.data.get(s.dataId).values,[w,C,T]=p,{batchSize:E,filterHeight:$,filterWidth:D,inChannels:P,inHeight:M,inWidth:W,outChannels:H,outHeight:q,outWidth:X,strideHeight:j,strideWidth:Z}=d;f=d.dataFormat;let et=$-1-d.padInfo.top,K=D-1-d.padInfo.left,ot=f==="channelsLast",st=h.strides[0],it=ot?h.strides[1]:h.strides[2],pt=ot?h.strides[2]:1,at=ot?1:h.strides[1],gt=m[0],dt=ot?m[1]:m[2],bt=ot?m[2]:1,Tt=ot?1:m[1];for(let At=0;At<E;++At)for(let Rt=0;Rt<P;++Rt)for(let qt=0;qt<M;++qt){let Kt=qt-et,me=Math.max(0,Math.ceil(Kt/j)),Ft=Math.min(q,($+Kt)/j);for(let Ae=0;Ae<W;++Ae){let Ie=Ae-K,le=Math.max(0,Math.ceil(Ie/Z)),qe=Math.min(X,(D+Ie)/Z),Re=0;for(let Me=me;Me<Ft;++Me){let Lo=Me*j-Kt;for(let Or=le;Or<qe;++Or){let Qr=Or*Z-Ie,tn=gt*At+dt*Me+bt*Or,qr=w*($-1-Lo)+C*(D-1-Qr)+T*Rt;for(let so=0;so<H;++so){let $n=x[tn+Tt*so],Mo=b[qr+so];Re+=$n*Mo}}}let Jr=st*At+it*qt+pt*Ae+at*Rt;g[Jr]=Re}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var oO={kernelName:ts,backendName:"cpu",kernelFunc:t9};function e9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n;nt([o,s],"conv3d");let l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=l,x=g.front,b=g.left,w=g.top,C=new fe(l.outShape,o.dtype),T=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=C.values,D=y.computeStrides(o.shape),P=y.computeStrides(s.shape);for(let M=0;M<l.batchSize;++M){let W=M*D[0],H=M*C.strides[0];for(let q=0;q<l.outDepth;++q){let X=H+q*C.strides[1],j=q*l.strideDepth-x;for(let Z=0;Z<c;++Z){let et=j+Z*f;if(et<0||et>=l.inDepth)continue;let K=Z*P[0],ot=W+et*D[1];for(let st=0;st<l.outHeight;++st){let it=X+st*C.strides[2],pt=st*l.strideHeight-w;for(let at=0;at<p;++at){let gt=pt+at*d;if(gt<0||gt>=l.inHeight)continue;let dt=K+at*P[1],bt=ot+gt*D[2];for(let Tt=0;Tt<l.outWidth;++Tt){let At=it+Tt*l.outChannels,Rt=Tt*l.strideWidth-b;for(let qt=0;qt<m;++qt){let Kt=Rt+qt*h;if(Kt<0||Kt>=l.inWidth)continue;let me=dt+qt*P[2],Ft=bt+Kt*l.inChannels,Ae=me;for(let Ie=0;Ie<l.inChannels;++Ie){let le=T[Ft+Ie];for(let qe=0;qe<l.outChannels;++qe)$[At+qe]+=le*E[Ae+qe];Ae+=l.outChannels}}}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}var sO={kernelName:El,backendName:"cpu",kernelFunc:e9};function r9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n;nt([o,s],"conv3dBackpropFilterV2");let l=y.computeStrides(o.shape),c=y.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,u,i,1,a),m=p.strideDepth,f=p.strideHeight,d=p.strideWidth,h=p.filterDepth,g=p.filterHeight,x=p.filterWidth,b=new fe(p.filterShape,"float32"),w=b.values,[C,T,E,$]=b.strides,D=e.data.get(s.dataId).values,[P,M,W,H]=c,q=e.data.get(o.dataId).values,[X,j,Z,et]=l,K=p.padInfo.front,ot=p.padInfo.left,st=p.padInfo.top;for(let it=0;it<h;++it){let pt=Math.max(0,Math.ceil((K-it)/m)),at=Math.min(p.outDepth,(p.inDepth+K-it)/m),gt=it*C;for(let dt=0;dt<g;++dt){let bt=Math.max(0,Math.ceil((st-dt)/f)),Tt=Math.min(p.outHeight,(p.inHeight+st-dt)/f),At=dt*T+gt;for(let Rt=0;Rt<x;++Rt){let qt=Math.max(0,Math.ceil((ot-Rt)/d)),Kt=Math.min(p.outWidth,(p.inWidth+ot-Rt)/d),me=Rt*E+At;for(let Ft=0;Ft<p.inChannels;++Ft){let Ae=Ft*$+me;for(let Ie=0;Ie<p.outChannels;++Ie){let le=0;for(let qe=0;qe<p.batchSize;++qe){let Re=qe*X,Jr=qe*P;for(let Me=pt;Me<at;++Me){let Or=(it+Me*m-K)*j+Re,Qr=Me*M+Jr;for(let tn=bt;tn<Tt;++tn){let so=(dt+tn*f-st)*Z+Or,$n=tn*W+Qr;for(let Mo=qt;Mo<Kt;++Mo){let Cl=(Rt+Mo*d-ot)*et+so,Fu=Mo*H+$n;le+=q[Cl+Ft]*D[Fu+Ie]}}}}w[Ae+Ie]=le}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var iO={kernelName:_p,backendName:"cpu",kernelFunc:r9};function n9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n;nt([o],"conv3dBackpropInputV2");let l=y.computeStrides(o.shape),c=y.computeStrides(s.shape),p=S.computeConv3DInfo(u,s.shape,a,1,i),m=new fe(p.inShape,"float32"),f=m.values,[d,h,g,x]=m.strides,b=e.data.get(o.dataId).values,[w,C,T,E]=l,$=e.data.get(s.dataId).values,[D,P,M,W]=c,{batchSize:H,filterDepth:q,filterHeight:X,filterWidth:j,inChannels:Z,inDepth:et,inHeight:K,inWidth:ot,outChannels:st,outDepth:it,outHeight:pt,outWidth:at,strideDepth:gt,strideHeight:dt,strideWidth:bt}=p,Tt=q-1-p.padInfo.front,At=X-1-p.padInfo.top,Rt=j-1-p.padInfo.left;for(let qt=0;qt<H;++qt)for(let Kt=0;Kt<Z;++Kt)for(let me=0;me<et;++me){let Ft=me-Tt,Ae=Math.max(0,Math.ceil(Ft/gt)),Ie=Math.min(it,(q+Ft)/gt);for(let le=0;le<K;++le){let qe=le-At,Re=Math.max(0,Math.ceil(qe/dt)),Jr=Math.min(pt,(X+qe)/dt);for(let Me=0;Me<ot;++Me){let Lo=Me-Rt,Or=Math.max(0,Math.ceil(Lo/bt)),Qr=Math.min(at,(j+Lo)/bt),tn=0;for(let qr=Ae;qr<Ie;++qr){let so=qr*gt-Ft;for(let $n=Re;$n<Jr;++$n){let Mo=$n*dt-qe;for(let io=Or;io<Qr;++io){let Cl=io*bt-Lo,Fu=w*qt+C*qr+T*$n+E*io,np=D*(q-1-so)+P*(X-1-Mo)+M*(j-1-Cl)+W*Kt;for(let dr=0;dr<st;++dr){let op=b[Fu+dr],sp=$[np+dr];tn+=op*sp}}}}f[d*qt+h*me+g*le+x*Me+Kt]=tn}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var aO={kernelName:Ep,backendName:"cpu",kernelFunc:n9};var o9=Et(es,r=>Math.cos(r)),lO={kernelName:es,backendName:"cpu",kernelFunc:o9};var s9=Et(rs,r=>Math.cosh(r)),uO={kernelName:rs,backendName:"cpu",kernelFunc:s9};function i9(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,[c,p,m,f]=o.shape,d=s.shape[0],[h,g]=a,x=vt([d,h,g,f],"float32"),b=e.data.get(s.dataId).values,w=e.data.get(i.dataId).values,C=e.data.get(o.dataId).values,T=y.computeStrides(o.shape),E=y.computeStrides(x.shape);for(let $=0;$<d;$++){let D=$*4,P=b[D],M=b[D+1],W=b[D+2],H=b[D+3],q=w[$];if(q>=c)continue;let X=h>1?(W-P)*(p-1)/(h-1):0,j=g>1?(H-M)*(m-1)/(g-1):0;for(let Z=0;Z<h;Z++){let et=h>1?P*(p-1)+Z*X:.5*(P+W)*(p-1);if(et<0||et>p-1){for(let K=0;K<g;K++)for(let ot=0;ot<f;ot++){let st=ot+K*E[2]+Z*E[1]+$*E[0];x.values[st]=l}continue}if(u==="bilinear"){let K=Math.floor(et),ot=Math.ceil(et),st=et-K;for(let it=0;it<g;it++){let pt=g>1?M*(m-1)+it*j:.5*(M+H)*(m-1);if(pt<0||pt>m-1){for(let bt=0;bt<f;bt++){let Tt=bt+it*E[2]+Z*E[1]+$*E[0];x.values[Tt]=l}continue}let at=Math.floor(pt),gt=Math.ceil(pt),dt=pt-at;for(let bt=0;bt<f;bt++){let Tt=bt+at*T[2]+K*T[1]+q*T[0],At=C[Tt];Tt=bt+gt*T[2]+K*T[1]+q*T[0];let Rt=C[Tt];Tt=bt+at*T[2]+ot*T[1]+q*T[0];let qt=C[Tt];Tt=bt+gt*T[2]+ot*T[1]+q*T[0];let Kt=C[Tt],me=At+(Rt-At)*dt,Ft=qt+(Kt-qt)*dt;Tt=bt+it*E[2]+Z*E[1]+$*E[0],x.values[Tt]=me+(Ft-me)*st}}}else for(let K=0;K<g;++K){let ot=g>1?M*(m-1)+K*j:.5*(M+H)*(m-1);if(ot<0||ot>m-1){for(let pt=0;pt<f;pt++){let at=pt+K*E[2]+Z*E[1]+$*E[0];x.values[at]=l}continue}let st=Math.round(ot),it=Math.round(et);for(let pt=0;pt<f;pt++){let at=pt+st*T[2]+it*T[1]+q*T[0],gt=pt+K*E[2]+Z*E[1]+$*E[0];x.values[gt]=C[at]}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var cO={kernelName:da,backendName:"cpu",kernelFunc:i9};function a9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;nt(o,"cumprod");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=Ue({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ir(l.dtype,"int32"),m=y.makeOnesTypedArray(y.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(x,b)=>x+d-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=d)for(let b=0;b<d;b++){let w=h(x,b);if(b===0)m[w]=i?1:f[w];else{let C=h(x,b-1);m[w]=i?f[C]*m[C]:f[w]*m[C]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let x=S.getUndoAxesPermutation(u),b=Ue({inputs:{x:g},backend:e,attrs:{perm:x}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var pO={kernelName:fa,backendName:"cpu",kernelFunc:a9};function l9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;nt(o,"cumsum");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=Ue({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ir(l.dtype,"int32"),m=y.makeZerosTypedArray(y.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(x,b)=>x+d-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=d)for(let b=0;b<d;b++){let w=h(x,b);if(b===0)m[w]=i?0:f[w];else{let C=h(x,b-1);m[w]=i?f[C]+m[C]:f[w]+m[C]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let x=S.getUndoAxesPermutation(u),b=Ue({inputs:{x:g},backend:e,attrs:{perm:x}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var mO={kernelName:ns,backendName:"cpu",kernelFunc:l9};function u9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=hd(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=mw(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var fO={kernelName:Ap,backendName:"cpu",kernelFunc:u9};function c9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n;y.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],u=o.shape[1],l=o.shape[2],c=o.shape[3],p=u*s,m=l*s,f=c/(s*s),d=e.data.get(o.dataId).values,h=new Float32Array(a*p*m*f),g=0;for(let x=0;x<a;++x)for(let b=0;b<p;++b){let w=Math.floor(b/s),C=b%s;for(let T=0;T<m;++T){let E=Math.floor(T/s),$=T%s,D=(C*s+$)*f;for(let P=0;P<f;++P){let W=P+D+c*(E+l*(w+u*x));h[g++]=d[W]}}}return e.makeTensorInfo([a,p,m,f],o.dtype,h)}var dO={kernelName:ha,backendName:"cpu",kernelFunc:c9};function NN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n;nt([o,s],"depthwiseConv2DNative");let c=y.computeStrides(o.shape),p=y.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,m,a,l,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:x,padInfo:b}=f,w=b.left,C=b.top,T=f.outChannels/f.inChannels,E=new fe(f.outShape,o.dtype),$=e.data.get(o.dataId).values,D=e.data.get(s.dataId).values,P=E.values;for(let M=0;M<f.batchSize;++M){let W=M*c[0],H=M*E.strides[0];for(let q=0;q<f.outHeight;++q){let X=H+q*E.strides[1],j=q*f.strideHeight-C;for(let Z=0;Z<d;++Z){let et=j+Z*g;if(et<0||et>=f.inHeight)continue;let K=Z*p[0],ot=W+et*c[1];for(let st=0;st<f.outWidth;++st){let it=X+st*E.strides[2],pt=st*f.strideWidth-w;for(let at=0;at<h;++at){let gt=pt+at*x;if(gt<0||gt>=f.inWidth)continue;let dt=K+at*p[1],bt=ot+gt*f.inChannels,Tt=it,At=dt;for(let Rt=0;Rt<f.inChannels;++Rt){let qt=$[bt+Rt];for(let Kt=0;Kt<T;++Kt)P[Tt+Kt]+=qt*D[At+Kt];Tt+=T,At+=T}}}}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}var hO={kernelName:os,backendName:"cpu",kernelFunc:NN};function p9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n;nt([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=p,g=new fe(p.filterShape,"float32"),x=p.padInfo.left,b=p.padInfo.top,w=p.outChannels/p.inChannels,C=e.data.get(o.dataId).values,T=new fe(o.shape,o.dtype,C),E=e.data.get(s.dataId).values,$=new fe(s.shape,s.dtype,E);for(let D=0;D<d;++D){let P=Math.max(0,Math.ceil((b-D)/m)),M=Math.min(p.outHeight,(p.inHeight+b-D)/m);for(let W=0;W<h;++W){let H=Math.max(0,Math.ceil((x-W)/f)),q=Math.min(p.outWidth,(p.inWidth+x-W)/f);for(let X=0;X<p.outChannels;++X){let j=Math.trunc(X/w),Z=X%w,et=0;for(let K=0;K<p.batchSize;++K)for(let ot=P;ot<M;++ot){let st=D+ot*m-b;for(let it=H;it<q;++it){let pt=W+it*f-x;et+=T.get(K,st,pt,j)*$.get(K,ot,it,X)}}g.set(et,D,W,j,Z)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var gO={kernelName:$p,backendName:"cpu",kernelFunc:p9};function m9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n;nt([o,s],"depthwiseConv2DNativeBackpropInput");let p=y.computeStrides(o.shape),m=y.computeStrides(s.shape),f=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),d=new fe(f.inShape,"float32"),h=d.values,[g,x,b]=d.strides,w=e.data.get(o.dataId).values,[C,T,E]=p,$=e.data.get(s.dataId).values,[D,P,M]=m,{batchSize:W,filterHeight:H,filterWidth:q,inChannels:X,inHeight:j,inWidth:Z,outChannels:et,outHeight:K,outWidth:ot,strideHeight:st,strideWidth:it}=f,pt=H-1-f.padInfo.top,at=q-1-f.padInfo.left,gt=et/X;for(let dt=0;dt<W;++dt)for(let bt=0;bt<X;++bt)for(let Tt=0;Tt<j;++Tt){let At=Tt-pt,Rt=Math.max(0,Math.ceil(At/st)),qt=Math.min(K,(H+At)/st);for(let Kt=0;Kt<Z;++Kt){let me=Kt-at,Ft=Math.max(0,Math.ceil(me/it)),Ae=Math.min(ot,(q+me)/it),Ie=0;for(let le=Rt;le<qt;++le){let qe=le*st-At;for(let Re=Ft;Re<Ae;++Re){let Jr=Re*it-me,Me=C*dt+T*le+E*Re,Lo=D*(H-1-qe)+P*(q-1-Jr)+M*bt;for(let Or=0;Or<gt;++Or){let Qr=bt*gt+Or,tn=w[Me+Qr],qr=$[Lo+Or];Ie+=tn*qr}}}h[g*dt+x*Tt+b*Kt+bt]=Ie}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var xO={kernelName:Dp,backendName:"cpu",kernelFunc:m9};function f9(r){let{inputs:t,backend:e}=r,{x:n}=t,o=y.sizeFromShape(n.shape),s=e.data.get(n.dataId).values,i=vt([o,o],n.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,i.dtype,i.values)}var yO={kernelName:Rp,backendName:"cpu",kernelFunc:f9};var bO={kernelName:Al,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o}=r,{strides:s,pad:i,dilations:a}=e,u=t,l=u.data.get(n.dataId).values,c=n.shape.length,p=u.data.get(o.dataId).values,m=o.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:x,outWidth:b,padInfo:w,strideHeight:C,strideWidth:T,filterHeight:E,filterWidth:$,dilationHeight:D,dilationWidth:P,outShape:M}=S.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),W=y.sizeFromShape(M),H=M.length,q=y.getArrayFromDType(n.dtype,W);for(let j=0;j<f;++j)for(let Z=0;Z<x;++Z){let et=Z*C-w.top;for(let K=0;K<b;++K){let ot=K*T-w.left;for(let st=0;st<g;++st){let it=Number.MIN_SAFE_INTEGER;for(let at=0;at<E;++at){let gt=et+at*D;if(gt>=0&&gt<d)for(let dt=0;dt<$;++dt){let bt=ot+dt*P;if(bt>=0&&bt<h){let Tt=y.locToIndex([j,gt,bt,st],c,y.computeStrides(n.shape)),At=y.locToIndex([at,dt,st],m,y.computeStrides(o.shape)),Rt=l[Tt]+p[At];Rt>it&&(it=Rt)}}}let pt=y.locToIndex([j,Z,K,st],H,y.computeStrides(M));q[pt]=it}}}return{dataId:u.write(y.toTypedArray(q,n.dtype),M,n.dtype),shape:M,dtype:n.dtype}}};var wO={kernelName:sh,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=y.toNestedArray(n.shape,l.data.get(n.dataId).values),p=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:x,padInfo:b,strideHeight:w,strideWidth:C,filterHeight:T,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:P}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);y.assert(s.rank===P.length,()=>`Error in ${sh}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let M=y.toNestedArray(P,l.data.get(s.dataId).values),W=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let q=0;q<m;++q)for(let X=0;X<g;++X){let j=X*w-b.top;for(let Z=0;Z<x;++Z){let et=Z*C-b.left;for(let K=0;K<h;++K){let ot=Number.MIN_SAFE_INTEGER,st=0,it=0;for(let pt=0;pt<T;++pt){let at=j+pt*$;if(at>=0&&at<f)for(let gt=0;gt<E;++gt){let dt=et+gt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][K]+p[pt][gt][K];bt>ot&&(ot=bt,st=pt,it=gt)}}}W[st][it][K]+=M[q][X][Z][K]}}}return{dataId:l.write(y.toTypedArray(W,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var CO={kernelName:oh,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=y.toNestedArray(n.shape,l.data.get(n.dataId).values),p=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:x,padInfo:b,strideHeight:w,strideWidth:C,filterHeight:T,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:P}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);y.assert(s.rank===P.length,()=>`Error in ${oh}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let M=y.toNestedArray(P,l.data.get(s.dataId).values),W=y.makeZerosNestedTypedArray(n.shape,n.dtype);for(let q=0;q<m;++q)for(let X=0;X<g;++X){let j=X*w-b.top;for(let Z=0;Z<x;++Z){let et=Z*C-b.left;for(let K=0;K<h;++K){let ot=Number.MIN_SAFE_INTEGER,st=j<0?0:j,it=et<0?0:et;for(let pt=0;pt<T;++pt){let at=j+pt*$;if(at>=0&&at<f)for(let gt=0;gt<E;++gt){let dt=et+gt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][K]+p[pt][gt][K];bt>ot&&(ot=bt,st=at,it=dt)}}}W[q][st][it][K]+=M[q][X][Z][K]}}}return{dataId:l.write(y.toTypedArray(W,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function dl(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"sum");let a;o.dtype==="bool"?a=Ao({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=Ur({inputs:{x:o},backend:e});let u=a.shape.length,l=y.parseAxisParam(s,a.shape),c=S.getAxesPermutation(l,u),p=l,m=a;c!=null&&(m=Ue({inputs:{x:a},backend:e,attrs:{perm:c}}),p=S.getInnerMostAxes(p.length,u)),S.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[f,d]=S.computeOutAndReduceShapes(m.shape,p),h=S.upcastType(m.dtype,"int32"),g=fd(e,f,h),x=y.sizeFromShape(d),b=e.data.get(g.dataId).values,w=e.data.get(m.dataId).values;for(let C=0;C<b.length;++C){let T=C*x,E=0;for(let $=0;$<x;++$)E+=w[T+$];b[C]=E}if(i){let C=S.expandShapeToKeepDim(g.shape,l),T=g;g=Jt({inputs:{x:g},backend:e,attrs:{shape:C}}),e.disposeIntermediateTensorInfo(T)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(m),g}var vO={kernelName:Ls,backendName:"cpu",kernelFunc:dl};function d9(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:x,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=Ue({inputs:{x:s[g]},backend:e,attrs:{perm:x}}),d.push(w));let C=w.shape.slice();for(let T=0;T<b.length;++T)C.splice(b[T],0,1);y.arraysEqual(w.shape,C)||(w=Jt({inputs:{x:w},backend:e,attrs:{shape:C}}),d.push(w)),m===null?m=w:(m=Lc({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=dl({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var IO={kernelName:Fp,backendName:"cpu",kernelFunc:d9};function h9(r){let{inputs:t,backend:e}=r,{dy:n,y:o}=t;nt([n,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let l=i[u];l>=1?s[u]=a[u]:s[u]=a[u]*(l+1)}return e.makeTensorInfo(o.shape,"float32",s)}var SO={kernelName:Op,backendName:"cpu",kernelFunc:h9};var g9=S.ERF_P,x9=S.ERF_A1,y9=S.ERF_A2,b9=S.ERF_A3,w9=S.ERF_A4,C9=S.ERF_A5,v9=Et(ga,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+g9*e);return t*(1-((((C9*n+w9)*n+b9)*n+y9)*n+x9)*n*Math.exp(-e*e))}),TO={kernelName:ga,backendName:"cpu",kernelFunc:v9};function wd(r){let{inputs:t,backend:e,attrs:n}=r,{input:o}=t,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(y.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),Jt({inputs:{x:o},backend:e,attrs:{shape:a}})}var NO={kernelName:di,backendName:"cpu",kernelFunc:wd};var I9=re((r,t)=>r/t),Jh=ie(ss,I9),Qh={kernelName:ss,backendName:"cpu",kernelFunc:Jh};function kw(r,t,e){let n=r.shape,o=n[0],s=n[1],i=e.data.get(r.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[o,s],c=y.sizeFromShape(l),p=y.getTypedArrayFromDType("float32",c),m=y.getTypedArrayFromDType("float32",c);for(let g=0;g<o;g++){let x=Ro({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),b=Ro({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,s]}}),w=Cr({inputs:{real:x,imag:b},backend:e}),{real:C,imag:T}=S9(w,t,e),E=S.mergeRealAndImagArrays(C,T);for(let $=0;$<s;$++){let D=S.getComplexWithIndex(E,$);p[g*s+$]=D.real,m[g*s+$]=D.imag}e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w)}let f=e.makeTensorInfo(l,"float32",p),d=e.makeTensorInfo(l,"float32",m),h=Cr({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}function S9(r,t,e){let n=y.sizeFromShape(r.shape),o=e.data.get(r.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(T9(n)){let a=kN(s,i,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let l=e.makeTensorInfo(u,"float32",a.real),c=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",y.createScalarValue(n,"float32")),m=Ur({inputs:{x:p},backend:e}),f=Qh.kernelFunc({inputs:{a:l,b:p},backend:e}),d=Qh.kernelFunc({inputs:{a:c,b:m},backend:e}),h=e.data.get(f.dataId).values,g=e.data.get(d.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),u=N9(a,n,t);return S.splitRealAndImagArrays(u)}}function T9(r){return(r&r-1)===0}function kN(r,t,e,n,o){if(e===1)return{real:r,imag:t};let s=S.mergeRealAndImagArrays(r,t),i=e/2,a=S.complexWithEvenIndex(s),u=a.real,l=a.imag,c=[u.length],p=o.makeTensorInfo(c,"float32",u),m=o.makeTensorInfo(c,"float32",l),f=Cr({inputs:{real:p,imag:m},backend:o}),d=S.complexWithOddIndex(s),h=d.real,g=d.imag,x=[h.length],b=o.makeTensorInfo(x,"float32",h),w=o.makeTensorInfo(x,"float32",g),C=Cr({inputs:{real:b,imag:w},backend:o}),T=kN(u,l,i,n,o),E=T.real,$=T.imag,D=[E.length],P=o.makeTensorInfo(D,"float32",E),M=o.makeTensorInfo(D,"float32",$),W=Cr({inputs:{real:P,imag:M},backend:o}),H=kN(h,g,i,n,o),q=H.real,X=H.imag,j=[q.length],Z=o.makeTensorInfo(j,"float32",q),et=o.makeTensorInfo(j,"float32",X),K=Cr({inputs:{real:Z,imag:et},backend:o}),ot=S.exponents(e,n),st=[ot.real.length],it=o.makeTensorInfo(st,"float32",ot.real),pt=o.makeTensorInfo(st,"float32",ot.imag),at=Cr({inputs:{real:it,imag:pt},backend:o}),gt=Lc({inputs:{a:at,b:K},backend:o}),dt=Qi({inputs:{a:W,b:gt},backend:o}),bt=Yh({inputs:{a:W,b:gt},backend:o}),Tt=Eo({inputs:{input:dt},backend:o}),At=Eo({inputs:{input:bt},backend:o}),Rt=ta({inputs:{input:dt},backend:o}),qt=ta({inputs:{input:bt},backend:o}),Kt=Nu({inputs:[Tt,At],backend:o,attrs:{axis:0}}),me=Nu({inputs:[Rt,qt],backend:o,attrs:{axis:0}}),Ft=o.data.get(Kt.dataId).values,Ae=o.data.get(me.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(C),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(et),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(it),o.disposeIntermediateTensorInfo(pt),o.disposeIntermediateTensorInfo(at),o.disposeIntermediateTensorInfo(gt),o.disposeIntermediateTensorInfo(dt),o.disposeIntermediateTensorInfo(bt),o.disposeIntermediateTensorInfo(Tt),o.disposeIntermediateTensorInfo(Rt),o.disposeIntermediateTensorInfo(At),o.disposeIntermediateTensorInfo(qt),o.disposeIntermediateTensorInfo(Kt),o.disposeIntermediateTensorInfo(me),{real:Ft,imag:Ae}}function N9(r,t,e){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let u=S.exponent(o*a,t,e),l=S.getComplexWithIndex(r,a);s+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}e&&(s/=t,i/=t),S.assignToTypedArray(n,s,i,o)}return n}function k9(r){let{inputs:t,backend:e}=r,{input:n}=t,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=Jt({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=kw(a,!1,e),l=Jt({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var kO={kernelName:Pp,backendName:"cpu",kernelFunc:k9};function tg(r){let{backend:t,attrs:e}=r,{shape:n,value:o,dtype:s}=e,i=s||y.inferDtype(o),a=y.getArrayFromDType(i,y.sizeFromShape(n));return _9(a,o,i),t.makeTensorInfo(n,i,a)}var _O={kernelName:$l,backendName:"cpu",kernelFunc:tg};function _9(r,t,e){r.fill(t)}var EO={kernelName:ba,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,o=e,s=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[i,a,u,l]=n.shape,c=o.data.get(n.dataId).values;for(let m=0;m<i;m++){let f=m*u*a*l;for(let d=0;d<a;d++){let h=d*(u*l);for(let g=0;g<u;g++){let x=g*l;for(let b=0;b<l;b++){let w=Math.round(u-g-1),C=f+h+x+b,T=c[C];if(w>=0&&w<u){let E=w*l,$=f+h+E+b;T=c[$]}s[C]=T}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var E9=re((r,t)=>Math.floor(r/t)),A9=ie(us,E9,null,"int32"),AO={kernelName:us,backendName:"cpu",kernelFunc:A9};function $9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=TN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let x=Jt({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});h=Qi({inputs:{a:h,b:x},backend:e}),e.disposeIntermediateTensorInfo(x)}else h=Qi({inputs:{a:h,b:i},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){let g=h;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let x=Jt({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});h=Wc(e,h,f,x,d),e.disposeIntermediateTensorInfo(x)}else h=Wc(e,h,f,a,d);e.disposeIntermediateTensorInfo(g)}return h}var $O={kernelName:ki,backendName:"cpu",kernelFunc:$9};function D9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=NN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;h=Qi({inputs:{a:h,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=Wc(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var DO={kernelName:_i,backendName:"cpu",kernelFunc:D9};function R9(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=y.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[u,l,c,p]=S.prepareAndValidate(n,o);if(l===0)return e.makeTensorInfo(u,n.dtype,[]);let m=e.data.get(o.dataId).values,f=e.bufferSync(n),d=fw(m,f,n.dtype,l,a,c,p,n.shape,s);return e.makeTensorInfo(u,n.dtype,d.values)}var RO={kernelName:wa,backendName:"cpu",kernelFunc:R9};function F9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n;nt([o,s],"gatherV2");let u=y.parseAxisParam(i,o.shape)[0],l=e.data.get(s.dataId).values,c=o.shape[u];for(let C=0;C<l.length;++C){let T=l[C];y.assert(T<=c-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let m=y.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,u,p),d=Jt({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=Jt({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],x=e.bufferSync(h),b=e.bufferSync(d),w=dw(b,x,g);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.makeTensorInfo(f.outputShape,w.dtype,w.values)}var FO={kernelName:hi,backendName:"cpu",kernelFunc:F9};function O9(r){let{inputs:t,backend:e}=r,{input:n}=t,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=Jt({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=kw(a,!0,e),l=Jt({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var OO={kernelName:Lp,backendName:"cpu",kernelFunc:O9};var P9=Et(va,r=>Number.isFinite(r)?1:0,"bool"),PO={kernelName:va,backendName:"cpu",kernelFunc:P9};var L9=Et(Ia,r=>Math.abs(r)===1/0?1:0,"bool"),LO={kernelName:Ia,backendName:"cpu",kernelFunc:L9};var M9=Et(Sa,r=>Number.isNaN(r)?1:0,"bool"),MO={kernelName:Sa,backendName:"cpu",kernelFunc:M9};function z9(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=hw(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var zO={kernelName:zp,backendName:"cpu",kernelFunc:z9};var B9=Et(ka,r=>Math.log1p(r)),BO={kernelName:ka,backendName:"cpu",kernelFunc:B9};var V9=re((r,t)=>r&&t),G9=ie(_a,V9,null,"bool"),VO={kernelName:_a,backendName:"cpu",kernelFunc:G9};var W9=Et(Ea,r=>r?0:1,"bool"),GO={kernelName:Ea,backendName:"cpu",kernelFunc:W9};var U9=re((r,t)=>r||t),H9=ie(Aa,U9,null,"bool"),WO={kernelName:Aa,backendName:"cpu",kernelFunc:H9};function q9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n;nt(o,"LRN");let l=o.shape[3],c=l-1,p=e.data.get(o.dataId).values,m=y.sizeFromShape(o.shape),f=new Float32Array(m);function d(h){let g=h%l,x=h-g+Math.max(0,g-s),b=h-g+Math.min(g+s,c),w=0;for(;x<=b;x++){let C=p[x];w+=C*C}return w}for(let h=0;h<m;h++){let g=d(h),x=p[h]*Math.pow(i+a*g,-u);f[h]=x}return e.makeTensorInfo(o.shape,o.dtype,f)}var UO={kernelName:Dl,backendName:"cpu",kernelFunc:q9};function K9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n;nt(i,"LRNGrad");let p=y.sizeFromShape(i.shape),m=i.shape[3],f=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=e.data.get(s.dataId).values,g=new Float32Array(p),x=p;for(let b=0;b<x;b++){let w=b%m,C=b-w+Math.max(0,w-a),T=b-w+Math.min(m,w+a+1),E=0;for(let $=C;$<T;$++)E+=Math.pow(d[$],2);E=l*E+u;for(let $=C;$<T;$++){let D=-2*l*c*d[$]*h[b]/E;b===$&&(D+=Math.pow(E,-c)),D*=f[b],g[$]+=D}}return e.makeTensorInfo(i.shape,o.dtype,g)}var HO={kernelName:Bp,backendName:"cpu",kernelFunc:K9};function _N(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=e,u=o.shape,l=u.length,c=y.parseAxisParam(s,u),p=c,m=S.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(m!=null){let C=new Array(l);for(let T=0;T<C.length;T++)C[T]=u[m[T]];f=gd(f,u,o.dtype,m,C),p=S.getInnerMostAxes(p.length,l),u=C}nt(o,"max"),S.assertAxesAreInnerMostDims("max",p,l);let[d,h]=S.computeOutAndReduceShapes(u,p),g=y.sizeFromShape(h),x=gw(f,g,d,o.dtype),b=a.write(x,d,o.dtype),w=d;return i&&(w=S.expandShapeToKeepDim(d,c)),{dataId:b,shape:w,dtype:o.dtype}}var qO={kernelName:ds,backendName:"cpu",kernelFunc:_N};function j9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;nt(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))p=Ur({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=y.computeStrides(o.shape),d=bd(m,o.shape,o.dtype,f,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var KO={kernelName:gs,backendName:"cpu",kernelFunc:j9};function X9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;nt(o,"maxPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=Nw(p,o.shape,o.dtype,y.computeStrides(o.shape),c,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}var jO={kernelName:Rl,backendName:"cpu",kernelFunc:X9};function Y9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;nt([o,s],"maxPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=e.bufferSync(s),m=WF(p,c),f=c.strideDepth,d=c.strideHeight,h=c.strideWidth,g=c.dilationDepth,x=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,C=c.effectiveFilterHeight,T=c.effectiveFilterWidth,E=w-1-c.padInfo.front,$=T-1-c.padInfo.left,D=C-1-c.padInfo.top,P=vt(s.shape,"float32"),M=e.bufferSync(o);for(let W=0;W<c.batchSize;++W)for(let H=0;H<c.inChannels;++H)for(let q=0;q<c.inDepth;++q)for(let X=0;X<c.inHeight;++X)for(let j=0;j<c.inWidth;++j){let Z=q-E,et=X-D,K=j-$,ot=0;for(let st=0;st<w;st+=g){let it=(Z+st)/f;if(!(it<0||it>=c.outDepth||Math.floor(it)!==it))for(let pt=0;pt<C;pt+=x){let at=(et+pt)/d;if(!(at<0||at>=c.outHeight||Math.floor(at)!==at))for(let gt=0;gt<T;gt+=b){let dt=(K+gt)/h;if(dt<0||dt>=c.outWidth||Math.floor(dt)!==dt)continue;let bt=w*C*T-1-m.get(W,it,at,dt,H),Tt=st*C*T+pt*T+gt,At=bt===Tt?1:0;if(At===0)continue;ot+=M.get(W,it,at,dt,H)*At}}}P.set(ot,W,q,X,j,H)}return e.makeTensorInfo(P.shape,P.dtype,P.values)}var XO={kernelName:Gp,backendName:"cpu",kernelFunc:Y9};function Z9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;nt([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=e.data.get(a.dataId).values,d=vt(m.outShape,a.dtype,Tw(f,a.shape,a.dtype,m).values),h=m.strideHeight,g=m.strideWidth,x=m.dilationHeight,b=m.dilationWidth,w=m.effectiveFilterHeight,C=m.effectiveFilterWidth,T=C-1-m.padInfo.left,E=w-1-m.padInfo.top,$=vt(a.shape,"float32"),D=e.data.get(o.dataId).values,P=vt(o.shape,"float32",D);for(let M=0;M<m.batchSize;++M)for(let W=0;W<m.inChannels;++W)for(let H=0;H<m.inHeight;++H)for(let q=0;q<m.inWidth;++q){let X=H-E,j=q-T,Z=0;for(let et=0;et<w;et+=x){let K=(X+et)/h;if(!(K<0||K>=m.outHeight||Math.floor(K)!==K))for(let ot=0;ot<C;ot+=b){let st=(j+ot)/g;if(st<0||st>=m.outWidth||Math.floor(st)!==st)continue;let it=w*C-1-d.get(M,K,st,W),pt=et*C+ot,at=it===pt?1:0;if(at===0)continue;Z+=P.get(M,K,st,W)*at}}$.set(Z,M,H,q,W)}return e.makeTensorInfo($.shape,$.dtype,$.values)}var YO={kernelName:Vp,backendName:"cpu",kernelFunc:Z9};function ZO(r,t,e,n,o){let s=y.computeStrides(t),i=bd(r,t,e,s,o,"max"),a=Tw(r,t,e,o,!0,n);return[i.values,a.values]}var JO={kernelName:Wp,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;nt(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,c=S.computePool2DInfo(n.shape,o,s,[1,1],i),[p,m]=ZO(l,n.shape,n.dtype,a,c),f=u.write(p,c.outShape,n.dtype),d=u.write(m,c.outShape,n.dtype);return[{dataId:f,shape:c.outShape,dtype:n.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function J9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=y.parseAxisParam(s,o.shape),l=S.computeOutAndReduceShapes(o.shape,a)[1],c=y.sizeFromShape(l),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(m);let f=Ao({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(f);let d=Jh({inputs:{a:f,b:m},backend:e});p.push(d);let h=dl({inputs:{x:d},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var QO={kernelName:xs,backendName:"cpu",kernelFunc:J9};function Q9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"min");let a=y.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=Ue({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=y.sizeFromShape(m),d=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let x=0;x<d.length;++x){let b=x*f,w=h[b];for(let C=0;C<f;++C){let T=h[b+C];(Number.isNaN(T)||T<w)&&(w=T)}d[x]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let x=S.expandShapeToKeepDim(p,a),b=Jt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b}return g}var tP={kernelName:ys,backendName:"cpu",kernelFunc:Q9};function tQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,mode:i}=n;nt(o,"mirrorPad");let a=s.map((w,C)=>w[0]+o.shape[C]+w[1]),u=s.map(w=>w[0]),l=s.map((w,C)=>w[0]+o.shape[C]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,m=o.shape.length,f=y.computeStrides(o.shape),d=y.sizeFromShape(a),h=a.length,g=y.computeStrides(a),x=y.getTypedArrayFromDType(o.dtype,d);for(let w=0;w<d;w++){let C=y.indexToLoc(w,h,g);for(let E=0;E<h;E++)C[E]<u[E]?C[E]=u[E]*2-C[E]-c:C[E]>=l[E]&&(C[E]=(l[E]-1)*2-C[E]+c);C=C.map((E,$)=>E-u[$]);let T=y.locToIndex(C,m,f);x[w]=p[T]}return{dataId:e.write(x,a,o.dtype),shape:a,dtype:o.dtype}}var eP={kernelName:ws,backendName:"cpu",kernelFunc:tQ};var eQ=re((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),rQ=ie($a,eQ),rP={kernelName:$a,backendName:"cpu",kernelFunc:rQ};var oP=Tl(vh());function EN(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let u=y.parseAxisParam([a],o.shape),l=_N({inputs:{x:o},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),c=S.expandShapeToKeepDim(l.shape,u),p=Jt({inputs:{x:l},backend:e,attrs:{shape:c}}),m=Yh({inputs:{a:o,b:p},backend:e}),f=eN({inputs:{x:m},backend:e}),d=dl({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),h=Jt({inputs:{x:d},backend:e,attrs:{shape:c}}),g=Jh({inputs:{a:f,b:h},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var nP={kernelName:Ms,backendName:"cpu",kernelFunc:EN};function nQ(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n;nt(o,"multinomial");let u=a?o:EN({inputs:{logits:o},backend:e,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],p=e.data.get(u.dataId).values,m=[l,s],f=y.makeZerosTypedArray(y.sizeFromShape(m),"int32");for(let d=0;d<l;++d){let h=d*c,g=new Float32Array(c-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let x=oP.alea(i.toString()),b=d*s;for(let w=0;w<s;++w){let C=x();f[b+w]=g.length;for(let T=0;T<g.length;T++)if(C<g[T]){f[b+w]=T;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(m,"int32",f)}var sP={kernelName:Up,backendName:"cpu",kernelFunc:nQ};var oQ=Vr.nonMaxSuppressionV3Impl;function sQ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n;nt(o,"NonMaxSuppression");let l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=oQ(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var iP={kernelName:Ra,backendName:"cpu",kernelFunc:sQ};var iQ=Vr.nonMaxSuppressionV4Impl;function aQ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n;nt(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=iQ(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var aP={kernelName:Fa,backendName:"cpu",kernelFunc:aQ};var lQ=Vr.nonMaxSuppressionV5Impl;function uQ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n;nt(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:x}=lQ(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var lP={kernelName:Oa,backendName:"cpu",kernelFunc:uQ};function cQ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:u}=n;nt(o,"oneHot");let l=y.sizeFromShape(o.shape),c=new Float32Array(l*i);c.fill(u);let p=e.data.get(o.dataId).values;for(let m=0;m<l;++m)p[m]>=0&&p[m]<i&&(c[m*i+p[m]]=a);return e.makeTensorInfo([...o.shape,i],s,c)}var uP={kernelName:vs,backendName:"cpu",kernelFunc:cQ};function eg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Eo({inputs:{input:n},backend:e}),s=eg({inputs:{x:o},backend:e}),i=ta({inputs:{input:n},backend:e}),a=eg({inputs:{x:i},backend:e}),u=Cr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return tg({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var cP={kernelName:Ti,backendName:"cpu",kernelFunc:eg};function pP(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Eo({inputs:{input:n},backend:e}),s=pP({inputs:{x:o},backend:e}),i=ta({inputs:{input:n},backend:e}),a=eg({inputs:{x:i},backend:e}),u=Cr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return tg({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var mP={kernelName:xi,backendName:"cpu",kernelFunc:pP};function AN(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return wd({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=wd({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=Nu({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var fP={kernelName:yi,backendName:"cpu",kernelFunc:AN};function pQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;nt(o,"pad");let a=s.map((b,w)=>b[0]+o.shape[w]+b[1]),u=s.map(b=>b[0]),l=e.data.get(o.dataId).values,c=y.sizeFromShape(o.shape),p=o.shape.length,m=y.computeStrides(o.shape),f=y.sizeFromShape(a),d=a.length,h=y.computeStrides(a),g=y.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let b=0;b<c;b++){let C=y.indexToLoc(b,p,m).map((E,$)=>E+u[$]),T=y.locToIndex(C,d,h);g[T]=l[b]}return{dataId:e.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var _w={kernelName:Is,backendName:"cpu",kernelFunc:pQ};var mQ=re((r,t)=>Math.pow(r,t)),fQ=ie(Ss,mQ),dP={kernelName:Ss,backendName:"cpu",kernelFunc:fQ};function dQ(r){let{inputs:t,backend:e,attrs:n}=r,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=n,l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,m=a.map(g=>e.data.get(g.dataId).values),f=a.map(g=>g.shape),[d,h]=xw(l,o.shape,c,s.shape,s.dtype,p,i.shape,m,f,u);return e.makeTensorInfo(d,s.dtype,h)}var hP={kernelName:Hp,backendName:"cpu",kernelFunc:dQ};function hQ(r){let{backend:t,attrs:e}=r,{start:n,stop:o,dtype:s,step:i}=e,a=Mc(n,o,i,s);return t.makeTensorInfo([a.length],s,a)}var gP={kernelName:Fl,backendName:"cpu",kernelFunc:hQ};var gQ=Et(Pa,r=>1/r),xP={kernelName:Pa,backendName:"cpu",kernelFunc:gQ};function xQ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;nt(o,"resizeBilinear");let u=y.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([p,l,c,d])),x=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=0,C=x[0]/b[0],T=x[1]/b[1];for(let E=0;E<p;E++)for(let $=0;$<l;$++){let D;i?D=C*($+.5)-.5:D=C*$;let P=Math.max(0,Math.floor(D)),M=D-P,W=Math.min(m-1,Math.ceil(D)),H=E*u[0]+P*u[1],q=E*u[0]+W*u[1];for(let X=0;X<c;X++){let j;i?j=T*(X+.5)-.5:j=T*X;let Z=Math.max(0,Math.floor(j)),et=j-Z,K=Math.min(f-1,Math.ceil(j)),ot=H+Z*u[2],st=q+Z*u[2],it=H+K*u[2],pt=q+K*u[2];for(let at=0;at<d;at++){let gt=h[ot+at],dt=h[st+at],bt=h[it+at],Tt=h[pt+at],At=gt+(bt-gt)*et,Rt=dt+(Tt-dt)*et,qt=At+(Rt-At)*M;g[w++]=qt}}}return e.makeTensorInfo([p,l,c,d],"float32",g)}var yP={kernelName:Es,backendName:"cpu",kernelFunc:xQ};function yQ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;nt([s,o],"resizeBilinearGrad");let a=y.computeStrides(o.shape),[u,l,c,p]=o.shape,[,m,f]=s.shape,d=new Float32Array(u*l*c*p),h=[i&&m>1?l-1:l,i&&f>1?c-1:c],g=[i&&m>1?m-1:m,i&&f>1?f-1:f],x=h[0]/g[0],b=h[1]/g[1],w=e.data.get(s.dataId).values,C=0;for(let T=0;T<u;T++){let E=T*a[0];for(let $=0;$<m;$++){let D=$*x,P=Math.floor(D),M=Math.min(Math.ceil(D),l-1),W=E+P*a[1],H=E+M*a[1],q=D-P,X=1-q;for(let j=0;j<f;j++){let Z=j*b,et=Math.floor(Z),K=Math.min(Math.ceil(Z),c-1),ot=Z-et,st=1-ot,it=W+et*a[2],pt=W+K*a[2],at=H+et*a[2],gt=H+K*a[2],dt=X*st,bt=X*ot,Tt=q*st,At=q*ot;for(let Rt=0;Rt<p;Rt++){let qt=w[C++];d[it+Rt]+=qt*dt,d[pt+Rt]+=qt*bt,d[at+Rt]+=qt*Tt,d[gt+Rt]+=qt*At}}}}return e.makeTensorInfo([u,c,l,p],"float32",d)}var bP={kernelName:jp,backendName:"cpu",kernelFunc:yQ};function bQ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;nt(o,"resizeNearestNeighbor");let u=y.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(p*l*c*d),x=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=x[0]/b[0],C=x[1]/b[1],T=0;for(let E=0;E<p;E++){let $=E*u[0];for(let D=0;D<l;D++){let P=i?w*(D+.5):w*D,M=Math.min(m-1,s?Math.round(P):Math.floor(P));i&&(M=Math.max(0,M));let W=$+M*u[1];for(let H=0;H<c;H++){let q=i?C*(H+.5):C*H,X=Math.min(f-1,s?Math.round(q):Math.floor(q));i&&(X=Math.max(0,X));let j=W+X*u[2];for(let Z=0;Z<d;Z++){let et=h[j+Z];g[T++]=et}}}}return e.makeTensorInfo([p,l,c,d],o.dtype,g)}var wP={kernelName:_s,backendName:"cpu",kernelFunc:bQ};function wQ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;nt([s,o],"resizeNearestNeighborGrad");let a=y.computeStrides(o.shape),u=y.computeStrides(s.shape),[l,c,p,m]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*c*p*m),g=e.data.get(s.dataId).values,x=[i&&f>1?c-1:c,i&&d>1?p-1:p],b=[i&&f>1?f-1:f,i&&d>1?d-1:d],w=x[0]/b[0],C=x[1]/b[1],T=1/w,E=1/C,$=Math.ceil(T)*2+2,D=Math.ceil(E)*2+2;for(let P=0;P<l;P++){let M=P*a[0];for(let W=0;W<c;W++){let H=M+W*a[1],q=Math.floor(W*T),X=Math.floor(q-$/2);for(let j=0;j<p;j++){let Z=H+j*a[2],et=Math.floor(j*E),K=Math.floor(et-D/2);for(let ot=0;ot<m;ot++){let st=0;for(let it=0;it<$;it++){let pt=it+X;if(pt<0||pt>=f)continue;let at=M+pt*u[1],gt=pt*w,dt=Math.min(c-1,i?Math.round(gt):Math.floor(gt));if(W===dt)for(let bt=0;bt<D;bt++){let Tt=bt+K;if(Tt<0||Tt>=d)continue;let At=at+Tt*u[2],Rt=Tt*C,qt=Math.min(p-1,i?Math.round(Rt):Math.floor(Rt));j===qt&&(st+=g[At+ot])}}h[Z+ot]=st}}}}return e.makeTensorInfo(o.shape,o.dtype,h)}var CP={kernelName:Kp,backendName:"cpu",kernelFunc:wQ};function CQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n;nt(o,"reverse");let i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return Ur({inputs:{x:o},backend:e});let u=new fe(o.shape,o.dtype),l=e.bufferSync(o);for(let c=0;c<u.size;c++){let p=u.indexToLoc(c),m=p.slice();a.forEach(f=>m[f]=o.shape[f]-1-m[f]),u.set(l.get(...m),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var vP={kernelName:$s,backendName:"cpu",kernelFunc:CQ};var IP={kernelName:qa,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[l,c,p,m]=n.shape,[f,d]=S.getImageCenter(i,c,p),h=255,g=Math.sin(o),x=Math.cos(o),b=a.data.get(n.dataId).values;for(let C=0;C<l;C++){let T=C*p*c*m;for(let E=0;E<c;E++){let $=E*(p*m);for(let D=0;D<p;D++){let P=D*m;for(let M=0;M<m;M++){let W=[l,E,D,M],H=W[2],q=W[1],X=(H-f)*x-(q-d)*g,j=(H-f)*g+(q-d)*x;X=Math.round(X+f),j=Math.round(j+d);let Z=s;if(typeof s!="number"&&(M===3?Z=h:Z=s[M]),X>=0&&X<p&&j>=0&&j<c){let K=j*(p*m),ot=X*m,st=T+K+ot+M;Z=b[st]}let et=T+$+P+M;u[et]=Z}}}}return{dataId:a.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var vQ=Et(Ds,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),SP={kernelName:Ds,backendName:"cpu",kernelFunc:vQ};function IQ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=!0,f=e.bufferSync(o),d=e.bufferSync(s),h=fl(f,d,i,p,l,u,a,c,0,m);return e.makeTensorInfo(i,h.dtype,h.values)}var TP={kernelName:La,backendName:"cpu",kernelFunc:IQ};function SQ(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<t?e=o+1:n=o;return n}function TQ(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<=t?e=o+1:n=o;return n}function NP(r,t,e,n,o,s){let i=y.getArrayFromDType("int32",e*o);for(let a=0;a<e;++a){let u=r.slice(a*n,(a+1)*n),l=a*o;for(let c=0;c<o;++c)i[l+c]=s==="left"?SQ(u,t[c+l]):TQ(u,t[c+l])}return i}function NQ(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=NP(a,u,o.shape[0],o.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",l)}var kP={kernelName:Xp,backendName:"cpu",kernelFunc:NQ};function kQ(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t;nt([n,o,s],"select");let i=n.shape.length,a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=ir(o.dtype,s.dtype),p=y.makeZerosTypedArray(y.sizeFromShape(o.shape),c),m=0,f=i===0||i>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let d=0;d<a.length;d++)for(let h=0;h<f;h++)a[d]===1?p[m++]=u[d]:p[m++]=l[d];return e.makeTensorInfo(o.shape,c,p)}var _P={kernelName:wi,backendName:"cpu",kernelFunc:kQ};var _Q=S.SELU_SCALEALPHA,EQ=S.SELU_SCALE,AQ=Et(Ma,r=>r>=0?EQ*r:_Q*(Math.exp(r)-1)),EP={kernelName:Ma,backendName:"cpu",kernelFunc:AQ};var $Q=Et(Ba,r=>r<0?-1:r>0?1:0),AP={kernelName:Ba,backendName:"cpu",kernelFunc:$Q};var DQ=Et(Fs,r=>Math.sin(r)),$P={kernelName:Fs,backendName:"cpu",kernelFunc:DQ};var RQ=Et(za,r=>Math.sinh(r)),DP={kernelName:za,backendName:"cpu",kernelFunc:RQ};var FQ=11920928955078125e-23,RP=Math.log(FQ)+2,OQ=Et(Va,r=>{let t=r>-RP,e=r<RP,n=Math.exp(r),o;return e?o=n:t?o=r:o=Math.log(1+n),o}),FP={kernelName:Va,backendName:"cpu",kernelFunc:OQ};function PQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;nt([o],"spaceToBatchND");let a=y.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=_w.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=Jt({inputs:{x:l},backend:e,attrs:{shape:c}}),b=Ue({inputs:{x:h},backend:e,attrs:{perm:p}}),T=Jt({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(b),T}var OP={kernelName:vi,backendName:"cpu",kernelFunc:PQ};function LQ(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,m,f,d,h]=yw(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var PP={kernelName:Ol,backendName:"cpu",kernelFunc:LQ};function MQ(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(n.dataId).values,u=Array.from(e.data.get(s.dataId).values),[l,c,p]=bw(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var LP={kernelName:Ga,backendName:"cpu",kernelFunc:MQ};function zQ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=yd(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var MP={kernelName:Pl,backendName:"cpu",kernelFunc:zQ};function BQ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=yd(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var zP={kernelName:Ll,backendName:"cpu",kernelFunc:BQ};function VQ(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,o,a),f=!1,d=e.bufferSync(o),h;switch(s.dtype){case"bool":{let g=e.bufferSync(s),x=Boolean(e.data.get(i.dataId).values[0]);h=fl(d,g,a,m,c,l,u,p,x,f);break}case"float32":{let g=e.bufferSync(s),x=e.data.get(i.dataId).values[0];h=fl(d,g,a,m,c,l,u,p,x,f);break}case"int32":{let g=e.bufferSync(s),x=e.data.get(i.dataId).values[0];h=fl(d,g,a,m,c,l,u,p,x,f);break}case"string":{let g=e.bufferSync(s),x=y.decodeString(e.data.get(i.dataId).values[0]);h=fl(d,g,a,m,c,l,u,p,x,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,h.dtype,h.values)}var BP={kernelName:Yp,backendName:"cpu",kernelFunc:VQ};function GQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=y.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=Ro({inputs:{x:o},backend:e,attrs:{begin:l,size:m}});return l[a]+=p,f})}var VP={kernelName:Ii,backendName:"cpu",kernelFunc:GQ};var GP={kernelName:Ml,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;nt(e,"square");let o=n.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let u=o[a];s[a]=u*u}return{dataId:n.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var WQ=Et(co,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),WP={kernelName:co,backendName:"cpu",kernelFunc:WQ};function UQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n;nt(o,"stridedSlice");let{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:b,end:w,strides:C}=Be.sliceInfo(o.shape,s,i,a,u,l,c,p,m),T;if(h)T=Jt({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Be.computeOutShape(b,w,C),$=Ro({inputs:{x:o},backend:e,attrs:{begin:b,size:E}});T=Jt({inputs:{x:$},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo($)}else{let E=e.bufferSync(o),$=ww(f,E,C,b);T=e.makeTensorInfo(d,$.dtype,$.values)}return T}var UP={kernelName:Wa,backendName:"cpu",kernelFunc:UQ};function HQ(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.data.get(c.dataId).values,f=e.data.get(p.dataId).values,[d,h]=Bc(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var HP={kernelName:zl,backendName:"cpu",kernelFunc:HQ};function qQ(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values[0],[l,c,p]=Vc(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var qP={kernelName:Bl,backendName:"cpu",kernelFunc:qQ};function KQ(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=Gc(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var KP={kernelName:Vl,backendName:"cpu",kernelFunc:KQ};var jQ=Et(Vs,r=>Math.tan(r)),jP={kernelName:Vs,backendName:"cpu",kernelFunc:jQ};var XQ=Et(Gs,r=>Math.tanh(r)),XP={kernelName:Gs,backendName:"cpu",kernelFunc:XQ};function YQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;nt(o,"tile");let i=Cw(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var YP={kernelName:Xn,backendName:"cpu",kernelFunc:YQ};function ZQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n;nt(o,"topk");let a=e.data.get(o.dataId).values,[u,l]=vw(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}var ZP={kernelName:Ua,backendName:"cpu",kernelFunc:ZQ};function JQ(r){let{inputs:t,attrs:e,backend:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=e,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],x=y.computeStrides(o.shape),b=x[0],w=x[1],C=x[2],T=y.computeStrides(g),E=T[0],$=T[1],D=T[2],P=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));P.fill(u);let M=n.data.get(o.dataId).values,W=n.data.get(s.dataId).values;for(let q=0;q<c;++q){let X=s.shape[0]===1?W:W.subarray(q*8,q*8+8);for(let j=0;j<d;++j)for(let Z=0;Z<h;++Z)for(let et=0;et<f;++et){let K,ot=X[6]*Z+X[7]*j+1;if(ot===0)continue;let st=(X[0]*Z+X[1]*j+X[2])/ot,it=(X[3]*Z+X[4]*j+X[5])/ot,pt=JP(st,m,a),at=JP(it,p,a);switch(i){case"nearest":K=ntt(M,p,m,b,w,C,q,at,pt,et,u);break;case"bilinear":K=ott(M,p,m,b,w,C,q,at,pt,et,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let gt=q*E+j*$+Z*D+et;P[gt]=K}return n.makeTensorInfo(g,o.dtype,P)}return{dataId:n.write(P,g,o.dtype),shape:o.shape,dtype:o.dtype}}var QP={kernelName:Ha,backendName:"cpu",kernelFunc:JQ};function JP(r,t,e){switch(e){case"reflect":return QQ(r,t);case"wrap":return ttt(r,t);case"nearest":return rtt(r,t);case"constant":default:return ett(r,t)}}function QQ(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{let n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return y.clamp(0,e,t-1)}function ttt(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{let n=t-1;e-=t*Math.trunc(e/n)}return y.clamp(0,e,t-1)}function ett(r,t){return r}function rtt(r,t){return y.clamp(0,r,t-1)}function rg(r,t,e,n,o,s,i,a,u,l,c){let p=i*n+a*o+u*s+l;return 0<=a&&a<t&&0<=u&&u<e?r[p]:c}function ntt(r,t,e,n,o,s,i,a,u,l,c){let p=Math.round(a),m=Math.round(u);return rg(r,t,e,n,o,s,i,p,m,l,c)}function ott(r,t,e,n,o,s,i,a,u,l,c){let p=Math.floor(a),m=Math.floor(u),f=p+1,d=m+1,h=(d-u)*rg(r,t,e,n,o,s,i,p,m,l,c)+(u-m)*rg(r,t,e,n,o,s,i,p,d,l,c),g=(d-u)*rg(r,t,e,n,o,s,i,f,m,l,c)+(u-m)*rg(r,t,e,n,o,s,i,f,d,l,c);return(f-a)*h+(a-p)*g}function stt(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;nt(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:l}=Iw(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var tL={kernelName:Zp,backendName:"cpu",kernelFunc:stt};function itt(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],u=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let m=new Array(a);for(let f=0;f<m.length;f++){c[s]=f;let d=Ro({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});m[f]=Jt({inputs:{x:d},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(d)}return m}var eL={kernelName:Si,backendName:"cpu",kernelFunc:itt};function att(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n;nt(o,"unsortedSegmentSum");let a=o.shape.length,u=s.shape.length,l=[],c=[],p=a-u,m=s;for(let d=0;d<p;++d){let h=wd({inputs:{input:m},backend:e,attrs:{dim:d+1}});m=h,c.push(h)}for(let d=0;d<i;++d){let h=y.createScalarValue(d,"int32"),g=e.makeTensorInfo([],"int32",h),x=QT({inputs:{a:g,b:m},backend:e}),b=Ao({inputs:{x},backend:e,attrs:{dtype:"float32"}}),w=Lc({inputs:{a:b,b:o},backend:e}),C=dl({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});l.push(C),c.push(g),c.push(x),c.push(b),c.push(w),c.push(C)}let f=AN({inputs:l,backend:e,attrs:{axis:0}});return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var rL={kernelName:Gl,backendName:"cpu",kernelFunc:att};var ltt=[AF,WR,$F,DF,jR,RF,FF,OF,PF,LF,MF,zF,BF,VF,GF,UF,HF,qF,KF,EF,jF,XF,YF,ZF,KR,XR,JF,UR,QF,eO,rO,nO,oO,sO,iO,aO,lO,uO,cO,pO,mO,fO,dO,hO,gO,xO,yO,bO,wO,CO,IO,IF,SO,YR,TO,ZR,NO,JR,kO,_O,EO,QR,AO,$O,DO,RO,FO,tF,eF,HR,OO,tO,PO,LO,MO,SF,rF,nF,zO,oF,BO,VO,GO,WO,UO,HO,qO,sF,KO,jO,XO,YO,JO,QO,tP,iF,eP,rP,sP,aF,lF,iP,aP,lP,uF,uP,mP,fP,_w,dP,TF,pF,hP,gP,qR,Qh,xP,NF,kF,_F,yP,bP,wP,CP,vP,IP,SP,dF,TP,kP,_P,EP,gF,AP,$P,DP,xF,nP,FP,OP,PP,LP,MP,zP,BP,VP,bF,GP,wF,WP,UP,HP,qP,KP,CF,vO,jP,XP,YP,ZP,QP,cF,tL,eL,rL,cP];for(let r of ltt)Wu(r);var Id={};jt(Id,{assertNotComplex:()=>oi,bindCanvasToFramebuffer:()=>xtt,bindColorTextureToFramebuffer:()=>ig,bindTextureToProgramUniformSampler:()=>qN,bindTextureUnit:()=>iL,bindVertexBufferToProgramAttribute:()=>Fw,callAndCheck:()=>Ct,canBeRepresented:()=>FN,createFragmentShader:()=>PN,createFramebuffer:()=>WN,createProgram:()=>LN,createStaticIndexBuffer:()=>BN,createStaticVertexBuffer:()=>zN,createTexture:()=>VN,createVertexShader:()=>ON,getBatchDim:()=>gl,getExtensionOrThrow:()=>Cd,getFramebufferErrorMessage:()=>aL,getMaxTexturesInShader:()=>XN,getNumChannels:()=>htt,getProgramUniformLocation:()=>HN,getProgramUniformLocationOrThrow:()=>UN,getRowsCols:()=>xl,getShapeAs3D:()=>ag,getTextureShapeFromLogicalShape:()=>KN,getWebGLDisjointQueryTimerVersion:()=>YN,getWebGLErrorMessage:()=>sL,getWebGLMaxTextureSize:()=>jN,hasExtension:()=>Wn,isCapableOfRenderingToFloatTexture:()=>ZN,isDownloadFloatTextureEnabled:()=>JN,isReshapeFree:()=>_u,isWebGLFenceEnabled:()=>QN,isWebGLVersionEnabled:()=>Pw,linkProgram:()=>MN,logShaderSourceAndInfoLog:()=>Rw,resetMaxTextureSize:()=>ytt,resetMaxTexturesInShader:()=>btt,unbindColorTextureFromFramebuffer:()=>Ow,unbindTextureUnit:()=>gtt,validateFramebuffer:()=>vd,validateProgram:()=>sg,validateTextureSize:()=>GN});var Uc={},Ew={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function $N(r,t){Uc[r]=t}function Gn(r,t){if(!(r in Uc)||t!=null){let n=ctt(r,t);if(n!==null)Uc[r]=n;else return console.log("Could not get context for WebGL version",r),null}let e=Uc[r];return e==null||e.isContextLost()?(delete Uc[r],Gn(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Uc[r])}function utt(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function ctt(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t==null?utt(r):t;return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Uc[r]},!1),B().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ew.failIfMajorPerformanceCaveat=!1),r===1?e.getContext("webgl",Ew)||e.getContext("experimental-webgl",Ew):e.getContext("webgl2",Ew)}var ku;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(ku||(ku={}));var Hr;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(Hr||(Hr={}));var Fr;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Fr||(Fr={}));function Hc(r,t){return[t,r]}function nL(r,t){return r*t}function ng(r){let t=y.sizeFromShape(r),e=Math.ceil(t/4);return y.sizeToSquarishShape(e)}function ea(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function oL(r,t){let[e,n]=ea(r,t);return e*n*4}function og(r,t){let e=r,n,o,s,i,a,u,l,c,p,m;return B().getNumber("WEBGL_VERSION")===2?(n=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,l=4,c=1,p=e.HALF_FLOAT,m=e.FLOAT,u=e.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=e.RGBA,a=r.RGBA,l=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,m=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function Ct(r,t){let e=t();return B().getBool("DEBUG")&&ptt(r),e}function ptt(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+sL(r,t))}var mtt=596e-10,ftt=65504;function FN(r){return!!(B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||mtt<Math.abs(r)&&Math.abs(r)<ftt)}function sL(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Cd(r,t){return hl(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function ON(r,t){let e=hl(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ct(r,()=>r.shaderSource(e,t)),Ct(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function PN(r,t){let e=hl(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ct(r,()=>r.shaderSource(e,t)),Ct(r,()=>r.compileShader(e)),B().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw Rw(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var dtt=/ERROR: [0-9]+:([0-9]+):/g;function Rw(r,t){let e=dtt.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((p,m)=>y.rightPad((m+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${y.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function LN(r){return hl(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function MN(r,t){if(Ct(r,()=>r.linkProgram(t)),!B().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function sg(r,t){if(Ct(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function zN(r,t){let e=hl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Ct(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),Ct(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function BN(r,t){let e=hl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Ct(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),Ct(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function htt(){return B().getNumber("WEBGL_VERSION")===2?1:4}function VN(r){return hl(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function GN(r,t){let e=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function WN(r){return hl(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Fw(r,t,e,n,o,s,i){let a=r.getAttribLocation(t,e);return a===-1?!1:(Ct(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Ct(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),Ct(r,()=>r.enableVertexAttribArray(a)),!0)}function iL(r,t,e){lL(r,e),Ct(r,()=>r.activeTexture(r.TEXTURE0+e)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function gtt(r,t){lL(r,t),Ct(r,()=>r.activeTexture(r.TEXTURE0+t)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function UN(r,t,e){return hl(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function HN(r,t,e){return r.getUniformLocation(t,e)}function qN(r,t,e,n){Ct(r,()=>iL(r,t,n)),Ct(r,()=>r.uniform1i(e,n))}function xtt(r){Ct(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),Ct(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),Ct(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function ig(r,t,e){Ct(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Ct(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function Ow(r,t){Ct(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Ct(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function vd(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+aL(r,t))}function aL(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function hl(r,t,e){let n=Ct(r,()=>t());if(n==null)throw new Error(e);return n}function lL(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function gl(r,t=2){return y.sizeFromShape(r.slice(0,r.length-t))}function xl(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function ag(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[gl(r),...xl(r)]),t}function KN(r,t=!1){let e=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,r=r.map((o,s)=>s>=r.length-2?y.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=y.squeezeShape(r).newShape);let n=y.sizeFromShape(r);if(r.length<=1&&n<=e)return[1,n];if(r.length===2&&r[0]<=e&&r[1]<=e)return r;if(r.length===3&&r[0]*r[1]<=e&&r[2]<=e)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=e&&r[1]*r[2]<=e)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e)return[r[0],r[1]*r[2]*r[3]];if(t){let o=gl(r),s=2,i=2;return r.length&&([s,i]=xl(r)),n=o*(s/2)*(i/2),y.sizeToSquarishShape(n).map(a=>a*2)}return y.sizeToSquarishShape(n)}function Aw(r){return r%2===0}function _u(r,t){if(r=r.slice(-2),t=t.slice(-2),y.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],n=t.slice(-1)[0];if(e===n||Aw(e)&&Aw(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&Aw(r[0])&&Aw(t[0])}var $w,Dw;function jN(r){if($w==null){let t=Gn(r);$w=t.getParameter(t.MAX_TEXTURE_SIZE)}return $w}function ytt(){$w=null}function btt(){Dw=null}function XN(r){if(Dw==null){let t=Gn(r);Dw=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Dw)}function YN(r){if(r===0)return 0;let t,e=Gn(r);return Wn(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Wn(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Wn(r,t){return r.getExtension(t)!=null}function Pw(r){try{if(Gn(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function ZN(r){if(r===0)return!1;let t=Gn(r);if(r===1){if(!Wn(t,"OES_texture_float"))return!1}else if(!Wn(t,"EXT_color_buffer_float"))return!1;return RN(t)}function JN(r){if(r===0)return!1;let t=Gn(r);if(r===1){if(!Wn(t,"OES_texture_float")||!Wn(t,"WEBGL_color_buffer_float"))return!1}else{if(Wn(t,"EXT_color_buffer_float"))return RN(t);let n="EXT_color_buffer_half_float";if(Wn(t,n)){let o=t.getExtension(n);return wtt(t,o)}return!1}return RN(t)}function RN(r){let t=og(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,n,o,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),i}function wtt(r,t){let e=og(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,o,s,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function QN(r){return r!==2?!1:Gn(r).fenceSync!=null}function oi(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&y.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Dt=B();Dt.registerFlag("HAS_WEBGL",()=>Dt.getNumber("WEBGL_VERSION")>0);Dt.registerFlag("WEBGL_VERSION",()=>Pw(2)?2:Pw(1)?1:0);Dt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Dt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Dt.get("WEBGL_VERSION")===2);Dt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Dt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Dt.registerFlag("WEBGL_PACK",()=>Dt.getBool("HAS_WEBGL"));Dt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_CLIP",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_REDUCE",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_CONV_IM2COL",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>jN(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>XN(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Dt.getNumber("WEBGL_VERSION");return r===0?0:YN(r)});Dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Dt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ql.isMobile());Dt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>ZN(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Dt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Dt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Dt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>JN(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>QN(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Dt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Dt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Dt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ql.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Dt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Dt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Dt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Dt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Dt.registerFlag("WEBGL_EXP_CONV",()=>!1);Dt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Dt.getBool("IS_TEST"));function He(){let r,t,e,n,o,s,i,a,u,l;return B().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function si(r,t,e="index"){let n=y.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function qc(r,t,e="index"){let n=y.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function Ctt(r,t){let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function uL(r,t,e="index"){let n=r.map((s,i)=>i),o=Ctt(n,t);return o.map((s,i)=>{let a=`int ${r[i]} = ${e} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${e} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function Sd(r){let t=y.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Td(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Lw=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:cL}=S;function pL(r,t,e){let n=[];if(r.forEach(f=>{let d=y.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){let{uniformShape:h}=Mw(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>vtt(f,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=He(),u=Ttt(a),l,c,p=_tt(a);return t.isPacked?(l=Itt(t.logicalShape,i,e.enableShapeUniforms),c=ktt(a)):(l=Stt(t.logicalShape,i,e.enableShapeUniforms),c=Ntt(a)),e.packedInputs&&(p+=Dtt),[p,u,c,o,l,s,e.userCode].join(`
`)}function kd(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return Utt(r,t);case 1:return qtt(r,t);case 2:return jtt(r,t);case 3:return Ytt(r,t);case 4:return Jtt(r,t);case 5:return Qtt(r);case 6:return tet(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function mL(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return Wtt(r);case 1:return Htt(r,t);case 2:return Ktt(r,t);case 3:return Xtt(r,t);default:return Ztt(r,t)}}function vtt(r,t,e=!1,n){let o="";e?o+=mL(r,n):o+=kd(r,n);let s=r.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?o+=eet(r,t):o+=ret(r,t)),o}function Itt(r,t,e){switch(r.length){case 0:return fL();case 1:return Rtt(r,t,e);case 2:return Vtt(r,t,e);case 3:return Ott(r,t,e);default:return Ltt(r,t,e)}}function Stt(r,t,e){switch(r.length){case 0:return fL();case 1:return Ftt(r,t,e);case 2:return Gtt(r,t,e);case 3:return Ptt(r,t,e);case 4:return Mtt(r,t,e);case 5:return ztt(r,t);case 6:return Btt(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function Ttt(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function Ntt(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function ktt(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function _tt(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ett}
    ${Att}
    ${$tt}
  `}var Ett=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Att=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$tt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Dtt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function fL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Rtt(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function Ftt(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Ott(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Ptt(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${qc(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=si(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Ltt(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function Mtt(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${qc(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=si(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function ztt(r,t){let e=si(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Btt(r,t){let e=si(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Vtt(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(y.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function Gtt(r,t,e){return y.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Kc(r){return`offset${r}`}function Wtt(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=He();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function Utt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Kc(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function Htt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=r.shapeInfo.texShape,s=He();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function qtt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${_d(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Kc(e);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function Ktt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=He();if(s!=null&&y.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function jtt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&y.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=y.squeezeShape(e),u=i;if(u.length<e.length){let m=Ed(r,u),f=["row","col"];return`
      ${kd(m,t)}
      float ${o}(int row, int col) {
        return ${o}(${Ad(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${_d(r)}
      }
    `;let l=s[0],c=s[1],p=Kc(n);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function Xtt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let m=e.slice(1),f=[1,2],d=Ed(r,m),h=["b","row","col"];return`
        ${mL(d,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Ad(h,f)});
        }
      `}let a=He();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function Ytt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:u}=y.squeezeShape(e),l=a;if(l.length<e.length){let h=Ed(r,l),g=["row","col","depth"];return`
        ${kd(h,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Ad(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${_d(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=Kc(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${i} + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${d};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function Ztt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=He();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,m*=s[i-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${n}(${f}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${e}, uv);
    }
  `}function Jtt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=y.squeezeShape(e);if(u.length<e.length){let b=Ed(r,u),w=["row","col","depth","depth2"];return`
      ${kd(b,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Ad(w,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${_d(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let x=Kc(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${x});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${x});
      return sampleTexture(${n}, uv);
    }
  `}function Qtt(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=y.squeezeShape(t);if(u.length<t.length){let h=Ed(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${kd(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Ad(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${_d(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;let d=Kc(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function tet(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(t);if(o.length<t.length){let g=Ed(r,o),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${kd(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Ad(x,s)});
      }
    `}let i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${_d(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Kc(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function _d(r){let t=r.name,e=y.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function eet(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=cL(r.shapeInfo.logicalShape,t.logicalShape),u=Wt(i),l=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${p[b+l]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",h=y.sizeFromShape(r.shapeInfo.logicalShape)===1,x=y.sizeFromShape(t.logicalShape)===1;if(s===1&&!h&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!x)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let b=s-2,w=s-1;a.indexOf(b)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function ret(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&y.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let l=Wt(u),c=cL(r.shapeInfo.logicalShape,t.logicalShape),p=u-a,m,f=["x","y","z","w","u","v"];a===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let d="";return u<2&&a>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function Wt(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Mw(r,t,e){let{newShape:n,keptDims:o}=y.squeezeShape(t),s=t.length,i=r&&s===3&&t[0]===1,a=i?t.slice(1):n,u=!r&&s>1&&!y.arraysEqual(t,e)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:t,keptDims:o}}function Ed(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function Ad(r,t){return t.map(e=>r[e]).join(", ")}function hL(r,t,e,n){let o=e.map((c,p)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),s=o.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=pL(o,i,t),u=PN(r.gl,a),l=r.createProgram(u);return B().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},tk(r,t,l))}function tk(r,t,e){let n={},o={},s={},i=[],a,u,l,c=null,p=null;p=r.getUniformLocation(e,"NAN",!1),B().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(e,"INFINITY",!1));let m=!1;for(let f=0;f<t.variableNames.length;f++){let d=t.variableNames[f];n[d]=r.getUniformLocation(e,d,m),n[`offset${d}`]=r.getUniformLocation(e,`offset${d}`,m),t.enableShapeUniforms&&(o[`${d}Shape`]=r.getUniformLocation(e,`${d}Shape`,m),s[`${d}TexShape`]=r.getUniformLocation(e,`${d}TexShape`,m))}return t.enableShapeUniforms&&(a=r.getUniformLocation(e,"outShape",m),l=r.getUniformLocation(e,"outShapeStrides",m),u=r.getUniformLocation(e,"outTexShape",m)),t.customUniforms&&t.customUniforms.forEach((f,d)=>{i[d]=r.getUniformLocation(e,f.name,m)}),{uniformLocations:n,customUniformLocations:i,infLoc:c,nanLoc:p,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}}function dL(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let o=e.logicalShape,s=t[n],i=s.shape;if(!y.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function gL(r,t,e,n,o){t.program.enableShapeUniforms||(dL(t.inShapeInfos,e),dL([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):r.setOutputMatrixTexture(s.texture,i[0],i[1]),r.setProgram(t.webGLProgram),B().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((u,l)=>{let c=t.program.variableNames[l],p=t.uniformLocations[c],m=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],d=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:h}=Mw(t.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(y.sizeFromShape(u.shape)<2)r.gl.uniform1f(p,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(p,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,p,l)}});let a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let u=y.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o&&t.program.customUniforms.forEach((u,l)=>{let c=t.customUniformLocations[l],p=o[l];if(u.type==="float")r.gl.uniform1fv(c,p);else if(u.type==="vec2")r.gl.uniform2fv(c,p);else if(u.type==="vec3")r.gl.uniform3fv(c,p);else if(u.type==="vec4")r.gl.uniform4fv(c,p);else if(u.type==="int")r.gl.uniform1iv(c,p);else if(u.type==="ivec2")r.gl.uniform2iv(c,p);else if(u.type==="ivec3")r.gl.uniform3iv(c,p);else if(u.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function xL(r,t,e){let n="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=Mw(r.packedInputs,i.shape,u),m="",f="",d="";if(c.length===1&&r.packedInputs){let T=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${T[0]>1}_${T[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let T=y.computeStrides(c);d=`${T[0]===u[1]}_${T[T.length-1]===u[1]}`}let h=i.shape.length,g=c.length===2&&y.arraysEqual(i.shape,u),x=y.sizeFromShape(i.shape)===1,b=S.getBroadcastDims(i.shape,e.shape),w=!r.packedInputs&&h===e.shape.length&&y.arraysEqual(u,e.texData.texShape),C=r.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${w}_${l?p:""}_${c.length}_${x}_${b}_${g}_${m}_${f}_${d}_${C}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${B().getNumber("WEBGL_VERSION")}`,s}function ve(r){return B().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var zw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ku.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=He();this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?qc(["r","c","d"],t):si(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var Bw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ku.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=He();this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?qc(["r","c","d"],t):si(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var Vw=class{constructor(t){this.variableNames=["A"],this.outTexUsage=Hr.DOWNLOAD;let e=He();this.outputShape=t,this.userCode=`
      ${Lw}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var Gw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Hr.DOWNLOAD;let e=He();this.outputShape=t,this.userCode=`
      ${Lw}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var Ww=class{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=He();this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Td():Sd(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var Uw=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=He();this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Td():Sd(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var xk={};jt(xk,{bindVertexProgramAttributeStreams:()=>uk,createBufferFromOutputTexture:()=>mk,createFloat16MatrixTexture:()=>sk,createFloat16PackedMatrixTexture:()=>lk,createFloat32MatrixTexture:()=>ok,createIndexBuffer:()=>nk,createPackedMatrixTexture:()=>ak,createUnsignedBytesMatrixTexture:()=>ik,createVertexBuffer:()=>rk,createVertexShader:()=>ek,downloadByteEncodedFloatMatrixFromOutputTexture:()=>dk,downloadFloat32MatrixFromBuffer:()=>fk,downloadMatrixFromPackedOutputTexture:()=>gk,downloadPackedMatrixFromBuffer:()=>hk,getInternalFormatForFloat16MatrixTexture:()=>qw,getInternalFormatForFloat16PackedMatrixTexture:()=>Xw,getInternalFormatForFloat32MatrixTexture:()=>Hw,getInternalFormatForPackedMatrixTexture:()=>jw,getInternalFormatForUnsignedBytesMatrixTexture:()=>Kw,uploadDenseMatrixToTexture:()=>ck,uploadPixelDataToTexture:()=>pk});function ek(r){let t=He(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return ON(r,e)}function rk(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return zN(r,t)}function nk(r){let t=new Uint16Array([0,1,2,2,1,3]);return BN(r,t)}function lg(r,t,e,n,o,s){GN(t,e);let i=VN(r),a=r.TEXTURE_2D;return Ct(r,()=>r.bindTexture(a,i)),Ct(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Ct(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Ct(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),Ct(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),B().getNumber("WEBGL_VERSION")===1?Ct(r,()=>r.texImage2D(a,0,n,t,e,0,o,s,null)):Ct(r,()=>r.texStorage2D(a,1,n,t,e)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function Hw(r){return r.internalFormatFloat}function ok(r,t,e,n){let[o,s]=Hc(t,e);return lg(r,o,s,Hw(n),n.textureFormatFloat,r.FLOAT)}function qw(r){return r.internalFormatHalfFloat}function sk(r,t,e,n){let[o,s]=Hc(t,e);return lg(r,o,s,qw(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function Kw(r){return r.downloadTextureFormat}function ik(r,t,e,n){let[o,s]=Hc(t,e);return lg(r,o,s,Kw(n),r.RGBA,r.UNSIGNED_BYTE)}function jw(r){return r.internalFormatPackedFloat}function ak(r,t,e,n){let[o,s]=ea(t,e);return lg(r,o,s,jw(n),r.RGBA,r.FLOAT)}function Xw(r){return r.internalFormatPackedHalfFloat}function lk(r,t,e,n){let[o,s]=ea(t,e);return lg(r,o,s,Xw(n),r.RGBA,n.textureTypeHalfFloat)}function uk(r,t,e){return Ct(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),Fw(r,t,"clipSpacePos",e,3,20,0)&&Fw(r,t,"uv",e,2,20,12)}function ck(r,t,e,n,o,s){Ct(r,()=>r.bindTexture(r.TEXTURE_2D,t));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(e*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(e*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),B().getNumber("WEBGL_VERSION")===2?Ct(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,n,r.RGBA,a,i)):Ct(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,a,i)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function pk(r,t,e){Ct(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?B().getNumber("WEBGL_VERSION")===2?Ct(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):Ct(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):B().getNumber("WEBGL_VERSION")===2?Ct(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):Ct(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),Ct(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function mk(r,t,e,n){let o=r.createBuffer();Ct(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*t*e;return Ct(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),Ct(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),Ct(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function fk(r,t,e){let n=r,o=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function dk(r,t,e,n){let[o,s]=Hc(t,e),i=4,a=new Uint8Array(nL(t*e,i));return Ct(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function hk(r,t,e,n,o,s,i,a){let u=r,l=new Float32Array(oL(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function gk(r,t,e){let n=new Float32Array(t*e*4);return Ct(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var jc=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=B().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,$N(e,t)):this.gl=Gn(e);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),B().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Cd(this.gl,s),Wn(this.gl,i))this.textureHalfFloatExtension=Cd(this.gl,i);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Wn(this.gl,o))this.colorBufferHalfFloatExtension=Cd(this.gl,o);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Wn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Wn(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=rk(this.gl),this.indexBuffer=nk(this.gl),this.framebuffer=WN(this.gl),this.textureConfig=og(this.gl,this.textureHalfFloatExtension)}get debug(){return B().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;Ct(t,()=>t.finish()),Ct(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Ct(t,()=>t.deleteFramebuffer(this.framebuffer)),Ct(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Ct(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Ct(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),ok(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),sk(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),ik(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),pk(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,o){this.throwIfDisposed(),ck(this.gl,t,e,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),lk(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),ak(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Ow(this.gl,this.framebuffer),this.outputTexture=null),Ct(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>dk(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,o,s,i){return hk(this.gl,t,e,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return fk(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let o=mk(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(B().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>gk(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=ek(e));let n=LN(e);return Ct(e,()=>e.attachShader(n,this.vertexShader)),Ct(e,()=>e.attachShader(n,t)),MN(e,n),this.debug&&sg(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=uk(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&Ct(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&sg(this.gl,this.program),Ct(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?UN(this.gl,t,e):HN(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Ct(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),qN(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[o,s]=ea(e,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&sg(this.gl,this.program),vd(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),Ct(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ct(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Cd(this.gl,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=set(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),ig(this.gl,t,this.framebuffer),this.debug&&vd(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ig(this.gl,this.outputTexture,this.framebuffer),this.debug&&vd(this.gl)):Ow(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let o=this.gl;ig(o,t,this.framebuffer),this.debug&&vd(o),this.outputTexture=t,Ct(o,()=>o.viewport(0,0,e,n)),Ct(o,()=>o.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,o){this.throwIfDisposed(),Ct(this.gl,()=>this.gl.scissor(t,e,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function set(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:yL,bincountImpl:Yw,bincountReduceImpl:bL,castImpl:wL,ceilImpl:CL,concatImpl:vL,equalImpl:IL,expImpl:SL,expm1Impl:TL,floorImpl:NL,gatherNdImpl:kL,gatherV2Impl:_L,greaterImpl:EL,greaterEqualImpl:AL,lessImpl:$L,lessEqualImpl:DL,linSpaceImpl:RL,logImpl:FL,maxImpl:OL,maximumImpl:PL,minimumImpl:LL,multiplyImpl:ML,negImpl:zL,notEqualImpl:BL,prodImpl:VL,raggedTensorToTensorImpl:GL,rangeImpl:WL,rsqrtImpl:UL,scatterImpl:HL,sigmoidImpl:qL,simpleAbsImpl:Zw,sliceImpl:KL,sparseFillEmptyRowsImpl:jL,sparseReshapeImpl:XL,sparseSegmentReductionImpl:Jw,sqrtImpl:YL,stridedSliceImpl:ZL,stringNGramsImpl:JL,stringSplitImpl:QL,stringToHashBucketFastImpl:tM,subImpl:eM,tileImpl:rM,topKImpl:nM,transposeImpl:Xc,uniqueImpl:oM}=Sw;function yk(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function tr(r,t){return t===1?[r]:yk(r,t)}function sM(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var Qw=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ve(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=tr("rc",this.rank),n=Wt(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var $d=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${iet(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Td():Sd(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function iet(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?uL(["r","c","d"],"inputShape"):si(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var tC=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){let o=aM(e,n),s=lM(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=iM(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let a;return o===Fr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Fr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Fr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Fr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Fr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,o){if(this.freeTextures==null)return;let s=aM(n,o),i=lM(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=iM(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=B().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],c=l.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function aet(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function iM(r,t,e,n,o){let s=uet(t,n),i;if(o){let[u,l]=ea(r[0],r[1]);i=u*l}else{let[u,l]=Hc(r[0],r[1]);i=u*l}let a=aet(e,s);return i*a}function uet(r,t){switch(r){case Fr.PACKED_2X2_FLOAT32:return jw(t);case Fr.PACKED_2X2_FLOAT16:return Xw(t);case Fr.UNPACKED_FLOAT32:return Hw(t);case Fr.UNPACKED_FLOAT16:return qw(t);case Fr.PACKED_4X1_UNSIGNED_BYTE:return Kw(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function cet(r){return B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Fr.PACKED_2X2_FLOAT32:Fr.UNPACKED_FLOAT32:r?Fr.PACKED_2X2_FLOAT16:Fr.UNPACKED_FLOAT16}function aM(r,t){if(r===Hr.UPLOAD)return Fr.PACKED_2X2_FLOAT32;if(r===Hr.RENDER||r==null)return cet(t);if(r===Hr.DOWNLOAD||r===Hr.PIXELS)return Fr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function lM(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var Zr=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},fr="if (isnan(x)) return x;",uM="return x;",bk="return abs(x);";var cM="return (x >= 0.0) ? x : (exp(x) - 1.0);",pM=fr+`
  return (x < 0.0) ? 0.0 : x;
`,mM=fr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Yc="return x;",fM="return 1.0 / (1.0 + exp(-1.0 * x));";var hM="return x;",gM=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,xM=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yM=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bM="return 1.0 / (1.0 + exp(-1.0 * x));",ro=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var eC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length);let e=t.length,n=tr("rc",e),o=Wt(e),s=sM(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var met=Vr.whereImpl,fet=1e-7,det=1e-4,rC={};function het(r){return r in rC||(rC[r]={}),rC[r]}var get=B().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),xet=600;function yet(){return B().global.screen==null?1024:B().global.screen.height*B().global.screen.width*window.devicePixelRatio*xet/1024/1024}var Eu=class extends Ho{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!B().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof jc)e=t;else{let n=Gn(B().getNumber("WEBGL_VERSION"),t);e=new jc(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=Gn(B().getNumber("WEBGL_VERSION"));e=new jc(n),this.binaryCache=het(B().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new tC(this.gpgpu),this.numMBBeforeWarning=yet(),this.texData=new ra(this,go())}nextDataId(){return Eu.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((B().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||B().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:e,dtype:n,values:t,usage:Hr.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,n,o,s){if(B().getBool("DEBUG")&&this.checkNumericalProblems(e),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:o,values:e,usage:Hr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let e=this.texData.get(t),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:u}=e;if(i!=null){let m;u?m=new ro(a,Yc):m=new Zr(a,Yc);let f=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(t);if(o==="string")return n;let l=this.activeTimers!=null,c;l&&(c=y.now());let p;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=S.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=y.now()-c),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){let d=this.pendingRead.get(t);return new Promise(h=>d.push(h))}let e=this.texData.get(t),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:u}=e;if(s!=null){let d;u?d=new ro(o,Yc):d=new Zr(o,Yc);let h=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:i}],i),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(t);if(B().getBool("DEBUG")&&!B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&B().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&B().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let d=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(d.texture.texture,...ng(o))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){let d=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=d[0],g=d[1];p=S.mergeRealAndImagArrays(h,g)}else if(l==null)p=this.getValuesFromTexture(t);else{let d=y.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(l,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){let d=this.gpgpu.gl;Ct(d,()=>d.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(t,p),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(d=>d(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&go().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){let n=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,isPacked:u,texture:l}=n;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;u?f=new ro(s,Yc):f=new Zr(s,Yc);let d=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:a}],a),h=this.readToGPU(d,e);return this.disposeIntermediateTensorInfo(d),h}if(l==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,e.customTexShape),p=go().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){let e=this.readSync(t.dataId);if(t.dtype==="string")try{let n=e.map(o=>y.decodeString(o));return vt(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let n=t[e];if(!FN(n))throw B().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:n,isPacked:o}=this.texData.get(t),s=y.sizeFromShape(e);if(B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...ng(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let i=B().getBool("WEBGL_PACK")&&o===!0,a=i?ag(e):e,u=i?new Gw(a):new Vw(a),l=this.runWebGLProgram(u,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let e=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t();let s=y.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=y.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);a.kernelMs=y.sum(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(t){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=y.now(),t)}async getQueryTime(t){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:e,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(t),u=a&&a.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(e,o,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=get){return B().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&y.sizeFromShape(n.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return met(t.shape,e)}packedUnaryOp(t,e,n){let o=new ro(t.shape,e),s=this.compileAndRun(o,[t],n);return go().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let o=Zw(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(B().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,bk,t.dtype);let e=new Zr(t.shape,bk),n=this.compileAndRun(e,[t]);return go().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(i=>y.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:e}}makeOutput(t,e,n){return go().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){let e=new eC(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new Qw(t.shape),n=!0;return this.runWebGLProgram(e,[t],t.dtype,null,n)}packedReshape(t,e){let n=[gl(t.shape),...xl(t.shape)],o={dtype:t.dtype,shape:n,dataId:t.dataId},s=[gl(e),...xl(e)],i=new $d(s,n),a=!0,u=[n],l=this.runWebGLProgram(i,[o],t.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t,e){let n=this.texData.get(t),{isPacked:o,shape:s,dtype:i}=n;if(e!=null){let m=y.sizeFromShape(s),f=e[0]*e[1]*4;y.assert(m<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let a=ag(s),u;o?u=new Bw(a):u=new zw(a);let l=!0,c=[e!=null?e:ng(a)],p=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:t}],i,c,l,e);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,e,n,o,s=!1,i){let a=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(a.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===ku.DENSE){let x=i!=null?i:ng(t.outputShape);u.texShape=x.map(b=>b*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),y.sizeFromShape(a.shape)===0)return u.values=y.getTypedArrayFromDType(a.dtype,0),a;let l=[],c=e.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(x.dataId);if(b.texture==null){if(!t.packedInputs&&y.sizeFromShape(x.shape)<=B().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!b.isPacked!=!!t.packedInputs)x=b.isPacked?this.unpackTensor(x):this.packTensor(x),l.push(x),b=this.texData.get(x.dataId);else if(b.isPacked&&!_u(b.shape,x.shape)){let w=x,C=x.shape;x.shape=b.shape,x=this.packedReshape(x,C),l.push(x),b=this.texData.get(x.dataId),w.shape=C}return{shape:x.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:u,isUniform:!1},m=xL(t,c,p),f=this.getAndSaveBinary(m,()=>hL(this.gpgpu,t,c,p)),d=this.activeTimers!=null,h;d&&(h=this.startTimer()),B().get("ENGINE_COMPILE_ONLY")||gL(this.gpgpu,f,c,p,o),l.forEach(x=>this.disposeIntermediateTensorInfo(x)),d&&(h=this.endTimer(h),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(h)}));let g=B().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let x=y.now();x-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!B().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let x=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),x}return a}compileAndRun(t,e,n,o,s=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,o,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(B().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=G(()=>{if(!B().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=B().getBool("DEBUG");B().set("DEBUG",!1);let e=this.abs(mt(1e-8)).dataSync()[0];if(B().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?fet:det}uploadToGPU(t){let e=this.texData.get(t),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:u}=e;if(i!=null)return;let l=this.activeTimers!=null,c;l&&(c=y.now());let p=e.texShape;if(p==null&&(p=KN(n,u),e.texShape=p),s!=null){let m=ag(n),f,d=p[1],h=p[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([d,h]=ea(p[0],p[1])),u?f=new Uw(m,g):f=new Ww(m,g);let x=g?[h,d]:p,b=this.makeTensorInfo(x,o),w=this.texData.get(b.dataId);g?w.usage=Hr.PIXELS:w.usage=Hr.UPLOAD,w.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),d,h,s);let C=[[h,d]],T=!0,E=this.runWebGLProgram(f,[b],o,C,T),$=this.texData.get(E.dataId);e.texShape=$.texShape,e.isPacked=$.isPacked,e.usage=$.usage,B().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(e.texture=$.texture,e.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(b),l&&(this.uploadWaitMs+=y.now()-c)}else{let m=this.acquireTexture(p,a,o,u);e.texture=m}}convertAndCacheOnCPU(t,e){let n=this.texData.get(t),{dtype:o}=n;return this.releaseGPUData(t),e!=null&&(n.values=bet(e,o)),n.values}acquireTexture(t,e,n,o){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,o)}computeBytes(t,e){return t[0]*t[1]*y.bytesPerElement(e)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(let[,e]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(e),o(!0)}catch(s){throw s}});t.push(n)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Th(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Rw(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,t]of Object.entries(this.binaryCache)){let{uniformLocations:e,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:c}=tk(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=n,t.infLoc=o,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=u,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}};Eu.nextDataId=0;function bet(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}var wM="3.20.0";function CM(){B().set("WEBGL_FORCE_F16_TEXTURES",!0)}ql.isBrowser()&&lm("webgl",()=>new Eu,2);var ike={forceHalfFloat:CM};var nC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var no=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=ve(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Au=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Fo=class{constructor(t,e,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(e,n);let s=this.outputShape.length;this.enableShapeUniforms=ve(s);let i="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Wt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=tr("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function er(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var vM={kernelName:uo,backendName:"webgl",kernelFunc:er};function An(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),i=e.texData.get(s.dataId),a=er({inputs:{x:n},backend:e}),u=er({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:u},s}var IM={kernelName:Np,backendName:"webgl",kernelFunc:An};var wk="return (a < 0.) ? b * a : a;",Ck=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function wet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,i=e.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),a=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo(Ck,o.shape,i.shape):new no(wk,o.shape,i.shape),u=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),u}var SM={kernelName:ms,backendName:"webgl",kernelFunc:wet};var vk="return (a < 0.) ? b * a : a;",Ik=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Cet(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo(Ik,n.shape,o.shape):new no(vk,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],"float32")}var TM={kernelName:Ts,backendName:"webgl",kernelFunc:Cet};var Oo="if (isnan(x)) return x;",NM=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,kM=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function It({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),m=e(p.values,u);return a.makeTensorInfo(i.shape,u,m)}let l=B().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return l?c=new ro(i.shape,t):c=new Zr(i.shape,r),a.runWebGLProgram(c,[i],u)}}function ce({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,c=a;if(n&&u.dtype==="complex64"){let d=c.texData.get(u.dataId),h=c.texData.get(l.dataId),[g,x]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[C,T]=w,E={dataId:C.dataId,dtype:C.dtype,shape:u.shape},$={dataId:T.dataId,dtype:T.dtype,shape:l.shape},D=new no(r,u.shape,l.shape);return c.runWebGLProgram(D,[E,$],ir(C.dtype,T.dtype))}),b=An({inputs:{real:g,imag:x},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(x),b}let p=s||ir(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&o!=null){let d=c.texData.get(u.dataId).values,h=c.texData.get(l.dataId).values,g=u.dtype==="string"?S.fromUint8ToStringArray(d):d,x=u.dtype==="string"?S.fromUint8ToStringArray(h):h,[b,w]=o(u.shape,l.shape,g,x,p),C=c.makeTensorInfo(w,p),T=c.texData.get(C.dataId);return T.values=b,C}let m=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return m?f=new Fo(t,u.shape,l.shape,e):f=new no(r,u.shape,l.shape),c.runWebGLProgram(f,[u,l],p)}}function yl(r,t=!1){if(r==="linear")return t?hM:uM;if(r==="relu")return t?xM:pM;if(r==="elu")return t?gM:cM;if(r==="relu6")return t?yM:mM;if(r==="prelu")return t?Ik:vk;if(r==="leakyrelu")return t?Ck:wk;if(r==="sigmoid")return t?bM:fM;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Dd=class{constructor(t,e,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ve(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");let b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",C="rc.x";t[0]<e[0]?w=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(C=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${w};
          int batchB = ${C};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${x}

        setOutput(result);
      }
    `}};var Sk={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},ug=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var _M="return a * b;";function cg(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=S.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),l=new ug(Sk.REAL,n.shape,o.shape),c=new ug(Sk.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=An({inputs:{real:m,imag:f},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}if(e.shouldExecuteOnCPU([n,o])){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),[l,c]=ML(n.shape,o.shape,a.values,u.values,s),p=e.makeTensorInfo(c,s),m=e.texData.get(p.dataId);return m.values=l,p}let i;return B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Fo(_M,n.shape,o.shape):i=new no(_M,n.shape,o.shape),e.runWebGLProgram(i,[n,o],s)}var EM={kernelName:Cs,backendName:"webgl",kernelFunc:cg};function AM(r,t,e){let n=[gl(r.shape),...xl(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[gl(t),...xl(t)],i=new $d(s,n),a=!0,u=[n],l=e.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function lt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=e,a=y.sizeFromShape(o.shape),u=y.inferFromImplicitShape(s,a),l=y.sizeFromShape(u);y.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!_u(o.shape,u)&&!(c.texture!==null&&_u(c.shape,u))?AM(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var $M={kernelName:bi,backendName:"webgl",kernelFunc:lt};var pg=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(e!=null){let p=1/e;l=`sumValue += dot(values * ${y.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var oC=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",u="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",u="min"):e==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,p=n%4,m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";e==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):e==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Iet(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=S.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Un(r,t,e,n){let o=Iet(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],c,p;e==="mean"?c=i===0?new pg({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new pg({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):c=new oC({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},e),p=s,s=n.runWebGLProgram(c,[s],t),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var sC=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;let o=Wt(this.rank),s=Tet(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Tet(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<r.length;o++)n[r[o]]=e[o];return n.join()}var iC=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Wt(this.rank),s=yk("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function $u(r,t,e){let n=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iC(r.shape,t):new sC(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function DM(r,t,e,n){let o=t,s=r.shape.length,i=y.parseAxisParam(o,r.shape),a=i,u=S.getAxesPermutation(a,s),l=u!=null,c=r;l&&(c=$u(r,u,n),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,m]=S.computeOutAndReduceShapes(c.shape,a),f=p;e&&(f=S.expandShapeToKeepDim(p,i));let d=y.sizeFromShape(m),g=y.sizeFromShape(r.shape)/d,x=lt({inputs:{x:c},attrs:{shape:[g,d]},backend:n}),b=Xu(r.dtype),w=Un(x,b,"sum",n),C=lt({inputs:{x:w},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),l&&n.disposeIntermediateTensorInfo(c),C}function Zc(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return DM(o,s,i,e)}var RM={kernelName:Ls,backendName:"webgl",kernelFunc:Zc};function Le(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,i=e,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,m=Xc(p,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let f=i.texData.get(l.dataId);f.values=m}else l=$u(o,s,i);return l}var FM={kernelName:Yn,backendName:"webgl",kernelFunc:Le};var Tk=1e3;function Jc({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=t.shape.length,p=e?r.shape[l-2]:r.shape[l-1],m=n?t.shape[c-1]:t.shape[c-2],f=e?r.shape[l-1]:r.shape[l-2],d=n?t.shape[c-2]:t.shape[c-1],h=r.shape.slice(0,-2),g=t.shape.slice(0,-2),x=y.sizeFromShape(h),b=y.sizeFromShape(g),C=Lr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,d]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let T=e?[x,p,f]:[x,f,p],E=n?[b,d,m]:[b,m,d],$=lt({inputs:{x:r},backend:o,attrs:{shape:T}}),D=lt({inputs:{x:t},backend:o,attrs:{shape:E}}),P=[$,D],M=Math.max(x,b),W=e?$.shape[1]:$.shape[2],H=s!=null,q=i!=null,X=u==="leakyrelu",j=u!=null?yl(u,!0):null,Z=H||q||X||j!=null,et;if((f===1||d===1)&&W>Tk&&Z===!1){let ot=$,st=D;e&&(ot=Le({inputs:{x:$},backend:o,attrs:{perm:[0,2,1]}}),P.push(ot)),n&&(st=Le({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),P.push(st));let it=d!==1,pt=d===1,at=ot;it&&(at=lt({inputs:{x:ot},backend:o,attrs:{shape:[M,W,1]}}),P.push(at));let gt=d===1?2:1,dt=st;pt&&(dt=lt({inputs:{x:st},backend:o,attrs:{shape:[M,1,W]}}),P.push(dt));let bt=cg({inputs:{a:at,b:dt},backend:o});et=Zc({inputs:{x:bt},backend:o,attrs:{axis:gt,keepDims:!0}}),P.push(bt)}else{let ot=ir(r.dtype,t.dtype),st=new Dd(T,E,[M,f,d],e,n,H,j,q,X),it=[$,D];if(s!=null&&it.push(s),q&&it.push(i),X){let pt=o.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));it.push(pt),P.push(pt)}et=o.runWebGLProgram(st,it,ot)}let K=lt({inputs:{x:et},backend:o,attrs:{shape:C}});P.push(et);for(let ot of P)o.disposeIntermediateTensorInfo(ot);return K}function Net(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return Jc({a:o,b:s,transposeA:u,transposeB:l,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var OM={kernelName:Ni,backendName:"webgl",kernelFunc:Net};var PM="return abs(x);";function ket(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=e.texData.get(n.dataId),i=Zw(s.values);return e.makeTensorInfo(n.shape,n.dtype,i)}let o;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new ro(n.shape,PM):o=new Zr(n.shape,PM),e.runWebGLProgram(o,[n],n.dtype)}var LM={kernelName:pi,backendName:"webgl",kernelFunc:ket};var _et=fr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Eet=It({opSnippet:_et}),MM={kernelName:oa,backendName:"webgl",kernelFunc:Eet};var Aet=fr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,$et=It({opSnippet:Aet}),zM={kernelName:sa,backendName:"webgl",kernelFunc:$et};var BM="return a + b;",Det=ce({opSnippet:BM,packedOpSnippet:BM,supportsComplex:!0,cpuKernelImpl:yL}),VM={kernelName:jn,backendName:"webgl",kernelFunc:Det};var aC=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var lC=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function uC(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return er({inputs:{x:n[0]},backend:e});if(n.length>B().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=uC({inputs:n.slice(0,u),backend:e}),c=uC({inputs:n.slice(u),backend:e});return uC({inputs:[l,c],backend:e})}let o=n.map(u=>u.dtype).reduce((u,l)=>ir(u,l)),s=n.map(u=>u.shape),a=B().getBool("WEBGL_PACK")?new lC(n[0].shape,s):new aC(n[0].shape,s);return e.runWebGLProgram(a,n,o)}var GM={kernelName:jo,backendName:"webgl",kernelFunc:uC};function Ret(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Le({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("all",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=y.sizeFromShape(f),h=lt({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Un(h,h.dtype,"all",e),x;if(i){let b=S.expandShapeToKeepDim(m,u);x=lt({inputs:{x:g},backend:e,attrs:{shape:b}})}else x=lt({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),x}var WM={kernelName:ia,backendName:"webgl",kernelFunc:Ret};function Fet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Le({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("any",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=y.sizeFromShape(f),h=lt({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Un(h,h.dtype,"any",e),x;if(i){let b=S.expandShapeToKeepDim(m,u);x=lt({inputs:{x:g},backend:e,attrs:{shape:b}})}else x=lt({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),x}var UM={kernelName:aa,backendName:"webgl",kernelFunc:Fet};var cC=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var pC=class{constructor(t,e,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=Wt(u),c=tr("coords",u),p,m;if(i===1){m=u+1;let D=Wt(m);p=`
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[u-1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[u-2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[u-1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[u-2]};`}else m=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(D=>"int "+D),g=tr("sourceLocR",m-1).concat("inIdx.r"),x=tr("sourceLocG",m-1).concat("inIdx.g"),b=tr("sourceLocB",m-1).concat("inIdx.b"),w=tr("sourceLocA",m-1).concat("inIdx.a"),C=n==="max"?"greaterThan":"lessThan",T=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()})));`,E=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,$=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${T}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function HM(r,t,e,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new cC(a,e,n==null),l=[t];n!=null&&l.push(n);let c=r.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let p=HM(r,t,e,c);return r.disposeIntermediateTensorInfo(c),p}function qM(r,t,e,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new pC(o,i,e,n==null),u=n==null?[t]:[t,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===t.shape.length){let c=qM(r,t,e,l);return r.disposeIntermediateTensorInfo(l),c}return l}function mC(r,t,e,n){let o=[e];if(S.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!B().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=r.texData.get(t.dataId),a=i!==null&&i.isPacked,u=t;a&&(u=r.unpackTensor(t),s.push(u));let[l,c]=S.computeOutAndReduceShapes(u.shape,o),p=y.sizeFromShape(c),m=lt({inputs:{x:u},backend:r,attrs:{shape:[-1,p]}});s.push(m);let f=HM(r,m,n);s.push(f);let d=lt({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return qM(r,t,n)}function Oet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Le({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=mC(e,u,i[0],"max");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var KM={kernelName:Xo,backendName:"webgl",kernelFunc:Oet};function Pet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Le({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=mC(e,u,i[0],"min");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var jM={kernelName:Nl,backendName:"webgl",kernelFunc:Pet};var Let=fr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Met=It({opSnippet:Let}),XM={kernelName:la,backendName:"webgl",kernelFunc:Met};var zet=fr+"return log(x + sqrt(x * x + 1.0));",Bet=It({opSnippet:zet}),YM={kernelName:ua,backendName:"webgl",kernelFunc:Bet};var Vet=fr+`
  return atan(x);
`,Get=It({opSnippet:Vet}),ZM={kernelName:ca,backendName:"webgl",kernelFunc:Get};var Wet=NM+`
  return atan(a, b);
`,Uet=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+kM+`
  return result;
`,Het=ce({opSnippet:Wet,packedOpSnippet:Uet}),JM={kernelName:ma,backendName:"webgl",kernelFunc:Het};var qet=fr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Ket=It({opSnippet:qet}),QM={kernelName:pa,backendName:"webgl",kernelFunc:Ket};var ii=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,f=t.padInfo.top,d=t.padInfo.left;this.outputShape=t.outShape;let h=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,x=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,b="0.0";if(h||(b="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:x:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(C="avgValue / count");let T=Math.floor(i/4)*4,E=i%4,$=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${T}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${T};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${C});
      }
    `}},Du=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,u=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,f=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,g=t.padInfo.front,x=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;let w=e==="avg",C="0.0";if(w||(C="-1.0 / 1e-20"),n){let M=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${x}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${M} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let T="max",E=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(E="avgValue / count");let $=Math.floor(i/4)*4,D=i%4,P=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${x}, ${b});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${P}
            }

            int xC = xCCorner + ${$};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${P}
            }
          }
          setOutput(${E});
        }
      }
    `}};function jet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;oi(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))return er({inputs:{x:o},backend:e});let p=new ii(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var tz={kernelName:Yo,backendName:"webgl",kernelFunc:jet};function Xet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,u,l),m=new Du(p,"avg",!1);return e.runWebGLProgram(m,[o],"float32")}var ez={kernelName:kl,backendName:"webgl",kernelFunc:Xet};var fC=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=u-1-t.padInfo.top,p=l-1-t.padInfo.left,m=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},dC=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=p-1-t.padInfo.front,h=m-1-t.padInfo.top,g=f-1-t.padInfo.left,x=1/(e*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Yet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new dC(m);return e.runWebGLProgram(f,[o],i.dtype)}var rz={kernelName:Ip,backendName:"webgl",kernelFunc:Yet};function Zet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;oi([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=new fC(c);return e.runWebGLProgram(p,[o],i.dtype)}var nz={kernelName:vp,backendName:"webgl",kernelFunc:Zet};function Jet(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return Jc({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var oz={kernelName:Zo,backendName:"webgl",kernelFunc:Jet};var hC=class{constructor(t,e,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var gC=class{constructor(t,e,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Qet=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let l=[n,o,s],c=null;i!=null&&(c=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let m=B().getBool("WEBGL_PACK_NORMALIZATION")?new gC(n.shape,o.shape,s.shape,c,p,u):new hC(n.shape,o.shape,s.shape,c,p,u);return t.runWebGLProgram(m,l,l[0].dtype)},sz={kernelName:cs,backendName:"webgl",kernelFunc:Qet};var xC=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=Wt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=trt(this.rank),o,s=t.map((i,a)=>`sourceLoc.${Nk[a]} = start[${a}] + coords.${Nk[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},Nk=["x","y","z","w","u","v"];function trt(r){if(r===1)return"sourceLoc";if(r<=6)return Nk.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var yC=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Wt(this.rank),n=tr("coords",this.rank),o=tr("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function ert(r,t,e,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(e,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=r.dtype;let a=Be.computeFlatOffset(t,y.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function ai(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n,[a,u]=Be.parseSliceParams(o,s,i);if(Be.assertParamsValid(o,a,u),y.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),m=KL(p.values,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=e.texData.get(o.dataId),c=Be.isSliceContinous(o.shape,a,u);if(l||!c){let p=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yC(u):new xC(u),m=[a];return e.runWebGLProgram(p,[o],o.dtype,m)}return e.uploadToGPU(o.dataId),ert(o,a,u,e)}var iz={kernelName:Ci,backendName:"webgl",kernelFunc:ai};var rrt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((b,w)=>b*w),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=[],d=lt({inputs:{x:o},backend:e,attrs:{shape:u}}),h=Le({inputs:{x:d},backend:e,attrs:{perm:l}}),g=lt({inputs:{x:h},backend:e,attrs:{shape:c}}),x=ai({inputs:{x:g},backend:e,attrs:{begin:p,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),x},az={kernelName:mi,backendName:"webgl",kernelFunc:rrt};function nrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.readSync(o.dataId),u=e.readSync(s.dataId),l=Yw(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var lz={kernelName:Sp,backendName:"webgl",kernelFunc:nrt};function ort(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.readSync(n.dataId),i=e.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var uz={kernelName:Tp,backendName:"webgl",kernelFunc:ort};var srt="return float(a != b);",kk=ce({opSnippet:srt,cpuKernelImpl:BL,dtype:"bool"}),cz={kernelName:Da,backendName:"webgl",kernelFunc:kk};function bl(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return er({inputs:{x:o.complexTensorInfos.real},backend:e})}var pz={kernelName:qp,backendName:"webgl",kernelFunc:bl};var irt="return float(int(x));";function mz(r,t){let e=new Zr(r.shape,irt),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function _k(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return er({inputs:{x:o},backend:e});let i=_e(o.shape),a=_k({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=An({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=bl({inputs:{input:o},backend:e}),a=_k({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!y.hasEncodingLoss(o.dtype,s)){let i=er({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let i=e.texData.get(o.dataId).values,[a,u,l]=wL(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,u,l)}if(s==="int32")return mz(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=kk({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var fz={kernelName:ao,backendName:"webgl",kernelFunc:_k};var dz="return ceil(x);",art=It({opSnippet:dz,packedOpSnippet:dz,cpuKernelImpl:CL}),hz={kernelName:Jo,backendName:"webgl",kernelFunc:art};var bC=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var wC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function lrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a;B().getBool("WEBGL_PACK_CLIP")?a=new wC(o.shape):a=new bC(o.shape);let u=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,u)}var gz={kernelName:lo,backendName:"webgl",kernelFunc:lrt};var CC=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function xz(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function urt(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.texData.get(n.dataId),s=new CC(n.shape),i=[xz(n,o.complexTensorInfos.real),xz(n,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var yz={kernelName:_l,backendName:"webgl",kernelFunc:urt};var vC=class{constructor(t){this.outputShape=[],this.outputShape=S.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var SC=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(t,e);let n=this.outputShape,o=n.length,s=Wt(o),i=tr("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((h,g)=>`T${g}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let h=1;h<u.length;h++)u[h]=u[h-1]+t[h][e];let l=a[e],c=a.slice(-2),p=a.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${IC(a,l,g)}),
            vec2(${IC(c,l,g)}));
        }`}let f=u.length,d=u[u.length-1];m+=`
        return getChannel(
          getT${f}(${IC(a,l,d)}),
          vec2(${IC(c,l,d)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function IC(r,t,e){let n=r.indexOf(t);return r.map((s,i)=>i===n?`${s} - ${e}`:s).join()}function Qc(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return er({inputs:{x:o.complexTensorInfos.imag},backend:e})}var bz={kernelName:Mp,backendName:"webgl",kernelFunc:Qc};function Rd(r,t,e){let n=r[0].dtype;if(n==="complex64"){let p=r.map(g=>bl({inputs:{input:g},backend:e})),m=r.map(g=>Qc({inputs:{input:g},backend:e})),f=Rd(p,t,e),d=Rd(m,t,e),h=An({inputs:{real:f,imag:d},backend:e});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),m.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let p=r.map(b=>{let w=y.sizeFromShape(b.shape.slice(t));return lt({inputs:{x:b},backend:e,attrs:{shape:[-1,w]}})}),m=p.map(b=>({vals:e.readSync(b.dataId),shape:b.shape})),f=S.computeOutShape(p.map(b=>b.shape),1),d=p[0].shape[0]===1,h=vL(m,f,n,d),g=S.computeOutShape(r.map(b=>b.shape),t),x=e.makeTensorInfo(g,n,h);return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}let s=B().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>s){let p=[];for(let f=0;f<r.length;f+=s){let d=r.slice(f,f+s);p.push(Rd(d,t,e))}let m=Rd(p,t,e);for(let f of p)e.disposeIntermediateTensorInfo(f);return m}if(B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let p=new SC(r.map(m=>m.shape),t);return e.runWebGLProgram(p,r,n)}let{tensors2D:i,outShape:a}=crt(r,t,e),u=new vC(i.map(p=>p.shape)),l=e.runWebGLProgram(u,i,n);i.forEach(p=>e.disposeIntermediateTensorInfo(p));let c=lt({inputs:{x:l},attrs:{shape:a},backend:e});return e.disposeIntermediateTensorInfo(l),c}function crt(r,t,e){let n=S.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>lt({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:n}}function Ek(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(l=>l.shape),s);if(y.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(l=>y.sizeFromShape(l.shape)>0);if(a.length===1)return er({inputs:{x:a[0]},backend:e});let u=a.map(l=>l.shape);return S.assertParamsConsistent(u,s),Rd(a,s,e)}var wz={kernelName:fi,backendName:"webgl",kernelFunc:Ek};var Fd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,u=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4,g=t.dataFormat==="channelsLast",x=g?1:2,b=g?2:3,w=g?3:1,C="",T="";n&&(o?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:C=`
          float activation(float x) {
            ${n}
          }
        `,T="result = activation(result);");let E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${T}
        setOutput(result);
      }
    `}},TC=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Od=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ve(this.outputShape.length);let i=t.padInfo.left,a=t.strideWidth,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,p=c,m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)m+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;m+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)m+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){let x=g*2;if(m+=`
           xC = xCCorner + ${x*u};
           `,a===1){if(x<c&&(i%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,u===1&&x>0?m+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<c)){let b=i%2===0?y.nearestLargerEven(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,u>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:m+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):b===1?m+=`
                     xC${x+1} = xTexelC${x};
                     `:m+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<c&&(i%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<c&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<c&&(m+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<c&&(m+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<c&&(m+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let f="",d="";n&&(o?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:f=`vec4 activation(vec4 x) {
           ${n}
         }`,d="result = activation(result);");let h=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${d}
         setOutput(result);
       }
     `}};var NC=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ve(this.outputShape.length);let{dataFormat:n}=e,o=He(),s=n==="channelsLast",i=s?1:2,a=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function kC(r,t){let e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function _C({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),c=e.inChannels,p=u[0]*u[1]*u[2],m=e.outChannels,f=e.dataFormat==="channelsLast",d=!1,h=!1,g,x=[];if(s!=null){let C=kC(s.shape,f);C!=null&&(s=lt({inputs:{x:s},backend:n,attrs:{shape:C}}),x.push(s))}if(o!=null){let C=kC(o.shape,f);C!=null&&(o=lt({inputs:{x:o},backend:n,attrs:{shape:C}}),x.push(o))}if(!((p===1||m===1)&&c>Tk)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!==0&&y.arraysEqual(l.shape.slice(-3),u.slice(-3))){let C=u[0]*u[1]*(u[2]+1),T={dataId:r.dataId,shape:[1,C,e.inChannels],dtype:r.dtype},E=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,y.assert(_u(l.shape,T.shape),()=>`packed reshape ${l.shape} to ${T.shape} isn't free`);let $=lt({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});x.push($);let D=Jc({a:T,b:$,backend:n,transposeA:d,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),P=n.texData.get(D.dataId);y.assert(P.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=E,P.shape=e.outShape,g=er({inputs:{x:D},backend:n}),g.shape=e.outShape,x.push(D)}else{let C=e.outHeight*e.outWidth,T=lt({inputs:{x:r},backend:n,attrs:{shape:f?[e.batchSize,C,e.inChannels]:[e.batchSize,e.inChannels,C]}}),E=lt({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),$=Jc({a:f?T:E,b:f?E:T,transposeA:!f,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=lt({inputs:{x:$},backend:n,attrs:{shape:e.outShape}}),x.push(T),x.push(E),x.push($)}for(let C of x)n.disposeIntermediateTensorInfo(C);return g}function EC({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=e,d=f==="channelsLast",h=u*l*c,g=m*p,x=[e.batchSize,h,g],b=!0,w=!1,C=[];if(s!=null){let K=kC(s.shape,d);K!=null&&(s=lt({inputs:{x:s},backend:n,attrs:{shape:K}}),C.push(s))}if(o!=null){let K=kC(o.shape,d);K!=null&&(o=lt({inputs:{x:o},backend:n,attrs:{shape:K}}),C.push(o))}let T=lt({inputs:{x:t},backend:n,attrs:{shape:[1,h,y.sizeFromShape(t.shape)/h]}});C.push(T);let E=new NC(x,e),$=[r.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],D=n.runWebGLProgram(E,[r],"float32",$),P=lt({inputs:{x:D},backend:n,attrs:{shape:x}});C.push(D),C.push(P);let M=o!=null,W=s!=null,H=a==="leakyrelu",q=a?yl(a,!0):null,X=new Dd(d?P.shape:T.shape,d?T.shape:P.shape,d?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],b,w,M,q,W,H),j=d?[P,T]:[T,P];if(o&&j.push(o),W&&j.push(s),H){let K=n.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));j.push(K),C.push(K)}let Z=n.runWebGLProgram(X,j,"float32"),et=lt({inputs:{x:Z},backend:n,attrs:{shape:e.outShape}});C.push(Z);for(let K of C)n.disposeIntermediateTensorInfo(K);return et}function prt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=_C({x:o,filter:s,convInfo:m,backend:e});else if(m.strideWidth<=2&&p==="channelsLast"&&B().getBool("WEBGL_EXP_CONV")){let h=new Od(m),g=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];f=e.runWebGLProgram(h,[o,s],"float32",g)}else if(B().getBool("WEBGL_CONV_IM2COL"))f=EC({x:o,filter:s,convInfo:m,backend:e});else{let h=new Fd(m);f=e.runWebGLProgram(h,[o,s],"float32")}let d=lt({inputs:{x:f},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(f),d}var Cz={kernelName:Qo,backendName:"webgl",kernelFunc:prt};var AC=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},$C=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,u=n-1-t.padInfo.left,l=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},DC=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},RC=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function mrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new AC(m);return e.runWebGLProgram(f,[o,s],"float32")}var vz={kernelName:kp,backendName:"webgl",kernelFunc:mrt};function frt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p),f=new $C(m);return e.runWebGLProgram(f,[o,s],"float32")}var Iz={kernelName:ts,backendName:"webgl",kernelFunc:frt};function drt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),c=new TC(l);return e.runWebGLProgram(c,[o,s],"float32")}var Sz={kernelName:El,backendName:"webgl",kernelFunc:drt};function hrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n,l=S.computeConv3DInfo(o.shape,u,i,1,a),c=new DC(l);return e.runWebGLProgram(c,[o,s],"float32")}var Tz={kernelName:_p,backendName:"webgl",kernelFunc:hrt};function grt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n,l=S.computeConv3DInfo(u,s.shape,a,1,i),c=new RC(l);return e.runWebGLProgram(c,[o,s],"float32")}var Nz={kernelName:Ep,backendName:"webgl",kernelFunc:grt};var xrt=Oo+`
  return cos(x);
`,yrt=It({opSnippet:xrt}),kz={kernelName:es,backendName:"webgl",kernelFunc:yrt};var brt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,wrt=It({opSnippet:brt}),_z={kernelName:rs,backendName:"webgl",kernelFunc:wrt};var FC=class{constructor(t,e,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,u,l]=t,[c]=e,[p,m]=n;this.outputShape=[c,p,m,l];let f=o==="bilinear"?1:0,[d,h]=[`${a-1}.0`,`${u-1}.0`],[g,x,b]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[w,C,T]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${C};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${T};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Crt=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,c=new FC(o.shape,s.shape,a,u,l);return e.runWebGLProgram(c,[o,s,i],"float32")},Ez={kernelName:da,backendName:"webgl",kernelFunc:Crt};var tp;(function(r){r.Prod="*",r.Sum="+"})(tp||(tp={}));var mg=class{constructor(t,e,n,o){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===tp.Prod?"1.0":"0.0",a=n?i:`getX(${Az(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],l="",c="";n?(l=o?`end != ${u-1}`:"end != 0",c=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${u}`:"end >= pow2",c=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Wt(s)} coords = getOutputCoords();
        int end = ${$z(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${$z(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${Az(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function Az(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function $z(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function OC(r,t,e,n,o,s){let i=t.shape.length,a=S.getAxesPermutation([n],i),u=t;a!=null&&(u=Le({inputs:{x:t},backend:e,attrs:{perm:a}}));let l=S.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let c=u.shape[l],p=er({inputs:{x:u},backend:e});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let f=new mg(r,u.shape,!1,s),d=[[m]],h=p;p=e.runWebGLProgram(f,[p],p.dtype,d),e.disposeIntermediateTensorInfo(h)}if(o){let m=new mg(r,u.shape,o,s),f=p;p=e.runWebGLProgram(m,[p],p.dtype),e.disposeIntermediateTensorInfo(f)}if(a!=null){let m=S.getUndoAxesPermutation(a),f=Le({inputs:{x:p},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),f}return p}function vrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return OC(tp.Prod,o,e,s,i,a)}var Dz={kernelName:fa,backendName:"webgl",kernelFunc:vrt};function Irt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return OC(tp.Sum,o,e,s,i,a)}var Rz={kernelName:ns,backendName:"webgl",kernelFunc:Irt};function Srt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=Yw(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=bL(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Fz={kernelName:Ap,backendName:"webgl",kernelFunc:Srt};var PC=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Trt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=new PC(d,s,i);return e.runWebGLProgram(h,[o],o.dtype)}var Oz={kernelName:ha,backendName:"webgl",kernelFunc:Trt};var Pd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ve(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,u=t.outChannels/t.inChannels,l="",c="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var Ld=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ve(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,m=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<p;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let x=0;x<p;x++)f+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(m+1)/2;x++){let b=x*2;if(f+=`
          xC = xCCorner + ${b*l};
          `,u===1){if(b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<p)){let w=a%2===0?y.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:f+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):w===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<p&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<p&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<p&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function Nrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,c=u;c==null&&(c=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,c,a,l,!0),m;B().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new Ld(p):m=new Pd(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[o,s],"float32",f)}var Pz={kernelName:os,backendName:"webgl",kernelFunc:Nrt};var LC=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},MC=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function krt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),m=new LC(p);return e.runWebGLProgram(m,[o,s],"float32")}var Lz={kernelName:$p,backendName:"webgl",kernelFunc:krt};function _rt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),m=new MC(p);return e.runWebGLProgram(m,[o,s],"float32")}var Mz={kernelName:Dp,backendName:"webgl",kernelFunc:_rt};var zC=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Ert(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=y.sizeFromShape(n.shape),i=lt({inputs:{x:n},backend:e,attrs:{shape:[s]}}),a=new zC(s),u=e.runWebGLProgram(a,[i],i.dtype),l=lt({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}var zz={kernelName:Rp,backendName:"webgl",kernelFunc:Ert};var BC=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=t,{top:p,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Art(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c,p=new BC(l);c=e.runWebGLProgram(p,[o,s],"float32");let m=lt({inputs:{x:c},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(c),m}var Bz={kernelName:Al,backendName:"webgl",kernelFunc:Art};function $rt(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:x,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=Le({inputs:{x:s[g]},backend:e,attrs:{perm:x}}),d.push(w));let C=w.shape.slice();for(let T=0;T<b.length;++T)C.splice(b[T],0,1);y.arraysEqual(w.shape,C)||(w=lt({inputs:{x:w},backend:e,attrs:{shape:C}}),d.push(w)),m===null?m=w:(m=cg({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=Zc({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var Vz={kernelName:Fp,backendName:"webgl",kernelFunc:$rt};var Drt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Rrt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Frt=It({opSnippet:Drt,packedOpSnippet:Rrt}),Gz={kernelName:is,backendName:"webgl",kernelFunc:Frt};var Ort="return (b >= 1.0) ? a : a * (b + 1.0);",Prt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Lrt=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo(Prt,n.shape,o.shape):new no(Ort,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],n.dtype)},Wz={kernelName:Op,backendName:"webgl",kernelFunc:Lrt};var Mrt=`
  return vec4(equal(a, b));
`,zrt="return float(a == b);",Brt=ce({opSnippet:zrt,packedOpSnippet:Mrt,dtype:"bool",cpuKernelImpl:IL}),Uz={kernelName:xa,backendName:"webgl",kernelFunc:Brt};var Vrt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Grt=It({opSnippet:Vrt}),Hz={kernelName:ga,backendName:"webgl",kernelFunc:Grt};var Wrt=Oo+`
  return exp(x);
`,Urt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ak=It({opSnippet:Wrt,packedOpSnippet:Urt,cpuKernelImpl:SL,dtype:"float32"}),qz={kernelName:as,backendName:"webgl",kernelFunc:Ak};function VC(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(y.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),lt({inputs:{x:s},backend:n,attrs:{shape:a}})}var Kz={kernelName:di,backendName:"webgl",kernelFunc:VC};var jz="return exp(x) - 1.0;",Hrt=It({opSnippet:jz,packedOpSnippet:jz,cpuKernelImpl:TL}),Xz={kernelName:ya,backendName:"webgl",kernelFunc:Hrt};var fg=class{constructor(t,e,n){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function GC(r,t,e){let n=e.texData.get(r.dataId),o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=lt({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),u=a.shape,l=new fg("real",u,t),c=new fg("imag",u,t),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=An({inputs:{real:m,imag:f},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f);let h=lt({inputs:{x:d},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(d),h}function qrt(r){let{inputs:t,backend:e}=r,{input:n}=t;return GC(n,!1,e)}var Yz={kernelName:Pp,backendName:"webgl",kernelFunc:qrt};var WC=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function wl(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||y.inferDtype(o),s==="string"){let i=y.getArrayFromDType(s,y.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new WC(n,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var Zz={kernelName:$l,backendName:"webgl",kernelFunc:wl};var UC=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Jz={kernelName:ba,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new UC(e.shape);return n.runWebGLProgram(o,[e],e.dtype)}};var Qz="return floor(x);",Krt=It({opSnippet:Qz,packedOpSnippet:Qz,cpuKernelImpl:NL}),t3={kernelName:ls,backendName:"webgl",kernelFunc:Krt};var jrt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Xrt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Yrt=ce({opSnippet:jrt,packedOpSnippet:Xrt,dtype:"int32"}),e3={kernelName:us,backendName:"webgl",kernelFunc:Yrt};var HC=class{constructor(t){this.variableNames=["A"];let e=He(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var qC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=He(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var r3={kernelName:ih,backendName:"webgl",kernelFunc:Zrt},Md,$k=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Zrt(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[l,u],p=[l,u,s];if(a||i){let h=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Md==null||h!==$k)&&($k=h,Md=document.createElement("canvas").getContext("2d",{willReadFrequently:$k})),Md.canvas.width=u,Md.canvas.height=l,Md.drawImage(o,0,0,u,l),o=Md.canvas}let m=e.makeTensorInfo(c,"int32");e.texData.get(m.dataId).usage=Hr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),o);let f=B().getBool("WEBGL_PACK")?new qC(p):new HC(p),d=e.runWebGLProgram(f,[m],"int32");return e.disposeData(m.dataId),d}function Jrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=S.convertConv2DDataFormat(c),g=S.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!1,h),x,b=[],w=i!=null,C=a!=null,T=f==="leakyrelu",E=()=>{let D=[o,s],P=(M,W)=>{if(W==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){let H=lt({inputs:{x:M},backend:e,attrs:{shape:[M.shape[0],1,1]}});return b.push(H),H}return M};if(w&&D.push(P(i,c)),C&&D.push(P(a,c)),T){let M=e.makeTensorInfo([],"float32",y.createScalarValue(d,"float32"));D.push(M),b.push(M)}return D};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=_C({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else if(g.strideWidth<=2&&h==="channelsLast"&&B().getBool("WEBGL_EXP_CONV")){let D=f?yl(f,!0):null,P=new Od(g,w,D,C,T),M=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],W=E();x=e.runWebGLProgram(P,W,"float32",M)}else if(B().getBool("WEBGL_CONV_IM2COL"))x=EC({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else{let D=f?yl(f,!1):null,P=new Fd(g,w,D,C,T),M=E();x=e.runWebGLProgram(P,M,"float32")}let $=lt({inputs:{x},backend:e,attrs:{shape:g.outShape}});return b.push(x),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),$}var n3={kernelName:ki,backendName:"webgl",kernelFunc:Jrt};function Qrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,d=[],h=c;h==null&&(h=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,u,h,l,p,!0),x=B().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=m?yl(m,x):null,w=[o,s],C=i!=null,T=a!=null,E=m==="leakyrelu";if(C&&w.push(i),T&&w.push(a),E){let M=e.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));w.push(M),d.push(M)}let $;x?$=new Ld(g,C,b,T,E):$=new Pd(g,C,b,T,E);let D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=e.runWebGLProgram($,w,"float32",D);return d.forEach(M=>e.disposeIntermediateTensorInfo(M)),P}var o3={kernelName:_i,backendName:"webgl",kernelFunc:Qrt};var KC=class{constructor(t,e,n,o){this.sliceDim=t,this.strides=e,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=n;let s=Wt(e.length),i=Wt(n.length),a=this.sliceDim>1?"strides[j]":"strides",u=Wt(o.length),l=o.length>1?"paramsShape[j]":"paramsShape";this.userCode=`
        ${s} strides = ${s}(${this.strides});
        ${u} paramsShape = ${u}(${this.paramsShape});
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            out_of_bounds = out_of_bounds || index < 0;
            out_of_bounds = out_of_bounds || index >= ${l};
            flattenIndex += index * ${a};
          }
          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function tnt(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=y.sizeFromShape(n.shape),[u,l,c,p]=S.prepareAndValidate(n,o),m=lt({inputs:{x:o},backend:e,attrs:{shape:[l,i]}}),f=lt({inputs:{x:n},backend:e,attrs:{shape:[y.sizeFromShape(n.shape)/c,c]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let x=e.readSync(o.dataId),b=e.bufferSync(n),w=kL(x,b,n.dtype,l,i,c,p,n.shape,a);return e.makeTensorInfo(u,n.dtype,w.values)}let d=new KC(i,p,[l,c],n.shape),h=e.runWebGLProgram(d,[f,m],f.dtype),g=lt({inputs:{x:h},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),g}var s3={kernelName:wa,backendName:"webgl",kernelFunc:tnt};var jC=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=Wt(this.rank),o=ent(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function ent(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${e[o]}`);return n.join()}function Dk(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=y.parseAxisParam(i,o.shape)[0];if(B().get("DEBUG")){let b=e.readSync(s.dataId),w=o.shape[u];for(let C=0;C<b.length;++C){let T=b[C];y.assert(T<=w-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${w-1}]`)}}let l=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=y.sizeFromShape(s.shape),p=[],m=lt({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=lt({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(m),p.push(f);let d=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let b=e.bufferSync(f),w=e.bufferSync(m),C=_L(w,b,d);return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(l.outputShape,C.dtype,C.values)}let h=new jC(m.shape,d),g=e.runWebGLProgram(h,[m,f],m.dtype);p.push(g);let x=lt({inputs:{x:g},backend:e,attrs:{shape:l.outputShape}});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}var i3={kernelName:hi,backendName:"webgl",kernelFunc:Dk};var rnt="return float(a > b);",nnt=`
  return vec4(greaterThan(a, b));
`,ont=ce({opSnippet:rnt,packedOpSnippet:nnt,cpuKernelImpl:EL,dtype:"bool"}),a3={kernelName:Ca,backendName:"webgl",kernelFunc:ont};var snt="return float(a >= b);",int=`
  return vec4(greaterThanEqual(a, b));
`,ant=ce({opSnippet:snt,packedOpSnippet:int,dtype:"bool",cpuKernelImpl:AL}),l3={kernelName:ps,backendName:"webgl",kernelFunc:ant};function lnt(r){let{inputs:t,backend:e}=r,{input:n}=t;return GC(n,!0,e)}var u3={kernelName:Lp,backendName:"webgl",kernelFunc:lnt};var unt="return float(!isnan(x) && !isinf(x));",cnt=It({opSnippet:unt,dtype:"bool"}),c3={kernelName:va,backendName:"webgl",kernelFunc:cnt};var pnt="return float(isinf(x));",mnt=It({opSnippet:pnt,dtype:"bool"}),p3={kernelName:Ia,backendName:"webgl",kernelFunc:mnt};var fnt="return float(isnan(x));",dnt=It({opSnippet:fnt,dtype:"bool"}),m3={kernelName:Sa,backendName:"webgl",kernelFunc:dnt};var hnt="return float(a < b);",gnt=`
  return vec4(lessThan(a, b));
`,xnt=ce({opSnippet:hnt,packedOpSnippet:gnt,cpuKernelImpl:$L,dtype:"bool"}),f3={kernelName:Ta,backendName:"webgl",kernelFunc:xnt};var ynt="return float(a <= b);",bnt=`
  return vec4(lessThanEqual(a, b));
`,wnt=ce({opSnippet:ynt,packedOpSnippet:bnt,cpuKernelImpl:DL,dtype:"bool"}),d3={kernelName:Na,backendName:"webgl",kernelFunc:wnt};function Cnt(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=RL(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var h3={kernelName:zp,backendName:"webgl",kernelFunc:Cnt};var vnt=Oo+`
  return x < 0.0 ? 0./0. : log(x);
`,Int=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Snt=It({opSnippet:vnt,packedOpSnippet:Int,cpuKernelImpl:FL}),g3={kernelName:fs,backendName:"webgl",kernelFunc:Snt};var Tnt=Oo+`
  return log(1.0 + x);
`,Nnt=It({opSnippet:Tnt}),x3={kernelName:ka,backendName:"webgl",kernelFunc:Nnt};var knt="return float(a >= 1.0 && b >= 1.0);",_nt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Ent=ce({opSnippet:knt,packedOpSnippet:_nt,dtype:"bool"}),y3={kernelName:_a,backendName:"webgl",kernelFunc:Ent};var Ant="return float(!(x >= 1.0));",$nt=It({opSnippet:Ant}),b3={kernelName:Ea,backendName:"webgl",kernelFunc:$nt};var Dnt="return float(a >= 1.0 || b >= 1.0);",Rnt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Fnt=ce({opSnippet:Dnt,packedOpSnippet:Rnt,dtype:"bool"}),w3={kernelName:Aa,backendName:"webgl",kernelFunc:Fnt};var XC=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var YC=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Ont=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=B().getBool("WEBGL_PACK_NORMALIZATION")?new YC(o.shape,s,i,a,u):new XC(o.shape,s,i,a,u);return e.runWebGLProgram(l,[o],o.dtype)},C3={kernelName:Dl,backendName:"webgl",kernelFunc:Ont};var ZC=class{constructor(t,e,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Pnt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new ZC(o.shape,a,u,l,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},v3={kernelName:Bp,backendName:"webgl",kernelFunc:Pnt};function I3(r,t,e,n){let o=y.sizeFromShape(t),i=y.sizeFromShape(r.shape)/o,a=lt({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Un(a,r.dtype,"max",n),l=lt({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function Rk(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=e.shouldExecuteOnCPU([o]),f=o;if(p){if(m){let w=e.texData.get(f.dataId).values,C=new Array(a);for(let $=0;$<C.length;$++)C[$]=o.shape[c[$]];let T=Xc(w,o.shape,o.dtype,c,C);f=e.makeTensorInfo(C,o.dtype);let E=e.texData.get(f.dataId);E.values=T}else f=$u(o,c,e);l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("max",l,a);let[d,h]=S.computeOutAndReduceShapes(f.shape,l),g=d;i&&(g=S.expandShapeToKeepDim(d,u));let x;if(m){let w=e.texData.get(f.dataId).values,C=OL(w,y.sizeFromShape(h),g,o.dtype);x=e.makeTensorInfo(g,o.dtype);let T=e.texData.get(x.dataId);T.values=C}else x=I3(f,h,g,e);return p&&e.disposeIntermediateTensorInfo(f),x}var S3={kernelName:ds,backendName:"webgl",kernelFunc:Rk};var Lnt=nC+`
  return max(a, b);
`,Mnt=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Au+`
  return result;
`,znt=ce({opSnippet:Lnt,packedOpSnippet:Mnt,cpuKernelImpl:PL}),T3={kernelName:hs,backendName:"webgl",kernelFunc:znt};function Bnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;oi(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))return er({inputs:{x:o},backend:e});let p=new ii(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var N3={kernelName:gs,backendName:"webgl",kernelFunc:Bnt};function Vnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,l,u),m=new Du(p,"max",!1);return e.runWebGLProgram(m,[o],o.dtype)}var k3={kernelName:Rl,backendName:"webgl",kernelFunc:Vnt};var JC=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,u=i-1-t.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},QC=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=u-1-t.padInfo.front,m=l-1-t.padInfo.top,f=c-1-t.padInfo.left,d=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Gnt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Du(m,"max",!0),d=e.runWebGLProgram(f,[i],i.dtype),h=new QC(m),g=e.runWebGLProgram(h,[o,d],i.dtype);return e.disposeIntermediateTensorInfo(d),g}var _3={kernelName:Gp,backendName:"webgl",kernelFunc:Gnt};function Wnt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;oi([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=!0,d=new ii(m,"max",f),h=e.runWebGLProgram(d,[a],a.dtype),g=new JC(m),x=e.runWebGLProgram(g,[o,h],a.dtype);return e.disposeIntermediateTensorInfo(h),x}var E3={kernelName:Vp,backendName:"webgl",kernelFunc:Wnt};function A3(r,t,e,n){let o=new ii(e,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new ii(e,"max",!0,!0,t);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var $3={kernelName:Wp,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;y.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];y.assert(S.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=S.computePool2DInfo(n.shape,o,s,l,i),[p,m]=A3(n,a,c,u);return[p,m]}};function D3(r,t,e,n){let o=y.sizeFromShape(t),i=y.sizeFromShape(r.shape)/o,a=lt({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Un(a,"float32","mean",n),l=lt({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var R3={kernelName:xs,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:o,axis:s}=t,i=e,a=n.shape.length,u=y.parseAxisParam(s,n.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=i.shouldExecuteOnCPU([n]),f=[],d=n;if(p){if(m){let C=i.texData.get(d.dataId).values,T=new Array(a);for(let D=0;D<T.length;D++)T[D]=n.shape[c[D]];let E=Xc(C,n.shape,n.dtype,c,T);d=i.makeTensorInfo(T,n.dtype);let $=i.texData.get(d.dataId);$.values=E}else d=$u(n,c,i);f.push(d),l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=S.computeOutAndReduceShapes(d.shape,l),x=h;o&&(x=S.expandShapeToKeepDim(h,u));let b=D3(d,g,x,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return b}};function Unt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Le({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=y.sizeFromShape(f),h=lt({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Un(h,h.dtype,"min",e),x;if(i){let b=S.expandShapeToKeepDim(m,u);x=lt({inputs:{x:g},backend:e,attrs:{shape:b}})}else x=lt({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),x}var F3={kernelName:ys,backendName:"webgl",kernelFunc:Unt};var Hnt=nC+`
  return min(a, b);
`,qnt=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Au+`
  return result;
`,Knt=ce({opSnippet:Hnt,packedOpSnippet:qnt,cpuKernelImpl:LL}),O3={kernelName:bs,backendName:"webgl",kernelFunc:Knt};var tv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=Wt(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var ev=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((d,h)=>d[0]+t[h]+d[1]);let o=t.length,s=Wt(o),i=e.map(d=>d[0]).join(","),a=e.map((d,h)=>d[0]+t[h]).join(","),u=tr("rc",o),l=tr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var jnt=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:o,mode:s}=e,i=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ev(n.shape,o,s):new tv(n.shape,o,s);return t.runWebGLProgram(i,[n],n.dtype)},P3={kernelName:ws,backendName:"webgl",kernelFunc:jnt};var Xnt=`if (b == 0.0) return NAN;
  return mod(a, b);`,Ynt=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Au+`
  return result;
`,Znt=ce({opSnippet:Xnt,packedOpSnippet:Ynt}),L3={kernelName:$a,backendName:"webgl",kernelFunc:Znt};var rv=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var Jnt=`
if (a == b) {
  return 1.0;
};
return a / b;`,Qnt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Fk=ce({opSnippet:Jnt,packedOpSnippet:Qnt,checkOutOfBounds:!0}),M3={kernelName:ss,backendName:"webgl",kernelFunc:Fk};var z3="return a - b;",Ok=ce({opSnippet:z3,packedOpSnippet:z3,supportsComplex:!0,cpuKernelImpl:eM}),B3={kernelName:Bs,backendName:"webgl",kernelFunc:Ok};function Pk(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=y.parseAxisParam([s],o.shape),a=Rk({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=S.expandShapeToKeepDim(a.shape,i),l=lt({inputs:{x:a},backend:e,attrs:{shape:u}}),c=Ok({inputs:{a:o,b:l},backend:e}),p=Ak({inputs:{x:c},backend:e}),m=Zc({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=lt({inputs:{x:m},backend:e,attrs:{shape:u}}),d=Fk({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}var V3={kernelName:Ms,backendName:"webgl",kernelFunc:Pk};function tot(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,u=a?o:Pk({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new rv(l,c,s),m=[[i]],f=e.runWebGLProgram(p,[u],"int32",m);return a||e.disposeIntermediateTensorInfo(u),f}var G3={kernelName:Up,backendName:"webgl",kernelFunc:tot};var eot=fr+`
  return -x;
`,rot=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function not(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.texData.get(n.dataId),[i,a]=zL(s.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,i)}let o;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new ro(n.shape,rot):o=new Zr(n.shape,eot),e.runWebGLProgram(o,[n],n.dtype)}var W3={kernelName:gi,backendName:"webgl",kernelFunc:not};var oot=Vr.nonMaxSuppressionV3Impl;function sot(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=oot(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var U3={kernelName:Ra,backendName:"webgl",kernelFunc:sot};var iot=Vr.nonMaxSuppressionV4Impl;function aot(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=iot(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var H3={kernelName:Fa,backendName:"webgl",kernelFunc:aot};var lot=Vr.nonMaxSuppressionV5Impl;function uot(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:x}=lot(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var q3={kernelName:Oa,backendName:"webgl",kernelFunc:uot};var nv=class{constructor(t,e,n,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var cot=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:u}=n,l=y.sizeFromShape(o.shape),c=new nv(l,i,a,u),p=lt({inputs:{x:o},backend:e,attrs:{shape:[l]}}),m=e.runWebGLProgram(c,[p],s);e.disposeIntermediateTensorInfo(p);let f=[...o.shape,i],d=lt({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(m),d},K3={kernelName:vs,backendName:"webgl",kernelFunc:cot};function dg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=bl({inputs:{input:n},backend:e}),s=dg({inputs:{x:o},backend:e}),i=Qc({inputs:{input:n},backend:e}),a=dg({inputs:{x:i},backend:e}),u=An({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return wl({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var j3={kernelName:Ti,backendName:"webgl",kernelFunc:dg};function X3(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=bl({inputs:{input:n},backend:e}),s=X3({inputs:{x:o},backend:e}),i=Qc({inputs:{input:n},backend:e}),a=dg({inputs:{x:i},backend:e}),u=An({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return wl({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var Y3={kernelName:xi,backendName:"webgl",kernelFunc:X3};function pot(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return VC({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=VC({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=Ek({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var Z3={kernelName:yi,backendName:"webgl",kernelFunc:pot};var ov=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,c)=>l[0]+t[c]+l[1]);let o=t.length,s=Wt(o),i=e.map(l=>l[0]).join(","),a=e.map((l,c)=>l[0]+t[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var sv=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,g)=>h[0]+t[g]+h[1]);let o=t.length,s=Wt(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+t[g]).join(","),u=tr("rc",o),l=tr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Lk=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;if(y.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return wl({backend:e,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sv(o.shape,s,i):new ov(o.shape,s,i),u=[[i]];return e.runWebGLProgram(a,[o],o.dtype,u)},J3={kernelName:Is,backendName:"webgl",kernelFunc:Lk};var mot=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,fot=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Au+`
  return result;
`,dot=ce({opSnippet:mot,packedOpSnippet:fot}),Q3={kernelName:Ss,backendName:"webgl",kernelFunc:dot};function hot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=y.parseAxisParam(s,o.shape),c=l,p=S.getAxesPermutation(c,a),m=o;p!=null&&(m=Le({inputs:{x:o},backend:e,attrs:{perm:p}}),c=S.getInnerMostAxes(c.length,a),u.push(m)),S.assertAxesAreInnerMostDims("prod",c,a);let f;if(e.shouldExecuteOnCPU([m])){let d=e.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:x}=VL(m.shape,m.dtype,d,c);f=e.makeTensorInfo(g,x,h)}else{let[d,h]=S.computeOutAndReduceShapes(m.shape,c),g=y.sizeFromShape(h),x=lt({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}}),b=Xu(o.dtype),w=Un(x,b,"prod",e);f=lt({inputs:{x:w},backend:e,attrs:{shape:d}}),u.push(x),u.push(w)}if(i){u.push(f);let d=S.expandShapeToKeepDim(f.shape,l);f=lt({inputs:{x:f},backend:e,attrs:{shape:d}})}return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var tB={kernelName:Ns,backendName:"webgl",kernelFunc:hot};function got(r){let{inputs:t,backend:e,attrs:n}=r,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),p=e.readSync(i.dataId),m=a.map(g=>e.readSync(g.dataId)),f=a.map(g=>g.shape),[d,h]=GL(l,o.shape,c,s.shape,s.dtype,p,i.shape,m,f,u);return e.makeTensorInfo(d,s.dtype,h)}var eB={kernelName:Hp,backendName:"webgl",kernelFunc:got};var Mk=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=WL(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},rB={kernelName:Fl,backendName:"webgl",kernelFunc:Mk};var xot="return 1.0 / x;",yot=It({opSnippet:xot}),nB={kernelName:Pa,backendName:"webgl",kernelFunc:yot};var bot=fr+`
  return (x < 0.0) ? 0.0 : x;
`,wot=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Cot=It({opSnippet:bot,packedOpSnippet:wot}),oB={kernelName:ks,backendName:"webgl",kernelFunc:Cot};var vot=fr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Iot=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Sot=It({opSnippet:vot,packedOpSnippet:Iot}),sB={kernelName:As,backendName:"webgl",kernelFunc:Sot};var iv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var av=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Tot(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new av(o.shape,u,l,s,i):new iv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],"float32")}var iB={kernelName:Es,backendName:"webgl",kernelFunc:Tot};var lv=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Not(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new lv(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var aB={kernelName:jp,backendName:"webgl",kernelFunc:Not};var uv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var cv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function kot(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cv(o.shape,u,l,s,i):new uv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var lB={kernelName:_s,backendName:"webgl",kernelFunc:kot};var pv=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function _ot(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new pv(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var uB={kernelName:Kp,backendName:"webgl",kernelFunc:_ot};var mv=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,u)=>o(u)).join(","),i=Wt(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var fv=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=tr("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Wt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(d){return m(d)}function l(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=t.map((b,w)=>f(w,d)),g=h.join(","),x=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(d,h){return e.indexOf(d)!==-1&&t[d]!==1?`${t[d]} - ${h[d]} - 1`:`${h[d]}`}}};function Eot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return er({inputs:{x:o},backend:e});let u=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fv(o.shape,a):new mv(o.shape,a);return e.runWebGLProgram(u,[o],o.dtype)}var cB={kernelName:$s,backendName:"webgl",kernelFunc:Eot};var dv=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var pB={kernelName:qa,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=new dv(n.shape,s),[l,c]=S.getImageCenter(i,n.shape[1],n.shape[2]),p=[[l,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,p)}};var Aot=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,$ot=It({opSnippet:Aot}),mB={kernelName:Ds,backendName:"webgl",kernelFunc:$ot};var Dot="return inversesqrt(x);",Rot=It({opSnippet:Dot,cpuKernelImpl:UL}),fB={kernelName:Rs,backendName:"webgl",kernelFunc:Rot};var zd=class{constructor(t,e,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=Wt(s.length),l=Wt(i.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Fot(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=[p/l,l];if(p===0)return e.makeTensorInfo(i,o.dtype);let f=lt({inputs:{x:o},backend:e,attrs:{shape:[u,a]}}),d=lt({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),h=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new zd(u,a,f.shape.length,d.shape.length,c,m),x=e.runWebGLProgram(g,[d,f,h],d.dtype),b=lt({inputs:{x},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(h),b}var dB={kernelName:La,backendName:"webgl",kernelFunc:Fot};var hv=class{constructor(t,e,n,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=B().getNumber("WEBGL_VERSION")===2?s:i,u=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Oot(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=new hv(o.shape[0],o.shape[1],s.shape[1],i),u=[[o.shape[1]]];return e.runWebGLProgram(a,[o,s],"int32",u)}var hB={kernelName:Xp,backendName:"webgl",kernelFunc:Oot};var gv=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<e.length;c++)l.push(`${a[c]}`),c<t&&u.push(`${a[c]}`);o=u.join(),s=l.join()}let i=Wt(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Pot(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=new gv(n.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[n,o,s],ir(o.dtype,s.dtype))}var gB={kernelName:wi,backendName:"webgl",kernelFunc:Pot};var Lot=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Mot=It({opSnippet:Lot}),xB={kernelName:Ma,backendName:"webgl",kernelFunc:Mot};var zot=Oo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Bot=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Vot=It({opSnippet:zot,packedOpSnippet:Bot,cpuKernelImpl:qL}),yB={kernelName:Os,backendName:"webgl",kernelFunc:Vot};var Got=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Wot=It({opSnippet:Got}),bB={kernelName:Ba,backendName:"webgl",kernelFunc:Wot};var Uot=Oo+`
  return sin(x);
`,Hot=It({opSnippet:Uot}),wB={kernelName:Fs,backendName:"webgl",kernelFunc:Hot};var qot=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Kot=It({opSnippet:qot}),CB={kernelName:za,backendName:"webgl",kernelFunc:Kot};var jot=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Xot=It({opSnippet:jot}),vB={kernelName:Va,backendName:"webgl",kernelFunc:Xot};var Yot=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,b)=>x*b),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<o.shape.length;++x)u.push([0,0]);let l=[],c=Lk({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),p=S.getReshaped(c.shape,s,a,!1),m=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(c.shape,s,a,!1),d=lt({inputs:{x:c},backend:e,attrs:{shape:p}}),h=Le({inputs:{x:d},backend:e,attrs:{perm:m}}),g=lt({inputs:{x:h},backend:e,attrs:{shape:f}});return l.push(c),l.push(d),l.push(h),l.forEach(x=>e.disposeIntermediateTensorInfo(x)),g},IB={kernelName:vi,backendName:"webgl",kernelFunc:Yot};function Zot(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(n.dataId),u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,m,f,d,h]=jL(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var SB={kernelName:Ol,backendName:"webgl",kernelFunc:Zot};function Jot(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(n.dataId),u=Array.from(e.readSync(s.dataId)),[l,c,p]=XL(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var TB={kernelName:Ga,backendName:"webgl",kernelFunc:Jot};function Qot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=Jw(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var NB={kernelName:Pl,backendName:"webgl",kernelFunc:Qot};function tst(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=Jw(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var kB={kernelName:Ll,backendName:"webgl",kernelFunc:tst};function est(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let x=e.bufferSync(o),b=e.bufferSync(s),w=y.decodeString(e.readSync(i.dataId)[0]),C=HL(x,b,a,m,c,l,u,p,w,f);return e.makeTensorInfo(a,C.dtype,C.values)}let d=new zd(l,u,o.shape.length,s.shape.length,p,[m,1],f),h=e.runWebGLProgram(d,[s,o,i],s.dtype),g=lt({inputs:{x:h},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(h),g}var _B={kernelName:Yp,backendName:"webgl",kernelFunc:est};function rst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=y.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(m=>{let f=[...p];f[a]=m;let d=ai({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=m,d})}var EB={kernelName:Ii,backendName:"webgl",kernelFunc:rst};var AB="return sqrt(x);",nst=It({opSnippet:AB,packedOpSnippet:AB,cpuKernelImpl:YL}),$B={kernelName:Ps,backendName:"webgl",kernelFunc:nst};var ost="return x * x;",sst=It({opSnippet:ost}),DB={kernelName:Ml,backendName:"webgl",kernelFunc:sst};var RB="return (a - b) * (a - b);",ist=ce({opSnippet:RB,packedOpSnippet:RB}),FB={kernelName:zs,backendName:"webgl",kernelFunc:ist};function ast({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=fr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Zr(n.shape,o);return e.runWebGLProgram(s,[n],n.dtype)}var OB={kernelName:co,backendName:"webgl",kernelFunc:ast};var xv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=Wt(n.length),i=Wt(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function lst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:b,end:w,strides:C}=Be.sliceInfo(o.shape,s,i,a,u,l,c,p,m),T;if(h)T=lt({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let $=Be.computeOutShape(b,w,C),D=ai({inputs:{x:o},backend:e,attrs:{begin:b,size:$}});T=lt({inputs:{x:D},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([o])){let D=e.readSync(o.dataId),P=vt(o.shape,o.dtype,D),M=ZL(f,P,C,b);T=e.makeTensorInfo(d,o.dtype,M.values)}else{let D=new xv(b,C,f);T=e.runWebGLProgram(D,[o],o.dtype)}let E=lt({inputs:{x:T},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(T),E}var PB={kernelName:Wa,backendName:"webgl",kernelFunc:lst};function ust(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.readSync(c.dataId),f=e.readSync(p.dataId),[d,h]=JL(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var LB={kernelName:zl,backendName:"webgl",kernelFunc:ust};function cst(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),u=e.readSync(i.dataId)[0],[l,c,p]=QL(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var MB={kernelName:Bl,backendName:"webgl",kernelFunc:cst};function pst(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=tM(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var zB={kernelName:Vl,backendName:"webgl",kernelFunc:pst};var mst="return tan(x);",fst=It({opSnippet:mst}),BB={kernelName:Vs,backendName:"webgl",kernelFunc:fst};var dst=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,hst=It({opSnippet:dst}),VB={kernelName:Gs,backendName:"webgl",kernelFunc:hst};var yv=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;let o=Wt(this.rank),s=gst(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function gst(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${e[o]}, ${r[o]})`);return n.join()}function zk(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=e.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>y.decodeString(m)):u,c=vt(o.shape,o.dtype,l),p=rM(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new yv(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var GB={kernelName:Xn,backendName:"webgl",kernelFunc:zk};var bv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},wv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function ep(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function WB(r){let t=1;for(;t<r;)t*=2;return t}function xst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n,a=B().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=B().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,c=l[l.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>u){let M=e.readSync(o.dataId),[W,H]=nM(M,l,o.dtype,s,i);return[e.makeTensorInfo(W.shape,W.dtype,W.values),e.makeTensorInfo(H.shape,H.dtype,H.values)]}if(s===0)return l[l.length-1]=0,[e.makeTensorInfo(l,o.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(c===1)return[o,wl({attrs:{shape:l,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),m=p!==null&&p.isPacked,f=m?e.unpackTensor(o):o,h=y.sizeFromShape(l)/c,g=lt({inputs:{x:f},attrs:{shape:[h,c]},backend:e});m&&ep(e,f);let x=WB(s),b=WB(c),w=null,C=()=>w===null?[g,g]:[g,w],T=(M,W,H)=>{let q=C(),X=new bv(H),Z=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[M],[W]],et=w;w=e.runWebGLProgram(X,q,"int32",Z),ep(e,et)};for(let M=1;M<x;M*=2){let W=M*2;for(let H=M;H>=1;H/=2)T(W,H,[h,b])}for(let M=b;M>x;M/=2){let W=C(),H=new wv([h,M/2]),X=[[c],[w===null?1:0],[x]],j=w;w=e.runWebGLProgram(H,W,"int32",X),ep(e,j);let Z=x/2,et=Z*2;for(let K=Z;K>=1;K/=2)T(et,K,w.shape)}let E=w;w=ai({inputs:{x:w},backend:e,attrs:{begin:0,size:[h,s]}}),ep(e,E);let $=Dk({inputs:{x:g,indices:w},backend:e,attrs:{axis:1,batchDims:1}});ep(e,g);let D=l.slice(0,-1);D.push(s),E=w,w=lt({inputs:{x:w},attrs:{shape:D},backend:e}),ep(e,E);let P=$;return $=lt({inputs:{x:$},attrs:{shape:D},backend:e}),ep(e,P),[$,w]}var UB={kernelName:Ua,backendName:"webgl",kernelFunc:xst};var Cv=class{constructor(t,e,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function yst(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],x=new Cv(p,m,i,a,u,g);return e.runWebGLProgram(x,[o,s],"float32")}var HB={kernelName:Ha,backendName:"webgl",kernelFunc:yst};function bst(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;oi(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=oM(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var qB={kernelName:Zp,backendName:"webgl",kernelFunc:bst};function wst(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let h=0;h<a;h++)h!==s&&(l[c++]=i.shape[h]);let p=[],m=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=ai({inputs:{x:i},backend:e,attrs:{begin:m,size:f}}),x=lt({inputs:{x:g},backend:e,attrs:{shape:l}});d[h]=x,p.push(g)}return p.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var KB={kernelName:Si,backendName:"webgl",kernelFunc:wst};var vv=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,p=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Cst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=S.getAxesPermutation([l],a),p=o;c!=null&&(p=Le({inputs:{x:o},backend:e,attrs:{perm:c}}),u.push(p),l=S.getInnerMostAxes(1,a)[0]);let m=S.segment_util.computeOutShape(p.shape,l,i),f=y.sizeFromShape([p.shape[l]]),d=lt({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(d);let h=Xu(o.dtype),g=(C,T,E,$,D)=>{let P=C.shape[0],M=C.shape[1],W=S.segment_util.segOpComputeOptimalWindowSize(M,D),H={windowSize:W,inSize:M,batchSize:P,numSegments:D},q=new vv(H,T),X=e.compileAndRun(q,[C,E],$);if(u.push(X),X.shape[1]===D)return X;let j=Mk({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),Z=zk({inputs:{x:j},backend:e,attrs:{reps:[M/W]}});return u.push(j),u.push(Z),g(X,T,Z,$,D)},x=g(d,"unsortedSegmentSum",s,h,i),b=lt({inputs:{x},backend:e,attrs:{shape:m}}),w=b;if(c!=null){u.push(b);let C=S.getUndoAxesPermutation(c);w=Le({inputs:{x:w},backend:e,attrs:{perm:C}})}return u.forEach(C=>e.disposeIntermediateTensorInfo(C)),w}var jB={kernelName:Gl,backendName:"webgl",kernelFunc:Cst};var vst=[OM,LM,MM,zM,VM,GM,WM,UM,KM,jM,XM,YM,ZM,JM,QM,tz,ez,rz,nz,oz,sz,az,lz,uz,fz,hz,gz,IM,yz,wz,Cz,vz,Iz,Sz,Tz,Nz,kz,_z,Ez,Dz,Rz,Fz,Oz,Pz,Lz,Mz,zz,Bz,Vz,Gz,Wz,Uz,Hz,qz,Kz,Xz,Yz,Zz,Jz,t3,e3,r3,n3,o3,s3,i3,a3,l3,vM,u3,bz,c3,p3,m3,SM,f3,d3,h3,g3,x3,y3,b3,w3,C3,v3,S3,T3,N3,k3,_3,E3,$3,R3,F3,O3,P3,L3,G3,EM,W3,U3,H3,q3,cz,K3,Y3,Z3,J3,Q3,TM,tB,eB,rB,pz,M3,nB,oB,sB,$M,iB,aB,lB,uB,cB,pB,mB,fB,dB,hB,gB,xB,yB,bB,wB,CB,iz,V3,vB,IB,SB,TB,NB,kB,_B,EB,$B,DB,FB,OB,PB,LB,MB,zB,B3,RM,BB,VB,GB,UB,HB,FM,qB,KB,jB,j3];for(let r of vst)Wu(r);var Zt;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Zt||(Zt={}));var Ru;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(Ru||(Ru={}));var XB;function Ist(r){XB=r.wasm.cwrap(Ni,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Sst(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=0;if(i!=null){let D=e.dataIdMap.get(i.dataId);if(D.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${D.shape.length}.`);d=D.id}let h=a==null?0:e.dataIdMap.get(a.dataId).id,g=Ru[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let x=u?o.shape[2]:o.shape[1],b=l?s.shape[1]:s.shape[2],w=Lr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),C=e.makeOutput([...w,x,b],o.dtype),T=e.dataIdMap.get(C.dataId).id,E=new Uint8Array(new Int32Array(o.shape).buffer),$=new Uint8Array(new Int32Array(s.shape).buffer);return XB(m,E,o.shape.length,f,$,s.shape.length,u,l,g,d,h,p||0,T),C}var YB={kernelName:Ni,backendName:"wasm",setupFunc:Ist,kernelFunc:Sst};function ae(r,t){let e;function n(s){e=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:i,inputs:{x:a}}=s,u=i.dataIdMap.get(a.dataId).id,l=i.makeOutput(a.shape,t||a.dtype),c=i.dataIdMap.get(l.dataId).id;return y.sizeFromShape(l.shape)===0||e(u,Zt[a.dtype],c),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var ZB=ae(pi);function pe(r,t,e){let n;function o(i){n=i.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:a,inputs:u}=i,{a:l,b:c}=u,p=a.dataIdMap.get(l.dataId).id,m=a.dataIdMap.get(c.dataId).id,f=e!=null?e:l.dtype,d=S.assertAndGetBroadcastShape(l.shape,c.shape),h=a.makeOutput(d,f);if(y.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),x=new Uint8Array(new Int32Array(c.shape).buffer),b=a.dataIdMap.get(h.dataId).id;return(()=>n(p,g,l.shape.length,m,x,c.shape.length,Zt[l.dtype],b))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var Tst=!0,JB=pe(jn,Tst);var QB;function Nst(r){QB=r.wasm.cwrap(jo,null,["array","number","number","number"])}function kst(r){let{inputs:t,backend:e}=r,n=e.makeOutput(t[0].shape,t[0].dtype);if(y.sizeFromShape(n.shape)===0)return n;let o=t.map(a=>e.dataIdMap.get(a.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),i=e.dataIdMap.get(n.dataId).id;return QB(s,o.length,Zt[n.dtype],i),n}var tV={kernelName:jo,backendName:"wasm",setupFunc:Nst,kernelFunc:kst};function rp(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype),o=e.typedArrayFromHeap(t);return e.typedArrayFromHeap(n).set(o),n}var eV={kernelName:uo,backendName:"wasm",kernelFunc:rp};var rV;function _st(r){rV=r.wasm.cwrap(Yn,null,["number","array","number","number","number","array","number"])}function oo(r){let{inputs:t,backend:e,attrs:n}=r,[o,s]=Ast(t.x.shape,n.perm),i=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(i=!1);let a=Est(t.x.shape,n.perm),u={dataId:t.x.dataId,shape:o,dtype:t.x.dtype};if(i){let d=rp({inputs:t,backend:e});return d.shape=a,d}let l=e.makeOutput(a,u.dtype),c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(u.shape).buffer);return rV(c,f,u.shape.length,Zt[u.dtype],p,m,s.length),l}function Est(r,t){let e=new Array(r.length);for(let n=0;n<e.length;n++)e[n]=r[t[n]];return e}function Ast(r,t){let e=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&e.push(r[o]),r[t[o]]!==1&&n.push(t[o]);for(let o=0;o<n.length;++o){let s=-1;for(let i=0;i<n.length;++i)n[i]>=o&&(s===-1||n[s]>n[i])&&(s=i);n[s]=o}return[e,n]}var nV={kernelName:Yn,backendName:"wasm",kernelFunc:oo,setupFunc:_st};function wn(r,t,e){let n=r.shape,o=r.shape.length,s=y.parseAxisParam(t,n),i=s,a=S.getAxesPermutation(i,o),u=null,l=!1;if(a!=null){let c=new Array(o);for(let f=0;f<c.length;f++)c[f]=n[a[f]];i=S.getInnerMostAxes(i.length,o),u=oo({inputs:{x:r},attrs:{perm:a},backend:e});let p=e.dataIdMap.get(r.dataId).id;e.dataIdMap.get(u.dataId).id!==p&&(l=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:l}}var oV;function $st(r){oV=r.wasm.cwrap(ia,null,["number, number, number"])}function Dst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("all",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),x=y.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(y.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;oV(u,x,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var sV={kernelName:ia,backendName:"wasm",setupFunc:$st,kernelFunc:Dst};var iV;function Rst(r){iV=r.wasm.cwrap(aa,null,["number, number, number"])}function Fst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("any",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),x=y.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(y.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;iV(u,x,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var aV={kernelName:aa,backendName:"wasm",setupFunc:Rst,kernelFunc:Fst};var lV;function Ost(r){lV=r.wasm.cwrap(Xo,null,["number","number","number","number","number"])}function Pst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=i,u=s,{transposed:l,axes:c,inputWasTransposed:p}=wn(s,o,t);if(p){let x=t.dataIdMap.get(l.dataId).id;x!==i&&(u=l,a=x)}let m=u.shape.slice(0,-1),f=t.makeOutput(m,"int32"),d=t.dataIdMap.get(f.dataId).id,h=y.sizeFromShape(f.shape),g=u.shape[c[0]];return lV(a,Zt[u.dtype],h,g,d),p&&t.disposeData(l.dataId),f}var uV={kernelName:Xo,backendName:"wasm",kernelFunc:Pst,setupFunc:Ost};var cV;function Lst(r){cV=r.wasm.cwrap(Yo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Mst(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,x=c.strideHeight,b=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let C=n.makeOutput(c.outShape,"float32"),T=n.dataIdMap.get(C.dataId).id;return cV(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,x,b,w,T),C}var pV={kernelName:Yo,backendName:"wasm",setupFunc:Lst,kernelFunc:Mst};function lr(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=y.sizeFromShape(n.shape),i=y.inferFromImplicitShape(o,s);return y.assert(s===y.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var mV={kernelName:bi,backendName:"wasm",kernelFunc:lr};var fV;function zst(r){fV=r.wasm.cwrap(Zo,null,["number","array","number","number","array","number","number","number","number"])}function Bst(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(d),x=y.sizeFromShape(h),w=Lr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);y.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let C=i?[g,c,m]:[g,m,c],T=a?[x,f,p]:[x,p,f],E=lr({inputs:{x:o},backend:e,attrs:{shape:C}}),$=lr({inputs:{x:s},backend:e,attrs:{shape:T}}),D=e.dataIdMap.get(E.dataId).id,P=e.dataIdMap.get($.dataId).id,M=i?E.shape[2]:E.shape[1],W=a?$.shape[1]:$.shape[2],H=Math.max(g,x),q=e.makeOutput([H,M,W],E.dtype),X=e.dataIdMap.get(q.dataId).id,j=new Uint8Array(new Int32Array(E.shape).buffer),Z=new Uint8Array(new Int32Array($.shape).buffer);return fV(D,j,E.shape.length,P,Z,$.shape.length,i,a,X),e.disposeData(E.dataId),e.disposeData($.dataId),q.shape=w,q}var dV={kernelName:Zo,backendName:"wasm",setupFunc:zst,kernelFunc:Bst};function Po(r){let{inputs:{x:t},attrs:{begin:e,size:n},backend:o}=r,[s,i]=Be.parseSliceParams(t,e,n),a=Be.isSliceContinous(t.shape,s,i),u=o.readSync(t.dataId),l=o.makeOutput(i,t.dtype),c=y.computeStrides(t.shape),p=o.dataIdMap.get(l.dataId);if(a){let d=Be.computeFlatOffset(s,c);return t.dtype==="string"?p.stringBytes=u.slice(d,d+y.sizeFromShape(i)):o.typedArrayFromHeap(l).set(u.subarray(d,d+y.sizeFromShape(i))),l}if(t.dtype==="string"){let d=zc(u,s,i,t.shape,t.dtype);return p.stringBytes=d,l}let m=o.typedArrayFromHeap(l),f=t.shape.length;if(f===2)Vst(u,c[0],m,s,i);else if(f===3)Gst(u,c[0],c[1],m,s,i);else if(f===4)Wst(u,c[0],c[1],c[2],m,s,i);else{let d=zc(u,s,i,t.shape,t.dtype);m.set(d)}return l}function Vst(r,t,e,n,o){let s=0,i=n[0],a=n[1],u=i+o[0];for(let l=i;l<u;l++){let c=l*t+a;e.set(r.subarray(c,c+o[1]),s),s+=o[1]}}function Gst(r,t,e,n,o,s){let i=0,a=o[0],u=o[1],l=o[2],c=a+s[0],p=u+s[1];for(let m=a;m<c;m++)for(let f=u;f<p;f++){let d=m*t+f*e+l;n.set(r.subarray(d,d+s[2]),i),i+=s[2]}}function Wst(r,t,e,n,o,s,i){let a=0,u=s[0],l=s[1],c=s[2],p=u+i[0],m=l+i[1],f=c+i[2],d=s[3];for(let h=u;h<p;h++)for(let g=l;g<m;g++)for(let x=c;x<f;x++){let b=h*t+g*e+x*n+d;o.set(r.subarray(b,b+i[3]),a),a+=i[3]}}var hV={kernelName:Ci,backendName:"wasm",kernelFunc:Po};function Ust(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n,a=s.reduce((x,b)=>x*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=lr({inputs:{x:o},backend:e,attrs:{shape:u}}),d=oo({inputs:{x:f},backend:e,attrs:{perm:l}}),h=lr({inputs:{x:d},backend:e,attrs:{shape:c}}),g=Po({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeData(f.dataId),e.disposeData(d.dataId),e.disposeData(f.dataId),g}var gV={kernelName:mi,backendName:"wasm",kernelFunc:Ust};function li(r){let{inputs:{x:t},attrs:{dtype:e},backend:n}=r,o=n.makeOutput(t.shape,e),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(o).set(s),o}var xV={kernelName:ao,backendName:"wasm",kernelFunc:li};var yV=ae(Jo);var bV;function Hst(r){bV=r.wasm.cwrap(lo,null,["number","number","number","number"])}function qst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a=e.dataIdMap.get(o.dataId).id,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(u.dataId).id;return bV(a,s,i,l),u}var wV={kernelName:lo,backendName:"wasm",setupFunc:Hst,kernelFunc:qst};function Bk(r){let{inputs:t,backend:e}=r,n=y.parseAxisParam(r.attrs.axis,t[0].shape)[0],o=S.computeOutShape(t.map(f=>f.shape),n),s=t.filter(f=>y.sizeFromShape(f.shape)>0);if(s.length===1)return rp({inputs:{x:s[0]},backend:e});let i=e.makeOutput(o,t[0].dtype);if(y.sizeFromShape(o)===0)return i;let a=s.map(f=>f.shape);if(S.assertParamsConsistent(a,n),s[0].dtype==="string"){let f=s.map(w=>{let C=y.sizeFromShape(w.shape.slice(n));return lr({inputs:{x:w},backend:e,attrs:{shape:[-1,C]}})}),d=f.map(w=>({vals:e.readSync(w.dataId),shape:w.shape}));o=S.computeOutShape(f.map(w=>w.shape),1);let h=f[0].shape[0]===1,g=Pc(d,o,t[0].dtype,h),x=S.computeOutShape(s.map(w=>w.shape),n);i.shape=x;let b=e.dataIdMap.get(i.dataId);return b.stringBytes=S.fromStringArrayToUint8(g),f.forEach(w=>e.disposeData(w.dataId)),i}let u=y.sizeFromShape(s[0].shape.slice(0,n)),l=0,c=s.map(f=>{let d=y.sizeFromShape(f.shape.slice(n));return l+=d,d}),p=s.map(f=>e.typedArrayFromHeap(f)),m=e.typedArrayFromHeap(i);for(let f=0;f<u;f++){let d=f*l;for(let h=0;h<p.length;h++){let g=c[h],x=f*g,b=p[h].subarray(x,x+g);m.set(b,d),d+=g}}return i}var CV={kernelName:fi,backendName:"wasm",kernelFunc:Bk};var vV;function Kst(r){vV=r.wasm.cwrap(Qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p,dataFormat:m}=e,f=S.convertConv2DDataFormat(m),d=S.computeConv2DInfo(o.shape,s.shape,u,l,c,p,!1,f),h=d.filterHeight,g=d.filterWidth,x=d.padInfo.top,b=d.padInfo.right,w=d.padInfo.bottom,C=d.padInfo.left,T=d.dilationHeight,E=d.dilationWidth,$=d.strideHeight,D=d.strideWidth,P=d.inChannels,M=d.outChannels,W=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let H=n.makeOutput(d.outShape,"float32"),q=n.dataIdMap.get(H.dataId).id;return vV(i,o.shape[0],o.shape[1],o.shape[2],a,h,g,x,b,w,C,W,T,E,$,D,P,M,q),H}var IV={kernelName:Qo,backendName:"wasm",setupFunc:Kst,kernelFunc:jst};var SV;function Xst(r){SV=r.wasm.cwrap(ts,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yst(r){let{backend:t,inputs:e,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,inputShape:c}=n,p=1,m=S.convertConv2DDataFormat(u),f=S.computeConv2DInfo(c,s.shape,i,p,a,l,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:x,inHeight:b,inWidth:w,outChannels:C,outHeight:T,outWidth:E,strideHeight:$,strideWidth:D}=f,P=h-1-f.padInfo.top,M=g-1-f.padInfo.left,W=f.dataFormat==="channelsLast",H=y.computeStrides(f.inShape),q=y.computeStrides(o.shape),[X,j,Z]=y.computeStrides(s.shape),et=H[0],K=W?H[1]:H[2],ot=W?H[2]:1,st=W?1:H[1],it=q[0],pt=W?q[1]:q[2],at=W?q[2]:1,gt=W?1:q[1],dt=t.makeOutput(f.inShape,"float32"),bt=t.dataIdMap.get(dt.dataId).id,Tt=t.dataIdMap.get(o.dataId).id,At=t.dataIdMap.get(s.dataId).id;return SV(Tt,At,d,h,g,b,w,x,T,E,C,$,D,P,M,X,j,Z,et,K,ot,st,it,pt,at,gt,bt),dt}var TV={kernelName:ts,backendName:"wasm",setupFunc:Xst,kernelFunc:Yst};var NV=ae(es);var kV=ae(rs);var Vk;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(Vk||(Vk={}));var _V;function Zst(r){_V=r.wasm.cwrap(da,null,["number","number","number","number","array","number","number","number","number","number"])}function Jst(r){let{backend:t,inputs:e,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:i}=n,{image:a,boxes:u,boxInd:l}=e,c=u.shape[0],[p,m]=i,f=[c,p,m,a.shape[3]],d=t.dataIdMap.get(a.dataId),h;a.dtype!=="float32"&&(h=li({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),d=t.dataIdMap.get(h.dataId));let g=d.id,x=t.dataIdMap.get(u.dataId).id,b=t.dataIdMap.get(l.dataId).id,w=t.makeOutput(f,"float32"),C=t.dataIdMap.get(w.dataId).id,T=new Uint8Array(new Int32Array(a.shape).buffer);return _V(g,x,b,c,T,p,m,Vk[o],s,C),h!=null&&t.disposeData(h.dataId),w}var EV={kernelName:da,backendName:"wasm",setupFunc:Zst,kernelFunc:Jst};var AV;function Qst(r){AV=r.wasm.cwrap(fa,null,["number","number","number","number","number","number"])}function tit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=oo({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumprod",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;AV(d,i?1:0,a?1:0,f,h,Zt[o.dtype]);let g=m;if(l!==null){let x=S.getUndoAxesPermutation(l);g=oo({inputs:{x:m},attrs:{perm:x},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var $V={kernelName:fa,backendName:"wasm",setupFunc:Qst,kernelFunc:tit};var DV;function eit(r){DV=r.wasm.cwrap(ns,null,["number","number","number","number","number","number"])}function rit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=oo({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumsum",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;DV(d,i?1:0,a?1:0,f,h,Zt[o.dtype]);let g=m;if(l!==null){let x=S.getUndoAxesPermutation(l);g=oo({inputs:{x:m},attrs:{perm:x},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var RV={kernelName:ns,backendName:"wasm",setupFunc:eit,kernelFunc:rit};var FV;function nit(r){FV=r.wasm.cwrap(ha,null,["number","number","number","array","number","array","array","number","number"])}function oit(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=t.makeOutput(d,"float32"),x=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),w=new Uint8Array(new Int32Array(d).buffer),C=new Uint8Array(new Int32Array(y.computeStrides(d)).buffer),T=t.dataIdMap.get(h.dataId).id;return FV(x,s,i==="NHWC"?1:0,b,o.shape.length-1,w,C,d.length,T),h}var OV={kernelName:ha,backendName:"wasm",setupFunc:nit,kernelFunc:oit};var PV;function sit(r){PV=r.wasm.cwrap(os,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function iit(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p}=e,m=l==null?[1,1]:l,f=S.computeConv2DInfo(o.shape,s.shape,u,m,c,p,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,x=f.padInfo.right,b=f.padInfo.bottom,w=f.padInfo.left,C=f.dilationHeight,T=f.dilationWidth,E=f.strideHeight,$=f.strideWidth,D=f.inChannels,P=f.outChannels,M=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),H=n.dataIdMap.get(W.dataId).id;return PV(i,o.shape[0],o.shape[1],o.shape[2],a,d,h,g,x,b,w,M,C,T,E,$,D,P,H),W}var LV={kernelName:os,backendName:"wasm",setupFunc:sit,kernelFunc:iit};var MV=ae(is);var ait=!1,zV=pe(xa,ait,"bool");var BV=ae(as,"float32");function Iv(r){let{inputs:t,attrs:e,backend:n}=r,{input:o}=t,{dim:s}=e,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(y.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),lr({inputs:{x:o},backend:n,attrs:{shape:a}})}var VV={kernelName:di,backendName:"wasm",kernelFunc:Iv};function Gk(r){let{attrs:{shape:t,value:e,dtype:n},backend:o}=r,s=o.makeOutput(t,n);return o.typedArrayFromHeap(s).fill(e),s}var GV={kernelName:$l,backendName:"wasm",kernelFunc:Gk};var WV;function lit(r){WV=r.wasm.cwrap(ba,null,["number","number","number","number","number","number"])}function uit(r){let{inputs:t,backend:e}=r,{image:n}=t,o=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,[a,u,l,c]=n.shape;return WV(s,a,u,l,c,i),o}var UV={kernelName:ba,backendName:"wasm",kernelFunc:uit,setupFunc:lit};var HV=ae(ls);var cit=!1,qV=pe(us,cit);var KV;function pit(r){KV=r.wasm.cwrap(cs,null,["number","number","number","number","number","number","number"])}function mit(r){let{backend:t,inputs:e,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:i,variance:a,offset:u,scale:l}=e,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,f=u!=null?t.dataIdMap.get(u.dataId).id:0,d=l!=null?t.dataIdMap.get(l.dataId).id:0,h=t.makeOutput(s.shape,s.dtype);if(y.sizeFromShape(s.shape)===0)return h;let g=t.dataIdMap.get(h.dataId).id;return KV(c,p,m,f,d,o,g),h}var jV={kernelName:cs,backendName:"wasm",setupFunc:pit,kernelFunc:mit};var XV;function fit(r){XV=r.wasm.cwrap(ki,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dit(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m),g=Ru[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let x=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,C=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);C=at.id}let T=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,P=h.padInfo.bottom,M=h.padInfo.left,W=h.dilationHeight,H=h.dilationWidth,q=h.strideHeight,X=h.strideWidth,j=h.inChannels,Z=h.padInfo.type==="SAME"?1:0,et=h.batchSize,K=h.inHeight,ot=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,pt=a==null?0:n.dataIdMap.get(a.dataId).id;return XV(x,et,K,ot,b,T,E,C,$,D,P,M,Z,W,H,q,X,j,w,g,pt,d||0,it),st}var YV={kernelName:ki,backendName:"wasm",setupFunc:fit,kernelFunc:dit};var ZV;function hit(r){ZV=r.wasm.cwrap(_i,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function git(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!0),g=Ru[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let x=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,C=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);C=at.id}let T=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,P=h.padInfo.bottom,M=h.padInfo.left,W=h.dilationHeight,H=h.dilationWidth,q=h.strideHeight,X=h.strideWidth,j=h.inChannels,Z=h.padInfo.type==="SAME"?1:0,et=h.batchSize,K=h.inHeight,ot=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,pt=a==null?0:n.dataIdMap.get(a.dataId).id;return ZV(x,et,K,ot,b,T,E,C,$,D,P,M,Z,W,H,q,X,j,w,g,pt,d||0,it),st}var JV={kernelName:_i,backendName:"wasm",setupFunc:hit,kernelFunc:git};var QV;function xit(r){QV=r.wasm.cwrap(wa,null,["number","number","number","number","number","number","array","number"])}function yit(r){let{backend:t,inputs:e}=r,{params:n,indices:o}=e,[s,i,a,u]=yx.prepareAndValidate(n,o),l=t.makeOutput(s,n.dtype);if(i===0)return l;let c=o.shape,p=c[c.length-1],f=t.dataIdMap.get(n.dataId).id,h=t.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),x=t.dataIdMap.get(l.dataId).id;return QV(f,Zt[n.dtype],h,i,p,a,g,x),l}var tG={kernelName:wa,backendName:"wasm",setupFunc:xit,kernelFunc:yit};var eG;function bit(r){eG=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function wit(r){let{backend:t,inputs:e,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=y.parseAxisParam(i,o.shape)[0],l=t.readSync(s.dataId),c=o.shape[u];for(let P=0;P<l.length;++P){let M=l[P];y.assert(M<=c-1&&M>=0,()=>`GatherV2: the index value ${M} is not in [0, ${c-1}]`)}let p=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),m=lr({inputs:{x:o},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),f=y.sizeFromShape(s.shape),d=lr({inputs:{x:s},attrs:{shape:[p.batchSize,f/p.batchSize]},backend:t}),h=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],g=t.makeOutput(h,o.dtype);if(y.sizeFromShape(o.shape)===0)return g;let x=m.shape.length-1,w=t.dataIdMap.get(m.dataId).id,T=t.dataIdMap.get(d.dataId).id,E=t.dataIdMap.get(g.dataId).id,$=new Uint8Array(new Int32Array(y.computeStrides(m.shape)).buffer),D=new Uint8Array(new Int32Array(y.computeStrides(h)).buffer);return eG(w,Zt[o.dtype],$,x,T,p.batchSize,D,E),t.disposeData(m.dataId),t.disposeData(d.dataId),g.shape=p.outputShape,g}var rG={kernelName:hi,backendName:"wasm",setupFunc:bit,kernelFunc:wit};var Cit=!1,nG=pe(Ca,Cit,"bool");var vit=!1,oG=pe(ps,vit,"bool");var sG;function Iit(r){sG=r.wasm.cwrap(ms,null,["number","number","number","number"])}function Sit(r){let{inputs:{x:t},attrs:{alpha:e},backend:n}=r,o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(t.shape,"float32");if(y.sizeFromShape(t.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;sG(o,Zt[t.dtype],e,i)}return s}var iG={kernelName:ms,backendName:"wasm",setupFunc:Iit,kernelFunc:Sit};var Tit=!1,aG=pe(Ta,Tit,"bool");var Nit=!1,lG=pe(Na,Nit,"bool");var uG=ae(fs);var kit=!1,cG=pe(_a,kit,"bool");var pG=ae(Ea);var _it=!1,mG=pe(Aa,_it,"bool");var Eit=!1,fG=pe(k1,Eit,"bool");var dG;function Ait(r){dG=r.wasm.cwrap(ds,null,["number","number","number","number"])}function $it(r){let{backend:t,inputs:e,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("max",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),x=y.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(y.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;dG(u,Zt[i.dtype],x,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var hG={kernelName:ds,backendName:"wasm",setupFunc:Ait,kernelFunc:$it};var Dit=!1,gG=pe(hs,Dit);var xG;function Rit(r){xG=r.wasm.cwrap(gs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Fit(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id;y.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,x=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,C=c.strideWidth,T=c.inChannels,E=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let $=n.makeOutput(c.outShape,"float32"),D=n.dataIdMap.get($.dataId).id;return xG(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,x,b,w,C,T,E,D),$}var yG={kernelName:gs,backendName:"wasm",setupFunc:Rit,kernelFunc:Fit};var bG;function Oit(r){bG=r.wasm.cwrap(xs,null,["number, number, number"])}function Pit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t),d=p;if(f){let C=t.dataIdMap.get(c.dataId).id;C!==a&&(l=c,u=C,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("mean",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),x=y.sizeFromShape(g),b=l;l.dtype!=="float32"&&(b=li({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(b.dataId).id);let w=t.makeOutput(h,"float32");if(y.sizeFromShape(l.shape)!==0){let C=t.dataIdMap.get(w.dataId).id;bG(u,x,C)}if(f&&t.disposeData(c.dataId),s){let C=S.expandShapeToKeepDim(w.shape,m);w.shape=C}return l.dtype!=="float32"&&t.disposeData(b.dataId),w}var wG={kernelName:xs,backendName:"wasm",setupFunc:Oit,kernelFunc:Pit};var CG;function Lit(r){CG=r.wasm.cwrap(ys,null,["number","number","number","number"])}function Mit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w)}let d=l.shape.length;S.assertAxesAreInnerMostDims("min",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),x=y.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;CG(u,Zt[i.dtype],x,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var vG={kernelName:ys,backendName:"wasm",setupFunc:Lit,kernelFunc:Mit};var zit=!1,IG=pe(bs,zit);var Wk;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(Wk||(Wk={}));var SG;function Bit(r){SG=r.wasm.cwrap(ws,null,["number","array","number","number","array","array","number","number"])}function Vit(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+t.shape[h]+d[1]),i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),u=e.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return SG(i,l,t.shape.length,Zt[t.dtype],m,f,Wk[o],u),a}var TG={kernelName:ws,backendName:"wasm",kernelFunc:Vit,setupFunc:Bit};var Git=!0,NG=pe(Cs,Git);var kG=ae(gi);function Bd(r,t){let e=new Int32Array(r.wasm.HEAPU8.buffer,t,4),n=e[0],o=e[1],s=e[2],i=e[3];return r.wasm._free(t),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:i}}var _G;function Wit(r){_G=r.wasm.cwrap(Ra,"number",["number","number","number","number","number"])}function Uit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i}=n,{boxes:a,scores:u}=e,l=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=_G(l,c,s,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=Bd(t,p);return t.wasm._free(d),t.wasm._free(h),t.makeOutput([f],"int32",m)}var EG={kernelName:Ra,backendName:"wasm",setupFunc:Wit,kernelFunc:Uit};var AG;function Hit(r){AG=r.wasm.cwrap(Fa,"number",["number","number","number","number","number","bool"])}function qit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=AG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=Bd(t,m);t.wasm._free(h);let x=t.makeOutput([d],"int32",f),b=t.makeOutput([],"int32",g);return[x,b]}var $G={kernelName:Fa,backendName:"wasm",setupFunc:Hit,kernelFunc:qit};var DG;function Kit(r){DG=r.wasm.cwrap(Oa,"number",["number","number","number","number","number","number"])}function jit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,softNmsSigma:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=DG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=Bd(t,m);t.wasm._free(g);let x=t.makeOutput([d],"int32",f),b=t.makeOutput([d],"float32",h);return[x,b]}var RG={kernelName:Oa,backendName:"wasm",setupFunc:Kit,kernelFunc:jit};var Xit=!1,FG=pe(Da,Xit,"bool");var OG;function Yit(r){OG=r.wasm.cwrap(vs,null,["number","number","number","number","number"])}function Zit(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:u}=n,l=e.makeOutput([...o.shape,i],s),c=e.dataIdMap.get(l.dataId).id,m=e.dataIdMap.get(o.dataId).id;return OG(m,i,a,u,c),l}var PG={kernelName:vs,backendName:"wasm",setupFunc:Yit,kernelFunc:Zit};function Jit(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(1),n}var LG={kernelName:xi,backendName:"wasm",kernelFunc:Jit};function Qit(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return Iv({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=Iv({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=Bk({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeData(c.dataId)),l}var MG={kernelName:yi,backendName:"wasm",kernelFunc:Qit};var zG;function tat(r){zG=r.wasm.cwrap(Is,null,["number","array","number","number","array","array","number","number"])}function eat(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+t.shape[g]+h[1]);if(y.sizeFromShape(t.shape)===0)return Gk({backend:e,attrs:{shape:s,value:o,dtype:t.dtype}});let i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=n.map(h=>h[0]),m=n.map(h=>h[1]),f=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return zG(i,c,t.shape.length,Zt[t.dtype],f,d,o,l),a}var Sv={kernelName:Is,backendName:"wasm",kernelFunc:eat,setupFunc:tat};var rat=!1,BG=pe(Ss,rat);var VG;function nat(r){VG=r.wasm.cwrap(Ts,null,["number","number","number"])}function oat(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,a=s,u=n,l=u;u.dtype!=="float32"&&(l=li({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),a=e.dataIdMap.get(l.dataId).id);let c=e.makeOutput(n.shape,"float32"),p=e.dataIdMap.get(c.dataId).id;return VG(a,i,p),u.dtype!=="float32"&&e.disposeData(l.dataId),c}var GG={kernelName:Ts,backendName:"wasm",setupFunc:nat,kernelFunc:oat};var WG;function sat(r){WG=r.wasm.cwrap(Ns,null,["number","number","number","number"])}function iat(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("prod",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),x=y.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;WG(u,x,Zt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var UG={kernelName:Ns,backendName:"wasm",setupFunc:sat,kernelFunc:iat};var aat=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=Mc(n,o,s,i),u=t.makeOutput([a.length],i);return t.typedArrayFromHeap(u).set(a),u},HG={kernelName:Fl,backendName:"wasm",kernelFunc:aat};var lat=!0,qG=pe(ss,lat);var KG=ae(ks);var jG=ae(As);var XG;function uat(r){XG=r.wasm.cwrap(Es,null,["number","number","number","number","number","number","number","number","number","number"])}function cat(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[c,p,m,f]=o.shape,d=[c,u,l,f],h=t.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=li({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(g.dataId));let x=h.id,b=t.makeOutput(d,"float32");if(y.sizeFromShape(o.shape)===0)return b;let w=t.dataIdMap.get(b.dataId).id;return XG(x,c,p,m,f,u,l,s?1:0,i?1:0,w),g!=null&&t.disposeData(g.dataId),b}var YG={kernelName:Es,backendName:"wasm",setupFunc:uat,kernelFunc:cat};var ZG;function pat(r){ZG=r.wasm.cwrap(_s,null,["number","number","number","number","number","number","number","number","number","number"])}function mat(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[c,p,m,f]=o.shape,d=[c,u,l,f],h=t.makeOutput(d,"float32");if(y.sizeFromShape(o.shape)===0)return h;let g=t.dataIdMap.get(o.dataId),x;g.dtype!=="float32"&&(x=li({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(x.dataId));let b=g.id,w=t.dataIdMap.get(h.dataId).id;return ZG(b,c,p,m,f,u,l,s?1:0,i?1:0,w),x!=null&&t.disposeData(x.dataId),h}var JG={kernelName:_s,backendName:"wasm",setupFunc:pat,kernelFunc:mat};var QG;function fat(r){QG=r.wasm.cwrap($s,null,["number","array","number","array","number","number"])}function dat(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=y.parseAxisParam(s,o.shape);if(o.shape.length===0)return rp({inputs:{x:o},backend:e});let a=e.makeOutput(o.shape,o.dtype),u=e.dataIdMap.get(o.dataId).id,l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer);QG(u,c,i.length,p,o.shape.length,l);let m=lr({inputs:{x:a},attrs:{shape:o.shape},backend:e});return e.disposeData(a.dataId),m}var tW={kernelName:$s,backendName:"wasm",kernelFunc:dat,setupFunc:fat};var eW;function hat(r){eW=r.wasm.cwrap(qa,null,["number","number","number","number","number","number","number","number","array","number","number"])}function gat(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{radians:s,fillValue:i,center:a}=n,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(o.dataId).id,c=e.dataIdMap.get(u.dataId).id,[p,m,f,d]=o.shape,[h,g]=S.getImageCenter(a,m,f),x=i===0,b=255,w=typeof i=="number"?[i,i,i,x?0:b]:[...i,b],C=new Uint8Array(new Int32Array(w).buffer);return eW(l,p,m,f,d,s,h,g,C,w.length,c),u}var rW={kernelName:qa,backendName:"wasm",kernelFunc:gat,setupFunc:hat};var nW=ae(Ds);var oW=ae(Rs);var sW;function xat(r){sW=r.wasm.cwrap(La,null,["number","number","number","number","number","number","array","number","number"])}function yat(r){let{backend:t,inputs:e,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,a=t.makeOutput(i,s.dtype);if(y.sizeFromShape(i)===0)return a;let{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=yh.calculateShapes(s,o,i),d=t.dataIdMap.get(o.dataId).id,g=t.dataIdMap.get(s.dataId).id,x=new Uint8Array(new Int32Array(p).buffer),b=t.dataIdMap.get(a.dataId).id;return sW(d,g,Zt[s.dtype],u,l,c,x,m,b),a}var iW={kernelName:La,backendName:"wasm",setupFunc:xat,kernelFunc:yat};var aW;function bat(r){aW=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function wat(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=e.makeOutput(o.shape,o.dtype),c=e.dataIdMap.get(l.dataId).id,p=n.shape.length,m=o.shape.length,f=p===0||p>1||m===1?1:y.sizeFromShape(o.shape.slice(1));return aW(i,a,u,f,c),l}var lW={kernelName:wi,backendName:"wasm",kernelFunc:wat,setupFunc:bat};var uW;function Cat(r){uW=r.wasm.cwrap(Os,null,["number","number"])}function vat(r){let{backend:t,inputs:{x:e}}=r,n=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(e.shape,e.dtype),s=t.dataIdMap.get(o.dataId).id;return y.sizeFromShape(o.shape)===0||uW(n,s),o}var cW={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Cat,kernelFunc:vat};var pW=ae(Fs);var mW;function Iat(r){mW=r.wasm.cwrap(Ms,null,["number","number","number","number"])}function Sat(r){let{backend:t,inputs:{logits:e},attrs:{dim:n}}=r,o=t.dataIdMap.get(e.dataId).id,s=t.makeOutput(e.shape,e.dtype),i=t.dataIdMap.get(s.dataId).id,a=e.shape[n],u=y.sizeFromShape(e.shape)/a;return y.sizeFromShape(s.shape)===0||mW(o,i,a,u),s}var fW={kernelName:Ms,backendName:"wasm",setupFunc:Iat,kernelFunc:Sat};function Tat(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n,a=y.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=Sv.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=lr({inputs:{x:l},backend:e,attrs:{shape:c}}),b=oo({inputs:{x:h},backend:e,attrs:{perm:p}}),T=lr({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeData(l.dataId),e.disposeData(h.dataId),e.disposeData(b.dataId),T}var dW={kernelName:vi,backendName:"wasm",kernelFunc:Tat};var hW;function Nat(r){hW=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function kat(r){let{backend:t,inputs:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e,a=n.shape[0],u=n.shape[1],l=t.readSync(s.dataId)[0],c=[a+l,u],p=t.dataIdMap.get(n.dataId).id,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(i.dataId).id,d=t.makeOutput(c,n.dtype),h=t.dataIdMap.get(d.dataId).id,g=t.makeOutput(c.slice(0,1),o.dtype),x=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([l],"bool"),w=t.dataIdMap.get(b.dataId).id,C=t.makeOutput([a],n.dtype),T=t.dataIdMap.get(C.dataId).id,E=t.makeOutput([4],"int32"),$=t.dataIdMap.get(E.dataId).id,D=hW(p,m,Zt[o.dtype],a,l,u,f,h,x,w,T,$),P=t.readSync(E.dataId),M;switch(P[0]){case 1:{M=S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(P[1]);break}case 2:{M=S.getSparseFillEmptyRowsNegativeIndexErrorMessage(P[1],P[2]);break}case 3:M=S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(P[1],P[2],P[3]);break;default:M=""}if(t.disposeData(E.dataId),M)throw t.disposeData(d.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(C.dataId),new Error(M);let W=d,H=g;return D!==c[0]&&(W=Po({inputs:{x:d},attrs:{begin:0,size:[D,u]},backend:t}),H=Po({inputs:{x:g},attrs:{begin:0,size:D},backend:t}),t.disposeData(d.dataId),t.disposeData(g.dataId)),[W,H,b,C]}var gW={kernelName:Ol,backendName:"wasm",setupFunc:Nat,kernelFunc:kat};var xW;function _at(r){xW=r.wasm.cwrap(Ga,null,["number","number","number","number","number","number","number"])}function Eat(r){let{backend:t,inputs:e}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=n.shape[0],c=y.sizeFromShape(s.shape),p=t.makeOutput([l,c],n.dtype),m=t.dataIdMap.get(p.dataId).id,f=t.makeOutput([c],s.dtype),d=t.dataIdMap.get(f.dataId).id,h=t.makeOutput([3],"int32"),g=t.dataIdMap.get(h.dataId).id;xW(i,a,u,l,m,d,g);let x=t.readSync(h.dataId),b;switch(x[0]){case 0:{b=S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(x[1],x[2]);break}case 1:{b=S.getSparseReshapeNegativeOutputDimErrorMessage(x[1],x[2]);break}case 2:b=S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let w=Array.from(t.readSync(o.dataId)),C=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMultipleErrorMessage(w,C);break}case 4:{let w=Array.from(t.readSync(o.dataId)),C=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMismatchErrorMessage(w,C);break}default:b=""}if(t.disposeData(h.dataId),b)throw t.disposeData(p.dataId),t.disposeData(f.dataId),new Error(b);return[p,f]}var yW={kernelName:Ga,backendName:"wasm",setupFunc:_at,kernelFunc:Eat};var bW;function Tv(r){bW=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Nv(r,t){let{backend:e,inputs:n}=r,{data:o,indices:s,segmentIds:i}=n,a=s.shape[0],u=e.readSync(i.dataId,a-1,a)[0],c=a>0?u+1:0;if(c<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=o.shape.slice();p[0]=c;let m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=e.dataIdMap.get(i.dataId).id,h=e.makeOutput(p,o.dtype),g=e.dataIdMap.get(h.dataId).id,x=e.makeOutput([4],"int32"),b=e.dataIdMap.get(x.dataId).id;bW(m,Zt[o.dtype],o.shape[0],f,d,g,b,t,0);let w=e.readSync(x.dataId),C;switch(w[0]){case 0:{C=S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{C=S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:C=S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:C=S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:C=""}if(e.disposeData(x.dataId),C)throw e.disposeData(h.dataId),new Error(C);return h}function Aat(r){return Nv(r,!0)}var wW={kernelName:Pl,backendName:"wasm",setupFunc:Tv,kernelFunc:Aat};function $at(r){return Nv(r,!1)}var CW={kernelName:Ll,backendName:"wasm",setupFunc:Tv,kernelFunc:$at};function Dat(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=e,a=y.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=Po({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[a]+=p,f})}var vW={kernelName:Ii,backendName:"wasm",kernelFunc:Dat};var IW=ae(Ps);var SW=ae(Ml);var Rat=!0,TW=pe(zs,Rat);var NW;function Fat(r){NW=r.wasm.cwrap(co,null,["number","number","number","number"])}function Oat(r){let{backend:t,inputs:e,attrs:n}=r,{alpha:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(a.dataId).id;return NW(i,o,Zt[s.dtype],u),a}var kW={kernelName:co,backendName:"wasm",setupFunc:Fat,kernelFunc:Oat};var _W;function Pat(r){_W=r.wasm.cwrap(Wa,null,["number","array","number","array","array","array","array","array","number","number"])}function Lat(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:b,end:w,strides:C}=Be.sliceInfo(o.shape,s,i,a,u,l,c,p,m),T;if(h)T=lr({inputs:{x:o},backend:t,attrs:{shape:d}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Be.computeOutShape(b,w,C),$=Po({inputs:{x:o},backend:t,attrs:{begin:b,size:E}});T=lr({inputs:{x:$},backend:t,attrs:{shape:d}}),t.disposeData($.dataId)}else{let E=t.makeOutput(f,"float32"),$=t.dataIdMap.get(o.dataId).id,D=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),P=new Uint8Array(new Int32Array(b).buffer),M=new Uint8Array(new Int32Array(w).buffer),W=new Uint8Array(new Int32Array(C).buffer),H=new Uint8Array(new Int32Array(f).buffer),q=new Uint8Array(new Int32Array(y.computeStrides(f)).buffer),X=t.dataIdMap.get(E.dataId).id;_W($,D,o.shape.length,P,M,W,H,q,f.length,X),T=lr({inputs:{x:E},backend:t,attrs:{shape:d}}),t.disposeData(E.dataId)}return T}var EW={kernelName:Wa,backendName:"wasm",setupFunc:Pat,kernelFunc:Lat};function Mat(r){let{backend:t,inputs:e,attrs:n}=r,{data:o,dataSplits:s}=e,{separator:i,nGramWidths:a,leftPad:u,rightPad:l,padWidth:c,preserveShortSequences:p}=n,m=t.readSync(o.dataId),f=t.readSync(s.dataId),[d,h]=Bc(m,f,i,a,u,l,c,p),g=t.makeOutput([d.length],"string"),x=t.dataIdMap.get(g.dataId);x.stringBytes=d;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(h),[g,b]}var AW={kernelName:zl,backendName:"wasm",kernelFunc:Mat};function zat(r){let{backend:t,inputs:e,attrs:n}=r,{input:o,delimiter:s}=e,{skipEmpty:i}=n,a=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,c,p]=Vc(a,u[0],i),m=c.length,f=t.makeOutput([m,2],"int32");t.typedArrayFromHeap(f).set(l);let h=t.makeOutput([m],"string"),g=t.dataIdMap.get(h.dataId);g.stringBytes=c;let x=t.makeOutput([2],"int32");return t.typedArrayFromHeap(x).set(p),[f,h,x]}var $W={kernelName:Bl,backendName:"wasm",kernelFunc:zat};function Bat(r){let{backend:t,inputs:e,attrs:n}=r,{input:o}=e,{numBuckets:s}=n,i=t.readSync(o.dataId),a=Gc(i,s),u=t.makeOutput(o.shape,"int32");return t.typedArrayFromHeap(u).set(a),u}var DW={kernelName:Vl,backendName:"wasm",kernelFunc:Bat};var Vat=!0,RW=pe(Bs,Vat);var FW;function Gat(r){FW=r.wasm.cwrap(Ls,null,["number","number","number","number"])}function Wat(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=wn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("sum",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),x=y.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;FW(u,x,Zt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var OW={kernelName:Ls,backendName:"wasm",setupFunc:Gat,kernelFunc:Wat};var PW=ae(Vs);var LW=ae(Gs);var MW;function Uat(r){MW=r.wasm.cwrap(Xn,null,["number","array","number","array","number","number"])}function Hat(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,s=e.dataIdMap.get(o.dataId).id,{reps:i}=n,a=new Array(o.shape.length);for(let m=0;m<a.length;m++)a[m]=o.shape[m]*i[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(a).buffer),c=e.makeOutput(a,o.dtype),p=e.dataIdMap.get(c.dataId).id;return MW(s,u,o.shape.length,l,a.length,Zt[c.dtype],p),c}var zW={kernelName:Xn,backendName:"wasm",setupFunc:Uat,kernelFunc:Hat};var BW;function qat(r){BW=r.wasm.cwrap(Ua,null,["number","array","number","number","number","bool","number","number"])}var Kat=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{k:o,sorted:s}=e,i=t.dataIdMap.get(n.dataId).id,a=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=t.makeOutput(u,n.dtype),c=t.dataIdMap.get(l.dataId).id,p=t.makeOutput(u,"int32"),m=t.dataIdMap.get(p.dataId).id;return BW(i,a,n.shape.length,Zt[n.dtype],o,s,c,m),[l,p]},VW={kernelName:Ua,backendName:"wasm",setupFunc:qat,kernelFunc:Kat};var GW;function jat(r){GW=r.wasm.cwrap(Ha,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Xat(r){let{backend:t,inputs:e,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],x=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),b=new Uint8Array(new Int32Array(y.computeStrides(g)).buffer),w=t.makeOutput(g,o.dtype),C=t.dataIdMap.get(w.dataId).id,E=t.dataIdMap.get(o.dataId).id,D=t.dataIdMap.get(s.dataId).id,P=i==="nearest"?1:2,M;switch(a){case"constant":M=1;break;case"reflect":M=2;break;case"wrap":M=3;break;case"nearest":M=4;break;default:M=1;break}return GW(E,D,s.shape[0]>1,c,d,h,f,m,p,x,o.shape.length-1,b,g.length-1,P,M,u,C),w}var WW={kernelName:Ha,backendName:"wasm",setupFunc:jat,kernelFunc:Xat};function Yat(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape[s],a=o.shape.length,u=new Array(a-1),l=0;for(let f=0;f<a;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i),p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)p[s]=f,c[f]=Po({inputs:{x:o},attrs:{begin:p,size:m},backend:e});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:u}))}var UW={kernelName:Si,backendName:"wasm",kernelFunc:Yat};function Zat(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(0),n}var HW={kernelName:Ti,backendName:"wasm",kernelFunc:Zat};var Jat=[YB,ZB,JB,tV,sV,aV,uV,pV,dV,gV,xV,yV,wV,CV,IV,TV,NV,kV,EV,$V,RV,OV,LV,MV,zV,BV,VV,GV,UV,HV,qV,jV,YV,JV,tG,rG,nG,oG,eV,iG,aG,lG,uG,cG,pG,mG,fG,hG,gG,yG,wG,vG,IG,TG,NG,kG,EG,$G,RG,FG,PG,LG,MG,Sv,BG,GG,UG,HG,qG,KG,jG,mV,YG,JG,tW,rW,nW,oW,iW,lW,cW,pW,hV,fW,dW,gW,yW,wW,CW,vW,IW,SW,TW,kW,EW,AW,$W,DW,RW,OW,PW,LW,zW,VW,WW,nV,UW,HW];for(let r of Jat)Wu(r);var Uk=B();Uk.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));Uk.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Uk.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var Yk=Tl(XW()),eU=Tl(ZW()),Zk=Tl(JW());var QW=Yk.default||Yk,Qat=Zk.default||Zk,bg=class extends Ho{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(nU),Xk=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ra(this,go())}write(t,e,n){let o={id:this.dataIdNextNumber++};return this.move(o,t,e,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let e=y.now();return t(),{kernelMs:y.now()-e}}move(t,e,n,o,s){let i=this.dataIdNextNumber++;if(o==="string"){let c=e;this.dataIdMap.set(t,{id:i,stringBytes:c,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let a=y.sizeFromShape(n),u=a*y.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(t,{id:i,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(i,a,l),e!=null&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,u),l)}async read(t){return this.readSync(t)}readSync(t,e,n){let{memoryOffset:o,dtype:s,shape:i,stringBytes:a}=this.dataIdMap.get(t);if(s==="string")return(e==null||e===0)&&(n==null||n>=a.length)?a:a.slice(e,n);e=e||0,n=n||y.sizeFromShape(i);let u=y.bytesPerElement(s),l=this.wasm.HEAPU8.slice(o+e*u,o+n*u);return elt(l.buffer,s)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){let n=this.dataIdMap.get(t);if(n.refCount--,!e&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let e=this.dataIdMap.get(t);e!=null&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,n){let o;if(n==null)o=this.write(null,t,e);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:t,dtype:e,refCount:1});let i=y.sizeFromShape(t);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:o,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),i=y.sizeFromShape(t);switch(e){case"float32":return new Float32Array(o,s,i);case"int32":return new Int32Array(o,s,i);case"bool":return new Uint8Array(o,s,i);default:throw new Error(`Unknown dtype ${e}`)}}};function tlt(r){return(t,e)=>(y.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||t.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,t).then(s=>{e(s.instance,s.module)})})}),{})}function tU(r,t,e){if(Ev!=null)return Ev;let n="tfjs-backend-wasm.wasm";return r&&t?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),xg!=null&&xg[n]!=null?xg[n]:e+n}async function rU(){let[r,t]=await Promise.all([B().getAsync("WASM_HAS_SIMD_SUPPORT"),B().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((e,n)=>{let o={};o.locateFile=(a,u)=>{if(a.endsWith(".worker.js")){let l=eU.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return a.endsWith(".wasm")?tU(r,t,gg!=null?gg:u):u+a},Jk&&(o.instantiateWasm=tlt(tU(r,t,gg!=null?gg:"")));let s=!1;o.onAbort=()=>{if(s||yg)return;yg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;t&&r&&Ev==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+QW.toString()],{type:"text/javascript"}),i=QW(o)):i=Qat(o),i.then(a=>{s=!0,yg=!1;let u=null;a.tfjs={init:a.cwrap("init",null,[]),initWithThreadsCount:a.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:a.cwrap("get_threads_count","number",[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",u,["number"]),dispose:a.cwrap("dispose",u,[])},e({wasm:a})}).catch(n)})}function elt(r,t){switch(t){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${t}`)}}var rlt=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Ev=null,gg=null,xg={},yg=!1,Jk=!1;function nlt(r,t=!1){if(tS("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),yg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Ev=r,Jk=t}function olt(r,t=!1){if(yg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")gg=r;else{xg=r;let e=rlt.filter(n=>xg[n]==null);if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Jk=t}var nU=-1,Xk=-1;function slt(r){nU=r}function ilt(){if(Xk===-1)throw new Error("WASM backend not initialized.");return Xk}var alt="3.20.0";var llt=2;lm("wasm",async()=>{let{wasm:r}=await rU();return new bg(r)},llt);var ult="3.20.0",clt="3.20.0",plt="3.20.0",mlt="3.20.0",flt="3.20.0",dlt="3.20.0",hlt="3.20.0",glt="3.20.0",xlt={tfjs:ult,"tfjs-core":clt,"tfjs-data":plt,"tfjs-layers":mlt,"tfjs-converter":flt,"tfjs-backend-cpu":dlt,"tfjs-backend-webgl":hlt,"tfjs-backend-wasm":glt};export{pi as Abs,oa as Acos,sa as Acosh,cu as AdadeltaOptimizer,pu as AdagradOptimizer,mu as AdamOptimizer,fu as AdamaxOptimizer,jn as Add,jo as AddN,ia as All,aa as Any,Xo as ArgMax,Nl as ArgMin,la as Asin,ua as Asinh,ca as Atan,ma as Atan2,pa as Atanh,Yo as AvgPool,kl as AvgPool3D,Ip as AvgPool3DGrad,vp as AvgPoolGrad,bg as BackendWasm,Zo as BatchMatMul,mi as BatchToSpaceND,Sp as Bincount,Tp as BroadcastArgs,N1 as BroadcastTo,Lb as Callback,Yy as CallbackList,ao as Cast,Jo as Ceil,lo as ClipByValue,Np as Complex,_l as ComplexAbs,fi as Concat,Qo as Conv2D,kp as Conv2DBackpropFilter,ts as Conv2DBackpropInput,El as Conv3D,_p as Conv3DBackpropFilterV2,Ep as Conv3DBackpropInputV2,es as Cos,rs as Cosh,da as CropAndResize,fa as Cumprod,ns as Cumsum,Jy as CustomCallback,ra as DataStorage,Ap as DenseBincount,ha as DepthToSpace,os as DepthwiseConv2dNative,$p as DepthwiseConv2dNativeBackpropFilter,Dp as DepthwiseConv2dNativeBackpropInput,Rp as Diag,Al as Dilation2D,sh as Dilation2DBackpropFilter,oh as Dilation2DBackpropInput,y0 as ENV,Mb as EarlyStopping,Fp as Einsum,is as Elu,Op as EluGrad,rh as Environment,xa as Equal,ga as Erf,as as Exp,di as ExpandDims,ya as Expm1,Pp as FFT,$l as Fill,ba as FlipLeftRight,ls as Floor,us as FloorDiv,ih as FromPixels,cs as FusedBatchNorm,ki as FusedConv2D,_i as FusedDepthwiseConv2D,jc as GPGPUContext,wa as GatherNd,hi as GatherV2,Hh as GraphModel,Ca as Greater,ps as GreaterEqual,Zy as History,Lp as IFFT,uo as Identity,Mp as Imag,we as InputSpec,va as IsFinite,Ia as IsInf,Sa as IsNan,Ho as KernelBackend,Dl as LRN,Bp as LRNGrad,Ah as LayerVariable,Bn as LayersModel,ms as LeakyRelu,Ta as Less,Na as LessEqual,zp as LinSpace,fs as Log,ka as Log1p,_1 as LogSoftmax,_a as LogicalAnd,Ea as LogicalNot,Aa as LogicalOr,k1 as LogicalXor,Ilt as LowerBound,Eu as MathBackendWebGL,ds as Max,gs as MaxPool,Rl as MaxPool3D,Gp as MaxPool3DGrad,Vp as MaxPoolGrad,Wp as MaxPoolWithArgmax,hs as Maximum,xs as Mean,ys as Min,bs as Minimum,ws as MirrorPad,$a as Mod,du as MomentumOptimizer,Up as Multinomial,Cs as Multiply,gi as Neg,Ra as NonMaxSuppressionV3,Fa as NonMaxSuppressionV4,Oa as NonMaxSuppressionV5,Da as NotEqual,z0 as OP_SCOPE_SUFFIX,vs as OneHot,xi as OnesLike,Br as Optimizer,js as OptimizerConstructors,yi as Pack,Is as PadV2,Slt as Pool,Ss as Pow,Ts as Prelu,Ns as Prod,hu as RMSPropOptimizer,_n as RNN,Hp as RaggedTensorToTensor,Fl as Range,E0 as Rank,qp as Real,ss as RealDiv,Pa as Reciprocal,Ye as Reduction,ks as Relu,As as Relu6,bi as Reshape,Es as ResizeBilinear,jp as ResizeBilinearGrad,_s as ResizeNearestNeighbor,Kp as ResizeNearestNeighborGrad,$s as Reverse,qa as RotateWithOffset,Ds as Round,Rs as Rsqrt,qi as SGDOptimizer,La as ScatterNd,Xp as SearchSorted,wi as Select,Ma as Selu,Ji as Sequential,Os as Sigmoid,Ba as Sign,Fs as Sin,za as Sinh,Ci as Slice,Ms as Softmax,Va as Softplus,vi as SpaceToBatchND,Ol as SparseFillEmptyRows,Ga as SparseReshape,Pl as SparseSegmentMean,Ll as SparseSegmentSum,Yp as SparseToDense,Ii as SplitV,Ps as Sqrt,Ml as Square,zs as SquaredDifference,co as Step,Wa as StridedSlice,zl as StringNGrams,Bl as StringSplit,Vl as StringToHashBucketFast,Bs as Sub,Ls as Sum,Xr as SymbolicTensor,Vs as Tan,Gs as Tanh,Lt as Tensor,fe as TensorBuffer,Xn as Tile,Ua as TopK,Ha as Transform,Yn as Transpose,Zp as Unique,Si as Unpack,Gl as UnsortedSegmentSum,Tlt as UpperBound,Ka as Variable,Ti as ZerosLike,Ni as _FusedMatMul,$e as abs,Cx as acos,vx as acosh,J as add,J_ as addN,cm as all,Ju as any,Oi as argMax,Ix as argMin,Sx as asin,Tx as asinh,Nx as atan,kx as atan2,_x as atanh,Xl as avgPool,Ax as avgPool3d,$_ as backend,S as backend_util,eE as basicLSTMCell,Li as batchNorm,$x as batchNorm2d,Dx as batchNorm3d,Rx as batchNorm4d,Yl as batchToSpaceND,Fx as bincount,w6 as booleanMaskAsync,nE as broadcastArgs,Mi as broadcastTo,Lr as broadcast_util,xx as browser,vt as buffer,tZ as callbacks,tt as cast,Ox as ceil,Ir as clipByValue,an as clone,Cn as complex,se as concat,Px as concat1d,Lx as concat2d,Mx as concat3d,zx as concat4d,aD as constraints,mm as conv1d,Sn as conv2d,dm as conv2dTranspose,Bx as conv3d,Gx as conv3dTranspose,Dlt as copyRegisteredKernels,Zl as cos,hm as cosh,Sh as cosineWindow,ec as cumprod,gm as cumsum,un as customGrad,GR as data,oE as denseBincount,tS as deprecationWarn,Wx as depthToSpace,zi as depthwiseConv2d,oZ as deregisterOp,ql as device_util,sE as diag,Ux as dilation2d,vpt as disableDeprecationWarnings,_t as dispose,Ipt as disposeVariables,ct as div,Hx as divNoNan,qx as dot,bS as dropout,iE as einsum,Bi as elu,Cpt as enableDebugMode,wpt as enableProdMode,wS as enclosingPowerOfTwo,go as engine,B as env,Ar as equal,Kx as erf,jx as euclideanNorm,or as exp,yr as expandDims,Xx as expm1,nc as eye,iu as fft,Vi as fill,Ept as findBackend,Apt as findBackendFactory,Gi as floor,um as floorDiv,CM as forceHalfFloat,lu as fused,Wi as gather,E6 as gatherND,yx as gather_util,kpt as getBackend,C0 as getGradient,lh as getKernel,tx as getKernelsForBackend,ilt as getThreadsCount,xk as gpgpu_util,MK as grad,zK as grads,Xe as greater,Pn as greaterEqual,Qa as ifft,jl as imag,uu as image,D6 as inTopKAsync,lD as initializers,KS as input,vn as io,Am as irfft,Yx as isFinite,Zx as isInf,Jx as isNaN,Oe as keep,Vr as kernel_impls,BD as layers,Jl as leakyRelu,xm as less,Ln as lessEqual,vS as linalg,uE as linspace,ZZ as loadGraphModel,JZ as loadGraphModelSync,pY as loadLayersModel,Qx as localResponseNormalization,Sr as log,Ql as log1p,ry as logSigmoid,ym as logSoftmax,bm as logSumExp,Dr as logicalAnd,tu as logicalNot,wm as logicalOr,ny as logicalXor,D5 as losses,cE as lowerBound,Gt as matMul,R_ as math,Mr as max,eu as maxPool,sy as maxPool3d,pE as maxPoolWithArgmax,Tn as maximum,ke as mean,xh as memory,mE as meshgrid,VD as metrics,rc as min,Ui as minimum,iy as mirrorPad,ay as mod,uY as model,GD as models,oc as moments,v6 as movingAverage,O as mul,fE as multiRNNCell,dE as multinomial,Yt as neg,Th as nextFrame,Ja as norm,qs as notEqual,Ri as oneHot,cr as ones,br as onesLike,N as op,hE as outerProduct,cn as pad,gE as pad1d,xE as pad2d,yE as pad3d,bE as pad4d,ly as pool,ln as pow,nu as prelu,mx as print,uy as prod,Spt as profile,wE as raggedTensorToTensor,CE as rand,ME as randomGamma,ac as randomNormal,zE as randomStandardNormal,Hi as randomUniform,ou as range,Npt as ready,Za as real,dy as reciprocal,lm as registerBackend,mY as registerCallbackConstructor,A1 as registerGradient,Wu as registerKernel,nZ as registerOp,WD as regularizers,Rr as relu,Cm as relu6,_pt as removeBackend,F as reshape,pr as reverse,BE as reverse1d,VE as reverse2d,GE as reverse3d,WE as reverse4d,au as rfft,vm as round,Im as rsqrt,mt as scalar,S6 as scatterND,yh as scatter_util,Ch as searchSorted,Sm as selu,Tm as separableConv2d,cY as sequential,rt as serialization,bH as setBackend,$pt as setPlatform,slt as setThreadsCount,nlt as setWasmPath,olt as setWasmPaths,$N as setWebGLContext,UE as setdiff1dAsync,Kr as sigmoid,hy as sign,$5 as signal,Nm as sin,km as sinh,Ot as slice,_m as slice1d,Ih as slice2d,Em as slice3d,lc as slice4d,Be as slice_util,su as softmax,Hs as softplus,ru as spaceToBatchND,R5 as sparse,k6 as sparseToDense,A5 as spectral,mr as split,Ne as sqrt,Ht as square,$m as squaredDifference,Mn as squeeze,sr as stack,yo as step,gy as stridedSlice,F5 as string,ut as sub,ft as sum,Xu as sumOutType,xy as tan,Pi as tanh,vr as tensor,Ve as tensor1d,Ks as tensor2d,gx as tensor3d,HE as tensor4d,qE as tensor5d,KE as tensor6d,ho as tensor_util,Y_ as test_util,G as tidy,$r as tile,Tpt as time,yy as topk,fc as train,Mt as transpose,Dm as truncatedNormal,by as unique,$lt as unregisterGradient,Alt as unregisterKernel,Rm as unsortedSegmentSum,Tr as unstack,ir as upcastType,jE as upperBound,y as util,BK as valueAndGrad,VK as valueAndGrads,wy as variable,ty as variableGrads,xlt as version,vR as version_converter,Z_ as version_core,nf as version_layers,alt as version_wasm,wM as version_webgl,ike as webgl,Id as webgl_util,De as where,vy as whereAsync,_e as zeros,St as zerosLike};
